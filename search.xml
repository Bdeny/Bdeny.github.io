<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内核对设备树的处理(3)]]></title>
    <url>%2F2020%2F01%2F11%2F0041-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%A4%84%E7%90%86-3%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;根据 devicetree-specification-v0.2.pdf p43 中的说明: 1234Linux uses DT data for three major purposes: 1) platform identification, 2) runtime configuration, and 3) device population. &emsp;&emsp;本文根据这个过程分析内核对设备树的处理流程。 从源头分析&emsp;&emsp;内核head.S对dtb的简单处理：&emsp;&emsp;bootloader启动内核时,会设置r0,r1,r2三个寄存器：&emsp;&emsp;&emsp;&emsp;r0 一般设置为 0;&emsp;&emsp;&emsp;&emsp;r1 一般设置为 machine id (在使用设备树时该参数没有被使用);&emsp;&emsp;&emsp;&emsp;r2 一般设置 ATAGS 或 DTB 的开始地址 &emsp;&emsp;bootloader给内核传递的参数时有2种方法：&emsp;&emsp;&emsp;&emsp;ATAGS 或 DTB&emsp;&emsp;&emsp;&emsp;ATAGS 传参方法：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;a. lookup_processor_type : 使用汇编指令读取CPU ID, 根据该ID找到对应的proc_info_list结构体(里面含有这类CPU的初始化函数、信息)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b. __vet_atags : 判断是否存在可用的ATAGS或DTB&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c. __create_page_tables : 创建页表, 即创建虚拟地址和物理地址的映射关系&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d. __enable_mmu : 使能MMU, 以后就要使用虚拟地址了&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e. __mmap_switched : 上述函数里将会调用mmap_switched&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f. 把bootloader传入的r2参数, 保存到变量__atags_pointer中&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;g. 调用C函数start_kernel &emsp;&emsp;head.S/head-common.S 中:&emsp;&emsp;&emsp;&emsp;把bootloader传来的r1值, 赋给了C变量: __machine_arch_type&emsp;&emsp;&emsp;&emsp;把bootloader传来的r2值, 赋给了C变量: __atags_pointer // dtb首地址 内核设备树中平台信息的处理 (选择 machine_desc)&emsp;&emsp;a. 设备树 dts 根节点的 compatible 属性列出了一系列的字符串,&emsp;&emsp;&emsp;&emsp;表示它兼容的单板名,&emsp;&emsp;&emsp;&emsp;从左到右列出的表示：从”最兼容”到次之 123456/* dts 声明了期望哪些 madine_desc *//&#123; model = "SMDK2440"; compatible = "samsung,smdk2440","samsung,smdk2410","samsung,smdk24xx"; /* 单板 最好 次之 第三选择 */&#125; &emsp;&emsp;b. 内核中有多个 machine_desc ，每个 machine_desc 表明能支持哪些单板： 12345struct machine_desc&#123; .init; .nr; .dt_compat;&#125; 1234567891011121314static const char*const smdk2440 dt_compat[]initconst=&#123; "samsung,smdk2440", NULL&#125;;MACHINE START（S3C2440,"SMDK2440"） /*aintainer:Ben Dooks &lt;ben-linuxefluff.org&gt;*/ .atag offset = 0x100, ·dt compat = smak240_dt_compat, .init_irg = s3c2440_init_irq, .map_io = smdk2440_map_io, .init_machine = smdk2440_machine_init, .init_time = smdk2440 init time,MACHINE_END &emsp;&emsp;&emsp;&emsp;其中有 dt_compat 成员, 它指向一个字符串数组, 里面表示该 machine_desc 支持哪些单板 &emsp;&emsp;c. 有多个 machine_desc 跟 dts 吻合，选择哪个？&emsp;&emsp;&emsp;&emsp;使用 compatile 属性的值,&emsp;&emsp;&emsp;&emsp;跟&emsp;&emsp;&emsp;&emsp;每一个 machine_desc.dt_compat&emsp;&emsp;&emsp;&emsp;比较,&emsp;&emsp;&emsp;&emsp;成绩为”吻合的 compatile 属性值的位置”, &emsp;&emsp;&emsp;&emsp;成绩越低越匹配, 对应的 machine_desc 即被选中 &emsp;&emsp;&emsp;&emsp;函数调用过程: 123456789101112131415start_kernel // init/main.c setup_arch(&amp;command_line); // arch/arm/kernel/setup.c mdesc = setup_machine_fdt(__atags_pointer); // arch/arm/kernel/devtree.c early_init_dt_verify(phys_to_virt(dt_phys) // 判断是否有效的dtb, drivers/of/ftd.c initial_boot_params = params; mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach); // 找到最匹配的machine_desc, drivers/of/ftd.c while ((data = get_next_compat(&amp;compat))) &#123; score = of_flat_dt_match(dt_root, compat); if (score &gt; 0 &amp;&amp; score &lt; best_score) &#123; best_data = data; best_score = score; &#125; &#125; machine_desc = mdesc; 内核对设备树中运行时配置信息的处理&emsp;&emsp;函数调用过程: 123456789101112start_kernel // init/main.c setup_arch(&amp;command_line); // arch/arm/kernel/setup.c mdesc = setup_machine_fdt(__atags_pointer); // arch/arm/kernel/devtree.c early_init_dt_scan_nodes(); // drivers/of/ftd.c /* Retrieve various information from the /chosen node */ of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line); /* Initialize &#123;size,address&#125;-cells info */ of_scan_flat_dt(early_init_dt_scan_root, NULL); /* Setup memory, calling early_init_dt_add_memory_arch */ of_scan_flat_dt(early_init_dt_scan_memory, NULL); &emsp;&emsp;a. /chosen 节点中 bootargs 属性的值, 存入全局变量： boot_command_line&emsp;&emsp;b. 确定根节点的这 2 个属性的值: #address-cells, #size-cells 存入全局变量: dt_root_addr_cells, dt_root_size_cells&emsp;&emsp;c. 解析 /memory 中的 reg 属性, 提取出 “base, size”, 最终调用 memblock_add(base, size); dtb 转换为 device_node (unflatten)&emsp;&emsp;函数调用过程: 123456789101112131415161718192021222324252627282930313233343536start_kernel // init/main.c setup_arch(&amp;command_line); // arch/arm/kernel/setup.c arm_memblock_init(mdesc); // arch/arm/kernel/setup.c early_init_fdt_reserve_self(); /* Reserve the dtb region */ // 把DTB所占区域保留下来, 即调用: memblock_reserve early_init_dt_reserve_memory_arch(__pa(initial_boot_params), fdt_totalsize(initial_boot_params), 0); early_init_fdt_scan_reserved_mem(); // 根据dtb中的memreserve信息, 调用memblock_reserve unflatten_device_tree(); // arch/arm/kernel/setup.c __unflatten_device_tree(initial_boot_params, NULL, &amp;of_root, early_init_dt_alloc_memory_arch, false); // drivers/of/fdt.c /* First pass, scan for size */ size = unflatten_dt_nodes(blob, NULL, dad, NULL); /* Allocate memory for the expanded device tree */ mem = dt_alloc(size + 4, __alignof__(struct device_node)); /* Second pass, do actual unflattening */ unflatten_dt_nodes(blob, mem, dad, mynodes); populate_node np = unflatten_dt_alloc(mem, sizeof(struct device_node) + allocl, __alignof__(struct device_node)); np-&gt;full_name = fn = ((char *)np) + sizeof(*np); populate_properties pp = unflatten_dt_alloc(mem, sizeof(struct property), __alignof__(struct property)); pp-&gt;name = (char *)pname; pp-&gt;length = sz; pp-&gt;value = (__be32 *)val; &emsp;&emsp;a. 在DTB文件中,&emsp;&emsp;&emsp;&emsp;每一个节点都以 TAG(FDT_BEGIN_NODE, 0x00000001) 开始, 节点内部可以嵌套其他节点,&emsp;&emsp;&emsp;&emsp;每一个属性都以 TAG(FDT_PROP, 0x00000003) 开始 &emsp;&emsp;b. 每一个节点都转换为一个 device_node 结构体: 1234567891011121314151617181920212223struct device_node &#123; const char *name; // 来自节点中的name属性, 如果没有该属性, 则设为"NULL" const char *type; // 来自节点中的device_type属性, 如果没有该属性, 则设为"NULL" phandle phandle; const char *full_name; // 节点的名字, node-name[@unit-address] struct fwnode_handle fwnode; struct property *properties; // 节点的属性 struct property *deadprops; /* removed properties */ struct device_node *parent; // 节点的父亲 struct device_node *child; // 节点的孩子(子节点) struct device_node *sibling; // 节点的兄弟(同级节点)#if defined(CONFIG_OF_KOBJ) struct kobject kobj;#endif unsigned long _flags; void *data;#if defined(CONFIG_SPARC) const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans;#endif&#125;; &emsp;&emsp;c. device_node 结构体中有 properties, 用来表示该节点的属性&emsp;&emsp;&emsp;&emsp;每一个属性对应一个 property 结构体: 123456789101112131415struct property &#123; char *name; // 属性名字, 指向dtb文件中的字符串 int length; // 属性值的长度 void *value; // 属性值, 指向dtb文件中value所在位置, 数据仍以big endian存储 struct property *next;#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC) unsigned long _flags;#endif#if defined(CONFIG_OF_PROMTREE) unsigned int unique_id;#endif#if defined(CONFIG_OF_KOBJ) struct bin_attribute attr;#endif&#125;; &emsp;&emsp;d. 这些 device_node 构成一棵树, 根节点为: of_root device_node 转换为 platform_device&emsp;&emsp;从 dts 到 platform_device 的转化过程： 1dts -&gt; dtb -&gt; device_node -&gt; platform_device 两个问题&emsp;&emsp;要理解这个过程得先理解这两个问题:&emsp;&emsp;&emsp;&emsp;a. 哪些device_node可以转换为platform_device?&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;根节点下含有compatile属性的子节点&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果一个结点的compatile属性含有这些特殊的值(“simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus”)之一, 那么它的子结点(需含compatile属性)也可以转换为platform_device&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;i2c, spi等总线节点下的子节点, 应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device &emsp;&emsp;&emsp;&emsp;b. 怎么转换?&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;platform_device中含有resource数组, 它来自device_node的reg, interrupts属性;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;platform_device.dev.of_node指向device_node, 可以通过它获得其他属性 内核的处理过程&emsp;&emsp;a. 内核函数 of_platform_default_populate_init, 遍历 device_node 树, 生成 platform_device&emsp;&emsp;b. 并非所有的 device_node 都会转换为 platform_device&emsp;&emsp;&emsp;&emsp;只有以下的 device_node 会转换:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.1 该节点必须含有compatible属性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.2 根节点的子节点(节点必须含有compatible属性)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.3 含有特殊compatible属性的节点的子节点(子节点必须含有compatible属性):&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这些特殊的compatilbe属性为: “simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus” &emsp;&emsp;b.4 示例:&emsp;&emsp;&emsp;&emsp;假设当前接入设备如下： &emsp;&emsp;&emsp;&emsp;比如以下的节点, 1234567891011121314151617181920212223242526272829/ &#123; i2c &#123; // --&gt; platform_device &lt;--&gt; platform_driver.probe compatile = "samsung,i2c"; at24c02 &#123; // 交给 probe 处理转换为 I2C_client compatile = "at24c02"; &#125;; &#125;; spi &#123; compatile = "samsung,spi"; flash@0 &#123; // spi_device compatible = "winbond,w25q32dw"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; &#125;; &#125;; led &#123; compatile = "jz2550_led"; reg = &lt;5, 1&gt;; &#125;; mytest &#123; compatile = "mytest", "simple-bus"; // 如果有 "simple-bus" ，mytest 会转换为 platform_device mytest@0 &#123; compatile = "mytest_0"; &#125;; &#125;;&#125;; &emsp;&emsp;&emsp;&emsp;/mytest会被转换为platform_device,&emsp;&emsp;&emsp;&emsp;因为它兼容”simple-bus”, 它的子节点/mytest/mytest@0 也会被转换为platform_device &emsp;&emsp;&emsp;&emsp;/i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;&emsp;&emsp;&emsp;&emsp;/i2c/at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个i2c_client。 &emsp;&emsp;&emsp;&emsp;类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;&emsp;&emsp;&emsp;&emsp;/spi/flash@0节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。 123456789101112131415161718192021222324/ &#123; mytest &#123; compatile = "mytest", "simple-bus"; mytest@0 &#123; compatile = "mytest_0"; &#125;; &#125;; i2c &#123; compatile = "samsung,i2c"; at24c02 &#123; compatile = "at24c02"; &#125;; &#125;; spi &#123; compatile = "samsung,spi"; flash@0 &#123; compatible = "winbond,w25q32dw"; spi-max-frequency = &lt;25000000&gt;; reg = &lt;0&gt;; &#125;; &#125;; &#125;; 函数调用过程调用 of_platform_default_populate_init 函数&emsp;&emsp;of_platform_default_populate_init (drivers/of/platform.c) 被调用的过程: 1234567891011start_kernel // init/main.c rest_init(); pid = kernel_thread(kernel_init, NULL, CLONE_FS); kernel_init kernel_init_freeable(); do_basic_setup(); do_initcalls(); for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level); // 比如 do_initcall_level(3) for (fn = initcall_levels[3]; fn &lt; initcall_levels[3+1]; fn++) do_one_initcall(initcall_from_entry(fn)); // 就是调用"arch_initcall_sync(fn)"中定义的fn函数 调用 of_platform_default_populate_init 函数&emsp;&emsp;of_platform_default_populate_init (drivers/of/platform.c) 生成platform_device的过程: 1234567891011of_platform_default_populate_init of_platform_default_populate(NULL, NULL, NULL); of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL) for_each_child_of_node(root, child) &#123; rc = of_platform_bus_create(child, matches, lookup, parent, true); // 调用过程看下面 dev = of_device_alloc(np, bus_id, parent); // 根据device_node节点的属性设置platform_device的resource if (rc) &#123; of_node_put(child); break; &#125; &#125; 调用 of_platform_bus_create 函数&emsp;&emsp;of_platform_bus_create(bus, matches, …)的调用过程(处理bus节点生成platform_devie, 并决定是否处理它的子节点): 123456789101112dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent); // 生成bus节点的platform_device结构体if (!dev || !of_match_node(matches, bus)) // 如果bus节点的compatile属性不吻合matches成表, 就不处理它的子节点 return 0;for_each_child_of_node(bus, child) &#123; // 取出每一个子节点 pr_debug(" create child: %pOF\n", child); rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict); // 处理它的子节点, of_platform_bus_create是一个递归调用 if (rc) &#123; of_node_put(child); break; &#125;&#125; I2C 总线节点的处理过程&emsp;&emsp;/i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;&emsp;&emsp;platform_driver的probe函数中会调用i2c_add_numbered_adapter: 12345678i2c_add_numbered_adapter // drivers/i2c/i2c-core-base.c __i2c_add_numbered_adapter i2c_register_adapter of_i2c_register_devices(adap); // drivers/i2c/i2c-core-of.c for_each_available_child_of_node(bus, node) &#123; client = of_i2c_register_device(adap, node); client = i2c_new_device(adap, &amp;info); // 设备树中的i2c子节点被转换为i2c_client &#125; SPI 总线节点的处理过程&emsp;&emsp;/spi节点一般表示spi控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;&emsp;&emsp;platform_driver的probe函数中会调用spi_register_master, 即spi_register_controller: 1234567891011121314 spi_register_controller // drivers/spi/spi.c of_register_spi_devices // drivers/spi/spi.c for_each_available_child_of_node(ctlr-&gt;dev.of_node, nc) &#123; spi = of_register_spi_device(ctlr, nc); // 设备树中的spi子节点被转换为spi_device spi = spi_alloc_device(ctlr); rc = of_spi_parse_dt(ctlr, spi, nc); rc = spi_add_device(spi); &#125;``` # platform_device 与 platform_driver 的匹配&amp;emsp;&amp;emsp;参考内核代码： ```bash drivers/base/platform.c 注册 platform_driver 的过程:1234567891011121314151617platform_driver_register __platform_driver_register drv-&gt;driver.probe = platform_drv_probe; driver_register bus_add_driver klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers); // 把 platform_driver 放入 platform_bus_type 的driver链表中 driver_attach bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach); // 对于plarform_bus_type下的每一个设备, 调用__driver_attach __driver_attach ret = driver_match_device(drv, dev); // 判断dev和drv是否匹配成功 return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1; // 调用 platform_bus_type.match driver_probe_device(drv, dev); really_probe drv-&gt;probe // platform_drv_probe platform_drv_probe struct platform_driver *drv = to_platform_driver(_dev-&gt;driver); drv-&gt;probe 注册 platform_device 的过程:12345678910111213platform_device_register platform_device_add device_add bus_add_device klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices); // 把 platform_device 放入 platform_bus_type的device链表中 bus_probe_device(dev); device_initial_probe __device_attach ret = bus_for_each_drv(dev-&gt;bus, NULL, &amp;data, __device_attach_driver); // // 对于plarform_bus_type下的每一个driver, 调用 __device_attach_driver __device_attach_driver ret = driver_match_device(drv, dev); return drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : 1; // 调用platform_bus_type.match driver_probe_device 总结&emsp;&emsp;匹配函数是 platform_bus_type.match, 即 platform_match,&emsp;&emsp;匹配过程按优先顺序罗列如下:&emsp;&emsp;&emsp;&emsp;a. 比较 platform_dev.driver_override 和 platform_driver.drv-&gt;name&emsp;&emsp;&emsp;&emsp;b. 比较 platform_dev.dev.of_node的compatible属性 和 platform_driver.drv-&gt;of_match_table&emsp;&emsp;&emsp;&emsp;c. 比较 platform_dev.name 和 platform_driver.id_table&emsp;&emsp;&emsp;&emsp;d. 比较 platform_dev.name 和 platform_driver.drv-&gt;name&emsp;&emsp;有一个成功, 即匹配成功 内核中设备树的操作函数&emsp;&emsp;参考内核源代码 include/linux/ 目录下有很多 of 前缀开头的文件，这些就是内核中操作设备树的函数，下面对这些文件的作用作一个简单的说明。 123456789101112131415161718192021222324/* 处理DTB */#include &lt;of_fdt.h&gt; // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)/* 处理device_node */#include &lt;of.h&gt; // 提供设备树的一般处理函数, 比如 of_property_read_u32(读取某个属性的u32值), of_get_child_count(获取某个device_node的子节点数)#include &lt;of_address.h&gt; // 地址相关的函数, 比如 of_get_address(获得reg属性中的addr, size值)#include &lt;of_match_device(从matches数组中取出与当前设备最匹配的一项)#include &lt;of_dma.h&gt; // 设备树中DMA相关属性的函数#include &lt;of_gpio.h&gt; // GPIO相关的函数#include &lt;of_graph.h&gt; // GPU相关驱动中用到的函数, 从设备树中获得GPU信息#include &lt;of_iommu.h&gt; // 很少用到#include &lt;of_irq.h&gt; // 中断相关的函数#include &lt;of_mdio.h&gt; // MDIO (Ethernet PHY) API#include &lt;of_net.h&gt; // OF helpers for network devices. #include &lt;of_pci.h&gt; // PCI相关函数#include &lt;of_pdt.h&gt; // 很少用到#include &lt;of_reserved_mem.h&gt; // reserved_mem的相关函数/* 处理 platform_device */#include &lt;of_platform.h&gt; // 把device_node转换为platform_device时用到的函数, // 比如： of_device_alloc (根据 device_node 分配设置 platform_device), // of_find_device_by_node (根据 device_node 查找到 platform_device), // of_platform_bus_probe (处理 device_node 及它的子节点)#include &lt;of_device.h&gt; // 设备相关的函数, 比如 of_match_device 在根文件系统中查看设备树(有助于调试)原始 dtb 文件的存放位置1/sys/firmware/fdt 16 进制查看 dtb 文件1hexdump -C /sys/firmware/fdt 查看以目录结构存放的 dtb 文件&emsp;&emsp;以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件 1/sys/firmware/devicetree 查看系统中所有的 platform_device&emsp;&emsp;系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的&emsp;&emsp;对于来自设备树的platform_device,&emsp;&emsp;可以进入 /sys/devices/platform/&lt;设备名&gt;/of_node 查看它的设备树属性 1/sys/devices/platform /proc/device-tree 文件&emsp;&emsp;/proc/device-tree 是链接文件, 指向 /sys/firmware/devicetree/base]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Device tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备树之设备树的规范(2)]]></title>
    <url>%2F2020%2F01%2F05%2F0040-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E8%A7%84%E8%8C%83-2%2F</url>
    <content type="text"><![CDATA[DTS格式DTS的语法Devicetree node（节点）格式1234[label:] node-name[@unit-address] &#123; [properties definitions] [child nodes]&#125;; properties 的命名格式&emsp;&emsp;properties 有两种命名格式&emsp;&emsp;&emsp;&emsp;Property (属性名)格式1: 1[label:] property-name = value; &emsp;&emsp;&emsp;&emsp;Property(属性名)格式2(没有值): 1[label:] property-name; properties 的取值&emsp;&emsp;Property (属性名)取值只有 3 种:&emsp;&emsp;&emsp;&emsp;arrays of cells&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1 个或多个 32 位数据, 64 位数据使用 2 个 32 位数据表示),&emsp;&emsp;&emsp;&emsp;string&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;字符串: “str”,&emsp;&emsp;&emsp;&emsp;bytestring&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;16 进制表示的 1 个或多个字节，中括号: []。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;一个 byte 用 2 位 16 进制数表示，如： 00 必须写成 00，不可写成 0。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;byte之间的空格可省略： [001122] 或者 [00 11 22]&emsp;&emsp;&emsp;&emsp;这三种形式可组合使用。 properties 的取值示例:&emsp;&emsp;a. Arrays of cells : cell就是一个 32 位的数据 1interrupts = &lt;17 0xc&gt;; &emsp;&emsp;b. 64 bit 数据使用 2 个 cell 来表示: 1clock-frequency = &lt;0x00000001 0x00000000&gt;; &emsp;&emsp;c. A null-terminated string (有结束符的字符串): 1compatible = "simple-bus"; &emsp;&emsp;d. A bytestring(字节序列) : 12local-mac-address = [00 00 12 34 56 78]; // 每个byte使用 2 个 16 进制数来表示local-mac-address = [000012345678]; // 每个byte使用 2 个 16 进制数来表示 &emsp;&emsp;e. 可以是各种值的组合, 用逗号隔开: 12compatible = "ns16550", "ns8250";example = &lt;0xf00f0000 19&gt;, "a strange property format"; DTS 文件的基本布局(layout)&emsp;&emsp;一个最基本的 dts 文件示例： 12345678/dts-v1/; // 版本[memory reservations] // 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;; （给自己使用不希望内核使用的，保留的内存区域，如果希望内核使用全部的内存区域省略此项即可） // 留1MB的内存给自己使用，示例： /memreserve/ 0x33000000 0x10000;// 设备树的起点（根节点）/ &#123; [property definitions] // 属性-描述硬件的信息 [child nodes] // 子节点，子节点中可分出各种节点&#125;; 特殊的、默认的属性&emsp;&emsp;a. 根节点: 123456789#address-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)#size-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)compatible // 定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备 // 即这个板子兼容哪些平台 // uImage : smdk2410 smdk2440 mini2440 ==&gt; machine_desc // 有不同的初始化函数 model // 咱这个板子是什么 // 比如有2款板子配置基本一致, 它们的compatible是一样的 // 那么就通过model来分辨这2款板子 &emsp;&emsp;b. /memory 12device_type = "memory";reg // 用来指定内存的地址、大小 &emsp;&emsp;c. /chosen 1bootargs // 内核command line参数, 跟u-boot中设置的bootargs作用一样 &emsp;&emsp;d. /cpus&emsp;&emsp;/cpus 节点下有 1 个或多个 cpu 子节点, cpu 子节点中用 reg 属性用来标明自己是哪一个 cpu&emsp;&emsp;所以 /cpus 中有以下2个属性: 123#address-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)#size-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size) // 必须设置为0 &emsp;&emsp;e. /cpus/cpu* 12device_type = "cpu";reg // 表明自己是哪一个 cpu 如何引用其他节点&emsp;&emsp;a. phandle : // 节点中的 phandle 属性, 它的取值必须是唯一的(不要跟其他的 phandle 值一样) 12345678pic@10000000 &#123; phandle = &lt;1&gt;; interrupt-controller;&#125;;another-device-node &#123; interrupt-parent = &lt;1&gt;; // 使用phandle值为1来引用上述节点&#125;; &emsp;&emsp;b. label: 123456789PIC: pic@10000000 &#123; interrupt-controller;&#125;;another-device-node &#123; interrupt-parent = &lt;&amp;PIC&gt;; // 使用 label 来引用上述节点, // 使用 lable 时实际上也是使用phandle来引用, // 在编译 dts 文件为dtb文件时, 编译器 dtc 会在 dtb 中插入 phandle 属性&#125;; dts 文件可以包含 dtsi 文件&emsp;&emsp;比较公共的文件的命名为：“.dtsi”,“.dts”文件可以包含“.dtsi”文件；包含之后“.dts”文件中重新定义的内容会覆盖“*.dtsi”文件的内容。&emsp;&emsp;jz2440.dts 文件： 1234567891011121314// SPDX-License-Identifier: GPL-2.0/** SAMSUNG SMDK2440 board device tree source** Copyright (c) 2018 weidongshan@qq.com* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb*//dts-v1/;#include "jz2440.dtsi"&amp;LED &#123;pin = &lt;S3C2410_GPF(7)&gt;;&#125;; &emsp;&emsp;jz2440.dtsi 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// SPDX-License-Identifier: GPL-2.0/** SAMSUNG SMDK2440 board device tree source** Copyright (c) 2018 weidongshan@qq.com* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb*/#define S3C2410_GPA(_nr) ((0&lt;&lt;16) + (_nr))#define S3C2410_GPB(_nr) ((1&lt;&lt;16) + (_nr))#define S3C2410_GPC(_nr) ((2&lt;&lt;16) + (_nr))#define S3C2410_GPD(_nr) ((3&lt;&lt;16) + (_nr))#define S3C2410_GPE(_nr) ((4&lt;&lt;16) + (_nr))#define S3C2410_GPF(_nr) ((5&lt;&lt;16) + (_nr))#define S3C2410_GPG(_nr) ((6&lt;&lt;16) + (_nr))#define S3C2410_GPH(_nr) ((7&lt;&lt;16) + (_nr))#define S3C2410_GPJ(_nr) ((8&lt;&lt;16) + (_nr))#define S3C2410_GPK(_nr) ((9&lt;&lt;16) + (_nr))#define S3C2410_GPL(_nr) ((10&lt;&lt;16) + (_nr))#define S3C2410_GPM(_nr) ((11&lt;&lt;16) + (_nr))/dts-v1/;/ &#123; model = "SMDK24440"; compatible = "samsung,smdk2440"; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; memory &#123; /* /memory */ device_type = "memory"; reg = &lt;0x30000000 0x4000000 0 4096&gt;; &#125;; /* cpus &#123; cpu &#123; compatible = "arm,arm926ej-s"; &#125;; &#125;;*/ chosen &#123; bootargs = "noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200"; &#125;; LED: led &#123; compatible = "jz2440_led"; pin = &lt;S3C2410_GPF(5)&gt;; &#125;;&#125;; 编译得出 dtb 文件&emsp;&emsp;编译路径（Linux 4.19 内核路径）: /work/system/linux-4.19-rc3 12export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/arm/4.3.2/binmake dtbs # 得到dtb文件 将dtb文件反汇编为dts文件&emsp;&emsp;使用 ./scripts/dtc/dtc 可将dtb文件反汇编为dts文件 12./scripts/dtc/dtc -I dtb -0 dts -o tmp.dts arch/arm/boot/dts/jz2440.dtbvi tmp.dts 参考资料&emsp;&emsp;官方文档: https://www.devicetree.org/specifications/&emsp;&emsp;查看内核描述文件 Documentation/devicetree/booting-without-of.txt 对设备树的描述进行了总结： 1234linux uses DT data for three major purposes: 1) platform identification, // 平台信息，根节点中前面的信息： model compatible, address-cells, size-cells.... 2) runtime configuration, and // 运行时的配置信息，如：chosen, [memory reservations] 3) device population // 描述设备：如：各个node DTB格式&emsp;&emsp;DTB 中使用大端模式。（无论是大端还是小端，都只是对数值的储存的有影响，对字符串没有影响？） fdt_header结构体&emsp;&emsp;参考文档： devicetree-specification-v0.2.pdf p43 中的 fdt_header 结构体信息可对照 dtb 文件内容得出对应的值： 123456789101112struct fdt_header &#123; uint32_t magic; uint32_t totalsize; // 整个dtb文件的大小 uint32_t off_dt_struct; uint32_t off_dt_strings; uint32_t off_mem_rsvmap; // 保留的内存区域的偏移地址 uint32_t version; uint32_t last_comp_version; uint32_t boot_cpuid_phys; uint32_t size_dt_strings; uint32_t size_dt_struct;&#125;; &emsp;&emsp;fdt_header 中各个成员的说明： DTB文件布局12345678910111213141516171819202122 ------------------------------base -&gt; | struct boot_param_header | ------------------------------ | (alignment gap) (*) | ------------------------------ | memory reserve map | ------------------------------ | (alignment gap) | ------------------------------ | | | device-tree structure | | | ------------------------------ | (alignment gap) | ------------------------------ | | | device-tree strings | | |-----&gt; ------------------------------||--- (base + totalsize) 分析示例示例使用的 dts 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* jz2440.dts */// SPDX-License-Identifier: GPL-2.0/** SAMSUNG SMDK2440 board device tree source** Copyright (c) 2018 weidongshan@qq.com* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb*/#define S3C2410_GPA(_nr) ((0&lt;&lt;16) + (_nr))#define S3C2410_GPB(_nr) ((1&lt;&lt;16) + (_nr))#define S3C2410_GPC(_nr) ((2&lt;&lt;16) + (_nr))#define S3C2410_GPD(_nr) ((3&lt;&lt;16) + (_nr))#define S3C2410_GPE(_nr) ((4&lt;&lt;16) + (_nr))#define S3C2410_GPF(_nr) ((5&lt;&lt;16) + (_nr))#define S3C2410_GPG(_nr) ((6&lt;&lt;16) + (_nr))#define S3C2410_GPH(_nr) ((7&lt;&lt;16) + (_nr))#define S3C2410_GPJ(_nr) ((8&lt;&lt;16) + (_nr))#define S3C2410_GPK(_nr) ((9&lt;&lt;16) + (_nr))#define S3C2410_GPL(_nr) ((10&lt;&lt;16) + (_nr))#define S3C2410_GPM(_nr) ((11&lt;&lt;16) + (_nr))/dts-v1/;/memreserve/ 0x33f00000 0x100000;/ &#123; model = "SMDK24440"; compatible = "samsung,smdk2440"; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; memory &#123; /* /memory */ device_type = "memory"; reg = &lt;0x30000000 0x4000000 0 4096&gt;; &#125;; /* cpus &#123; cpu &#123; compatible = "arm,arm926ej-s"; &#125;; &#125;;*/ chosen &#123; bootargs = "noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200"; &#125;; led &#123; compatible = "jz2440_led"; pin = &lt;S3C2410_GPF(5)&gt;; &#125;;&#125;; dts 生成对应的 dtb 文件 分析过程 只分析其中的一个节点&emsp;&emsp;下面代码中注释部分为对应 dtb 文件中的内容。 123456789101112131415161718/* Devicetree node 格式： */[label:] node-name[@unit-address] &#123; [properties definitions] [child nodes]&#125;;/ &#123; /* ----&gt; 0x00000001 */ led &#123; /* ----&gt; 0x00000001 （表示 node 的开始） + 节点名字 */ compatible = "jz2440_led"; /* ----&gt; 0x00000003 （表示属性） + struct&#123; uint32_t len; // val 长度 uint32_t nameoff; // 名字在 strings block 中的 offset + val (len 个字节) &#125; */ pin = &lt;S3C2410_GPF(5)&gt;; /* ----&gt; 0x00000003 + struct + val */ &#125;; /* ----&gt; 0x00000002 (表示 node 结束) */&#125;; /* ----&gt; 0x00000002 */ /* ----&gt; 0x00000009 (表示整个 structure block 结束） */ 参考资料&emsp;&emsp;百问网：http://www.100ask.net&emsp;&emsp;官方文档： https://www.devicetree.org/specifications/&emsp;&emsp;内核文档: Documentation/devicetree/booting-without-of.txt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Device tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备树之为什么需要设备树(1)]]></title>
    <url>%2F2020%2F01%2F03%2F0039-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BE%E5%A4%87%E6%A0%91-1%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;设备树(Device Tree)是一种描述硬件的数据结构，由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。&emsp;&emsp;设备树的出现是为了解决内核中大量的板级文件代码，通过 DTS 可以像应用程序里的 XML 语言一样很方便的对硬件信息进行配置。 字符设备驱动程序的三种写法&emsp;&emsp;驱动程序编写有 3 种方法：传统方法、使用总线设备驱动模型、使用设备树&emsp;&emsp;这3种方法也核心都是一样的: 分配、设置、注册 file_operations 结构体&emsp;&emsp;&emsp;&emsp;这个 file_operations 结构体中有 .open, .read, .write, .ioctl 等成员&emsp;&emsp;&emsp;&emsp;驱动程序要实现这些成员，通过这些成员函数中操作硬件&emsp;&emsp;这 3 种方法的差别在于：如何指定硬件资源？（比如：如何指定 LED 引脚是哪个？）&emsp;&emsp;这 3 中方法的做法分别是： 传统方法&emsp;&emsp;在驱动程序代码中写死硬件资源, 代码简单/不易扩展：&emsp;&emsp;&emsp;&emsp;a. 分配file_operations结构体&emsp;&emsp;&emsp;&emsp;b. 设置file_operations结构体&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;该结构体中有.open,.read,.write等成员,&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在这些成员函数中去操作硬件&emsp;&emsp;&emsp;&emsp;c. 注册file_operations结构体:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;register_chrdev(major, name, &amp;fops)&emsp;&emsp;&emsp;&emsp;d. 入口函数: 调用register_chrdev&emsp;&emsp;&emsp;&emsp;e. 出口函数: 调用unregister_chrdev 总线设备驱动模型&emsp;&emsp;a. 把驱动程序分为两部分(platform_driver, platform_device)&emsp;&emsp;&emsp;&emsp;* 在 platform_device 中指定硬件资源,&emsp;&emsp;&emsp;&emsp;* 在 platform_driver 根据与之匹配的platform_device获得硬件资源，分配/设置/注册 file_operations结构体（从platform_device获得硬件资源信息）&emsp;&emsp;b. 如何确定platform_device和platform_driver是否匹配?&emsp;&emsp;&emsp;&emsp;b.1 platform_device含有name&emsp;&emsp;&emsp;&emsp;b.2 platform_driver.id_table”可能”指向一个数组, 每个数组项都有name, 表示该platform_driver所能支持的platform_device&emsp;&emsp;&emsp;&emsp;b.3 platform_driver.driver含有name, 表示该platform_driver所能支持的platform_device&emsp;&emsp;&emsp;&emsp;b.4 优先比较b.1, b.2两者的name, 若相同则表示互相匹配&emsp;&emsp;&emsp;&emsp;b.5 如果platform_driver.id_table为NULL, 则比较b.1, b.3两者的name, 若相同则表示互相匹配 &emsp;&emsp;特点：&emsp;&emsp;&emsp;&emsp;优点：易于扩展，但是有很多冗余代码(每种配置都对应一个platform_device结构体),&emsp;&emsp;&emsp;&emsp;缺点：硬件有变动时需要重新编译内核或驱动程序。 使用设备树指定硬件资源&emsp;&emsp;驱动程序也分为两部分(platform_driver, 设备树.dts)&emsp;&emsp;在设备树.dts中指定硬件资源, dts被编译为dtb文件, 在启动单板时会将dtb文件传给内核,&emsp;&emsp;内核根据dtb文件分配/设置/注册多个platform_device&emsp;&emsp;而platform_driver的编写方法跟”总线设备驱动模型”一样。 &emsp;&emsp;特点：&emsp;&emsp;&emsp;&emsp;易于扩展，没有冗余代码&emsp;&emsp;&emsp;&emsp;硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的dtb文件&emsp;&emsp;注: 123dts - device tree source // 设备树源文件dtb - device tree blob // 设备树二进制文件, 由dts编译得来blob - binary large object 使用设备树编写驱动的详细过程&emsp;&emsp;a. 使用”总线设备驱动模型”编写的驱动程序分为 platform_device 和 platform_driver 两部分&emsp;&emsp;&emsp;&emsp;* platform_device : 指定硬件资源, 来自 .c 文件&emsp;&emsp;&emsp;&emsp;* platform_driver : 根据与之匹配的 platform_device 获得硬件资源, 并分配-&gt;设置-&gt;注册 file_operations 结构体&emsp;&emsp;b. 实际上platform_device也可以来自设备树文件.dts&emsp;&emsp;&emsp;&emsp;* 1. dts 文件被编译为 dtb 文件,&emsp;&emsp;&emsp;&emsp;* 2. dtb 文件会传给内核,&emsp;&emsp;&emsp;&emsp;* 3. 内核会解析 dtb 文件, 构造出一系列的 device_node 结构体,&emsp;&emsp;&emsp;&emsp;* 4. device_node 结构体会转换为 platform_device 结构体 1dts -&gt; dtv -&gt; 内核解析dtb -&gt; device_node -&gt; platform_device &emsp;&emsp;&emsp;&emsp;所以: 我们在 dts 文件中指定资源即可； 不再需要在 .c 文件中设置 platform_device 结构体。&emsp;&emsp;c. “来自 dts 的 platform_device 结构体” 与 “我们写的 platform_driver “ 的匹配过程:&emsp;&emsp;&emsp;&emsp;”来自 dts 的 platform_device 结构体”里面有成员”.dev.of_node”, 它里面含有各种属性, 比如 compatible, reg, pin&emsp;&emsp;&emsp;&emsp;”我们写的 platform_driver “ 里面有成员 “.driver.of_match_table”, 它表示能支持哪些来自于 dts 的 platform_device &emsp;&emsp;&emsp;&emsp;如果 “of_node 中的 compatible” 跟 “of_match_table 中的 compatible” 一致, 就表示匹配成功, 则调用 platform_driver 中的 probe 函数;&emsp;&emsp;&emsp;&emsp;在 probe 函数中, 可以继续从 of_node 中获得各种属性来确定硬件资源 参考资料&emsp;&emsp;百问网：http://www.100ask.net]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Device tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android-Recovery-UI的实现过程]]></title>
    <url>%2F2019%2F10%2F11%2F0038-%E5%88%86%E6%9E%90Android-Recovery-UI%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;recovery作为一个简单的rootfs, 只提供了非常有限的几个功能，在源码中其利用boottable/recovery下的minui库作为基础，采用直接刷framebuffer的形式绘制显示UI。&emsp;&emsp;在recovery的源码中，跟ui显示相关的代码主要有： 定义并实现几个类，如ScreenRecoveryUI，ScreenRecoveryUI、RecoveryUI，这几个类由抽象到具体一层层继承下来，在recovery.cpp的main中实例化并被使用 将minui库里resources.cpp，graphics.cpp提供的基本api封装到几个方法中，这几个方法在类中基本被按功能划分，单独负责一个ui单元的显示，如draw_background_locked、draw_battery_locked、draw_logo_locked、update_progress_locked、draw_progressbar_locked、draw_state_locked等,之后再将这些方法进一步按照设计需求组合，实现了一些完成更多功能的方法，如SetBackground，ShowProgress boottable/recovery/minui下的resources.cpp，graphics.cpp其中resources.cpp提供的api主要用于图片资源的读取和加载，graphics.cpp负责具体完成各类ui的绘制 recovery下面根据分辨率不同保存的图片资源，如boottable/recovery/res-xxhdpi等。 &emsp;&emsp;以Android P原生代码作为分析材料，对Recovery模式下各类UI资源被加载并显示的过程来做具体分析：&emsp;&emsp;recovery的UI实现的大部分实现细节放在了screen_ui.cpp等文件中，在recovery的main中，主要是要完成ui的显示。 recovery.cpp main function1234567891011121314151617181920212223242526/* recovery.cpp */main(int argc, char **argv) &#123; /* ...... */ Device* device = make_device(); //Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : Device::REBOOT; // 1. If the recovery menu is visible, prompt and wait for commands. // 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into // recovery to sideload a package.) // 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device // without waiting. // 4. In all other cases, reboot the device. Therefore, normal users will observe the device // reboot after it shows the "error" screen for 5s. if (just_exit) &#123; after = Device::REBOOT; &#125; else if (((status == INSTALL_NONE) &amp;&amp; !sideload_auto_reboot) || ui-&gt;IsTextVisible()) &#123; Device::BuiltinAction temp = prompt_and_wait(device, status); if (temp != Device::NO_ACTION) &#123; after = temp; &#125; &#125; /* ...... */ return EXIT_SUCCESS;&#125; &emsp;&emsp;Reocvery的main函数代码中UI相关的语句中的工作很简单：首先新建了一个Device类的对象， Device类封装了一些操作，包括UI的操作。 device.h class Device123456789101112131415161718/* device.h */class Device &#123; public: explicit Device(RecoveryUI* ui) : ui_(ui) &#123;&#125; virtual ~Device() &#123;&#125; // Called to obtain the UI object that should be used to display the recovery user interface for // this device. You should not have called Init() on the UI object already, the caller will do // that after this method returns. virtual RecoveryUI* GetUI() &#123; return ui_; &#125; /* ..... */ // The device-specific library must define this function (or the default one will be used, if there // is no device-specific library). It returns the Device object that recovery should use. Device* make_device();&#125; &emsp;&emsp;make_device()函数的说明在device.h中有提及。 三个类的继承关系1234567/* ./ui.h(RecoveryUI)-&gt;./screen_ui.h(ScreenRecoveryUI)-&gt;./device.h(DefaultUI) */./ui.h RecoveryUI ./screen_ui.h ScreenRecoveryUI ./device.h DefaultUI &emsp;&emsp;调用Device类的GetUI()返回一个DefaultUI对象，recovery中涉及到三个UI类，三个类之间为继承关系，分别为DefaultUI、ScreenRecoveryUI、RecoveryUI screen_ui.cpp Init function123456789101112131415161718192021222324252627282930313233343536373839404142434445/* ./screen_ui.cpp *//* ..... */bool ScreenRecoveryUI::Init(const std::string&amp; locale) &#123; RecoveryUI::Init(locale); if (!InitTextParams()) &#123; return false; &#125; // Are we portrait or landscape? layout_ = (gr_fb_width() &gt; gr_fb_height()) ? LANDSCAPE : PORTRAIT; // Are we the large variant of our base layout? if (gr_fb_height() &gt; PixelsFromDp(800)) ++layout_; text_ = Alloc2d(text_rows_, text_cols_ + 1); file_viewer_text_ = Alloc2d(text_rows_, text_cols_ + 1); text_col_ = text_row_ = 0; // Set up the locale info. SetLocale(locale); LoadBitmap("icon_error", &amp;error_icon); LoadBitmap("progress_empty", &amp;progressBarEmpty); LoadBitmap("progress_fill", &amp;progressBarFill); LoadBitmap("stage_empty", &amp;stageMarkerEmpty); LoadBitmap("stage_fill", &amp;stageMarkerFill); // Background text for "installing_update" could be "installing update" // or "installing security update". It will be set after UI init according // to commands in BCB. installing_text = nullptr; LoadLocalizedBitmap("erasing_text", &amp;erasing_text); LoadLocalizedBitmap("no_command_text", &amp;no_command_text); LoadLocalizedBitmap("error_text", &amp;error_text); LoadAnimation(); pthread_create(&amp;progress_thread_, nullptr, ProgressThreadStartRoutine, this); return true;&#125;/* ..... */ 调用RecoveryUI的Init()，初始化输入事件处理。 InitTextParams()用于初始化图形设备和字体显示的环境。 调用DefaultUI类的Init()，由于DefaultUI类没有Init()方法，因此将调用它的父类ScreenRecoveryUI的Init()： 同理可得，调用ScreenRecoveryUI类的SetLocale()来标识几个比较特别的区域 同理可得，调用ScreenRecoveryUI类的SetBackground()设置初始状态的背景图 最后显示recovery的主界面，即平时所见的刷机界面。 LoadBitmap() 将png生成surface, 每个png图片对应一个surface, 所有surface存放在一个数组中 LoadLocalizedBitmap() 将区域文字所在的图片中的text信息根据当前的locale提取出来，生成对应的surface, 所以surface也存放在一个数组中 pthread_create(&amp;progress_t, NULL, progress_thread, NULL) 创建一个线程，该线程的任务是一个死循环，在该循环中不停地检测currentIcon以及progressBarType来决定是不是要更新进度条。 screen_ui.cpp InitTextParams function12345678910111213/* ./screen_ui.cpp *//* ..... */bool ScreenRecoveryUI::InitTextParams() &#123; if (gr_init() &lt; 0) &#123; return false; &#125; gr_font_size(gr_sys_font(), &amp;char_width_, &amp;char_height_); text_rows_ = (ScreenHeight() - kMarginHeight * 2) / char_height_; text_cols_ = (ScreenWidth() - kMarginWidth * 2) / char_width_; return true;&#125;/* ..... */ &emsp;gr_init() 初始化图形设备，分配Pixelflinger库渲染的内存&emsp;gr_font_size() 将字体对应的surface长宽赋值给char_width和char_height screen_ui.cpp SetLocale function1234567891011121314151617181920/* ./screen_ui.cpp */void ScreenRecoveryUI::SetLocale(const std::string&amp; new_locale) &#123; locale_ = new_locale; rtl_locale_ = false; if (!new_locale.empty()) &#123; size_t underscore = new_locale.find('_'); // lang has the language prefix prior to '_', or full string if '_' doesn't exist. std::string lang = new_locale.substr(0, underscore); // A bit cheesy: keep an explicit list of supported RTL languages. if (lang == "ar" || // Arabic lang == "fa" || // Persian (Farsi) lang == "he" || // Hebrew (new language code) lang == "iw" || // Hebrew (old language code) lang == "ur") &#123; // Urdu rtl_locale_ = true; &#125; &#125;&#125; &emsp;ScreenRecoveryUI类的SetLocale， 该函数根据locale判断所用的字体是否属于阿拉伯语系，阿拉伯语的书写习惯是从右到左，如果是阿拉伯语系的话，就设置一个标志，后面根据这个标志决定从右到左显示文字或进度条。&emsp;SetLocale的参数locale赋值逻辑是这样的，先从command文件中读取, command文件中设置locale的命令如”–locale=zh_CN“，如果没有传入locale,初始化过程中会尝试从/cache/recovery/last_locale中读取locale, 如果该文件也没有，则locale不会被赋值，就默认用English。 screen_ui.cpp SetBackground function123456789/* ./screen_ui.cpp */void ScreenRecoveryUI::SetBackground(Icon icon) &#123; pthread_mutex_lock(&amp;updateMutex); currentIcon = icon; update_screen_locked(); pthread_mutex_unlock(&amp;updateMutex);&#125; update_screen_locked包含两个操作，一是更新screen, 二是切换前后buffer。 12345/* ./screen_ui.cpp */void ScreenRecoveryUI::update_screen_locked() &#123; draw_screen_locked(); gr_flip();&#125; &emsp;SetBackground函数比较简洁，关键部分在update_screen_locked，下面重点分析一下:&emsp;update_screen_locked和update_progress_locked是recovery的UI部分的关键函数，update_screen_locked用来更新背景, update_progress_locked用来更新进度条，因为显示的画面会一直在更新，所以这两个函数会在不同的地方被反复调用。 screen_ui.cpp draw_background_locked function12345678910111213141516171819202122232425/* ./screen_ui.cpp */void ScreenRecoveryUI::draw_background_locked() &#123; pagesIdentical = false; gr_color(0, 0, 0, 255); gr_clear(); if (currentIcon != NONE) &#123; if (max_stage != -1) &#123; int stage_height = gr_get_height(stageMarkerEmpty); int stage_width = gr_get_width(stageMarkerEmpty); int x = (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / 2; int y = ScreenHeight() - stage_height - kMarginHeight; for (int i = 0; i &lt; max_stage; ++i) &#123; GRSurface* stage_surface = (i &lt; stage) ? stageMarkerFill : stageMarkerEmpty; DrawSurface(stage_surface, 0, 0, stage_width, stage_height, x, y); x += stage_width; &#125; &#125; GRSurface* text_surface = GetCurrentText(); int text_x = (ScreenWidth() - gr_get_width(text_surface)) / 2; int text_y = GetTextBaseline(); gr_color(255, 255, 255, 255); DrawTextIcon(text_x, text_y, text_surface); &#125;&#125; &emsp;&emsp;draw_background_locked函数的实现代码中又出现了几个以gr_开头的函数，以gr_开头的函数来自minui库，minui库的代码在recovery源码下的minui目录下，minui提供的接口实现了图形的描绘以及固定大小的文字显示。 gr_color(unsigned char r, unsigned char g, unsigned char b, unsigned char a); /* 设置字体颜色 */ gr_fill(int x, int y, int w, int h); /* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */ gr_blit(gr_surface source, int sx, int sy, int w, int h, int dx, int dy); /* 填充由source指定的图片 */ &emsp;&emsp;draw_background_locked函数先将整个渲染buffer填充为黑色，然后计算背景surface的长宽，文字surface的长宽，再结合fb的长宽计算出背景surface以及文字surface显示的坐标，有长宽和坐标就可以调用Pixelflinger的接口在渲染buffer上进行渲染。 screen_ui.cpp update_progress_locked function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* ./screen_ui.cpp */void ScreenRecoveryUI::update_progress_locked() &#123; if (show_text || !pagesIdentical) &#123; draw_screen_locked(); // Must redraw the whole screen pagesIdentical = true; &#125; else &#123; draw_foreground_locked(); // Draw only the progress bar and overlays &#125; gr_flip();&#125;/* ...... */void ScreenRecoveryUI::draw_foreground_locked() &#123; if (currentIcon != NONE) &#123; GRSurface* frame = GetCurrentFrame(); int frame_width = gr_get_width(frame); int frame_height = gr_get_height(frame); int frame_x = (ScreenWidth() - frame_width) / 2; int frame_y = GetAnimationBaseline(); DrawSurface(frame, 0, 0, frame_width, frame_height, frame_x, frame_y); &#125; if (progressBarType != EMPTY) &#123; int width = gr_get_width(progressBarEmpty); int height = gr_get_height(progressBarEmpty); int progress_x = (ScreenWidth() - width) / 2; int progress_y = GetProgressBaseline(); // Erase behind the progress bar (in case this was a progress-only update) gr_color(0, 0, 0, 255); DrawFill(progress_x, progress_y, width, height); if (progressBarType == DETERMINATE) &#123; float p = progressScopeStart + progress * progressScopeSize; int pos = static_cast&lt;int&gt;(p * width); if (rtl_locale_) &#123; // Fill the progress bar from right to left. if (pos &gt; 0) &#123; DrawSurface(progressBarFill, width - pos, 0, pos, height, progress_x + width - pos, progress_y); &#125; if (pos &lt; width - 1) &#123; DrawSurface(progressBarEmpty, 0, 0, width - pos, height, progress_x, progress_y); &#125; &#125; else &#123; // Fill the progress bar from left to right. if (pos &gt; 0) &#123; DrawSurface(progressBarFill, 0, 0, pos, height, progress_x, progress_y); &#125; if (pos &lt; width - 1) &#123; DrawSurface(progressBarEmpty, pos, 0, width - pos, height, progress_x + pos, progress_y); &#125; &#125; &#125; &#125;&#125; &emsp;update_progress_locked函数的原理与 update_screen_locked函数类似， 最终是将进度条的surface输出到渲染buffer,&emsp;recovery中各个场景的画面，就是由背景、文字、进度条的重叠，不同的是所用的surface 以及surface的坐标。 &emsp;recovery main函数中的UI代码基本上已经分析过了，最后一点主菜单的显示，就是通过上面介绍的这些接口将文字图片显示出来，因此就不再多讲。总的来说，recovery的UI显示部分难度不大，应用层调用minui库实现了图形的描绘以及固定大小的文字显示，minui库调用了Pixelflinger库来进行渲染。 minui部分接口说明&emsp;&emsp;仅供参考 1234567891011121314151617181920int gr_init(void); /* 初始化图形显示,主要是打开设备、分配内存、初始化一些参数 */ void gr_exit(void); /* 注销图形显示,关闭设备并释放内存 */ int gr_fb_width(void); /* 获取屏幕的宽度 */ int gr_fb_height(void); /* 获取屏幕的高度 */ gr_pixel *gr_fb_data(void); /* 获取显示数据缓存的地址 */ void gr_flip(void); /* 刷新显示内容 */ void gr_fb_blank(bool blank); /* 清屏 */ void gr_color(unsigned char r, unsigned char g, unsigned char b, unsigned char a); /* 设置字体颜色 */ void gr_fill(int x, int y, int w, int h); /* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */ int gr_text(int x, int y, const char *s); /* 显示字符串 */ int gr_measure(const char *s); /* 获取字符串在默认字库中占用的像素长度 */ void gr_font_size(int *x, int *y); /* 获取当前字库一个字符所占的长宽 */ void gr_blit(gr_surface source, int sx, int sy, int w, int h, int dx, int dy); /* 填充由source指定的图片 */ unsigned int gr_get_width(gr_surface surface); /* 获取图片宽度 */ unsigned int gr_get_height(gr_surface surface); /* 获取图片高度 */ int res_create_surface(const char* name, gr_surface* pSurface); /* 根据图片创建显示资源数据,name为图片在mk文件指定的相对路径 */ void res_free_surface(gr_surface surface); /* 释放资源数据 */]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的升级流程]]></title>
    <url>%2F2019%2F10%2F09%2F0037-Android%E7%9A%84%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;以Android P原生代码作为分析材料。 从Android的启动模式说起&emsp;&emsp;Android系统一般有三种启动模式：Fastboot、Recovery system、Main system。这三种启动模式对应不同的启动场景需求： Fastboot：在这种模式下，可以修改手机的硬件，并且允许我们发送一些命令给Bootloader。如使用电脑刷机，则需要进入fastboot模式，通过电脑执行命令将系统镜像刷到通过USB刷到Android设备中中。 Recovery：Recovery是一个小型的操作系统，并且会加载部分文件系统，这样才能从sdcard中读取升级包。 Main System: 即我们平时正常开机后所使用的手机操作系统模式。 &emsp;&emsp;但是我们一般经常用到的是recovery system和main system这两种启动模式。下面主要区分下recovery system和main system： &emsp;&emsp;启动经过bootloader之后，系统的启动方式有两种选择，这个选择有两个方式可以决定：一个是操作bootloader，一个是根据recovery的command文件。&emsp;&emsp;上半部分是mian system（正常启动模式），下半部分为Recovery模式。正常的启动模式是从boot.img启动系统（Main System），而recovery模式则是从reovery.img启动系统；（reovery.img只包含内核、简单的文件管理系统和图形系统） 升级流程之升级方式应用层ota升级流程：&emsp;&emsp;应用层层面的 ota升级包的下载、校验以及最后的发起安装过程： Recovery模式下的OTA升级流程&emsp;&emsp;进入Recovery模式之后，根据相应的指令指示开始对下载的升级包进行升级，整体的流程图如下所示： 升级流程之升级包升级包的制作&emsp;&emsp;升级包是通过脚本ota_from_target_files进行制作的。（在Android SDK源码中的位置：build/make/tools/releasetools/ota_from_target_files） WriteFullOTAPackage 执行目的 使用 edify_generator 生成升级脚本 updater-script 使用 **target-xxx.zip 中的内容生成最终的升级包 整体通过ota_from_target_files脚本，进行了升级包的制作，Android是使用 make otapackage 命令进行制作，制作出升级脚本后，会连带着系统相关信息进行打包。 升级包的架构&emsp;&emsp;下面是升级包的基本的架构，是以hisi 3798mv300举例不同平台升级包略有不同，单架构没什么差异裸分区镜像就使用boot.img loader.bin这种方式。&emsp;&emsp;META 目录下是system的权限信息和misc标记信息。&emsp;&emsp;META-INF中的metadata是系统信息，我们的apk会先去校验这个文件与我们的系统是否一致，信息举例如下： 123post-build=xxxxxxxx/xxxxxxxx/xxxxxxxx:4.4.2/xxxxxxxx/817109000126:eng/test-keyspost-timestamp=1553223178pre-device=xxxxxxxx &emsp;&emsp;updater-script是升级脚本，update-binary是升级脚本执行的执行程序，Recovery下面是升级recovery用的。update-script升级脚本： 12345678910111213141516171819202122232425262728(!less_than_int(1569489228, getprop("ro.build.date.utc"))) || abort("E3003: Can't install this package (2019年 00月 00日 星期x xx:xx:xx CST) over newer build (" + getprop("ro.build.date") + ").");getprop("ro.product.device") == "franklin" || abort("E3004: This package is for \"franklin\" devices; this is a \"" + getprop("ro.product.device") + "\".");if ota_zip_check() == "1" thenset_bootloader_env("upgrade_step", "3");backup_update_package("/dev/block/mmcblk0", "1894");set_bootloader_env("upgrade_step", "2");set_bootloader_env("upgrade_step", "3");reboot_recovery();elseui_print("Target: Android/xxxxx/xxxxxx:9.0.0/xxxxx/0000.00000.001:eng/test-keys");set_bootloader_env("upgrade_step", "3");show_progress(0.750000, 0);ui_print("Patching system image unconditionally...");block_image_update("/dev/block/system", package_extract_file("system.transfer.list"), "system.new.dat.br", "system.patch.dat") || abort("E1001: Failed to update system image.");show_progress(0.050000, 5);package_extract_file("boot.img", "/dev/block/boot");show_progress(0.200000, 10);if get_update_stage() == "2" thenformat("ext4", "EMMC", "/dev/block/metadata", "0", "/metadata");format("ext4", "EMMC", "/dev/block/tee", "0", "/tee");wipe_cache();set_update_stage("0");endif;set_bootloader_env("upgrade_step", "1");set_bootloader_env("force_auto_update", "false");endif;set_progress(1.000000); 升级流程之升级脚本&emsp;&emsp;升级脚本在recovery中执行，执行的每一步骤，是使用update-binary这个二进制文件里面的程序执行，代码见： bootable/recovery/updater/install.cpp 这里面编译会生成updater文件，这个文件就是制作update-binary的。&emsp;&emsp;其中的脚本，通过文件中void RegisterInstallFunctions() 函数中的RegisterFunction(“mount”, MountFn);函数执行，前面是脚本，后面是脚本的函数。执行完所有的脚本过程后，就完成了本次的升级 注：整个升级过程是没有升级recovery自己的分区的 升级流程之启动升级&emsp;&emsp;在recovery中，是怎样进行升级的呢？&emsp;&emsp;Recovery的启动也是通过init执行recovery服务进行启动，执行recovery.cpp中的main函数： 12345678/* recovery.cpp *//* ....... */if (update_package != nullptr) &#123; /* ....... */ status = install_package(update_package, &amp;should_wipe_cache, TEMPORARY_INSTALL_FILE, true, retry_count); /* ....... */&#125; mian函数的入口参数是通过cache/recovery/command中得来。 &emsp;&emsp;升级函数install_package（bootable/recovery/install.cpp）会调用 really_install_package，其中进行校验，之后开始执行升级update-binary调用updater-script开始根据进行升级，最终的升级过程在try_update_binary()函数中进行，其创建了两个管道并fork一个子进程，子进程管道的数据即升级指令，父进程读取其执行相应到处理（升级）工作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/* install.cpp */int install_package(const std::string&amp; path, bool* wipe_cache, const std::string&amp; install_file, bool needs_mount, int retry_count) &#123; /* ....... */ int result; std::vector&lt;std::string&gt; log_buffer; if (setup_install_mounts() != 0) &#123; LOG(ERROR) &lt;&lt; "failed to set up expected mounts for install; aborting"; result = INSTALL_ERROR; &#125; else &#123; result = really_install_package(path, wipe_cache, needs_mount, &amp;log_buffer, retry_count, &amp;max_temperature); &#125; /* ....... */&#125;static int really_install_package(const std::string&amp; path, bool* wipe_cache, bool needs_mount, std::vector&lt;std::string&gt;* log_buffer, int retry_count, int* max_temperature) &#123; /* ....... */ // Verify package. if (!verify_package(map.addr, map.length)) &#123; log_buffer-&gt;push_back(android::base::StringPrintf("error: %d", kZipVerificationFailure)); return INSTALL_CORRUPT; &#125; /* ....... */ // Verify and install the contents of the package. ui-&gt;Print("Installing update...\n"); if (retry_count &gt; 0) &#123; ui-&gt;Print("Retry attempt: %d\n", retry_count); &#125; ui-&gt;SetEnableReboot(false); int result = 0; if (update_flag == 1) &#123; result = try_update_binary(new_path, zip, wipe_cache, log_buffer, retry_count, max_temperature); &#125; else &#123; result = try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature); &#125; /* ....... */// If the package contains an update binary, extract it and run it.static int try_update_binary(const std::string&amp; package, ZipArchiveHandle zip, bool* wipe_cache, std::vector&lt;std::string&gt;* log_buffer, int retry_count, int* max_temperature) &#123; read_source_target_build(zip, log_buffer); int pipefd[2]; pipe(pipefd); std::vector&lt;std::string&gt; args; #ifdef AB_OTA_UPDATER int ret = update_binary_command(package, zip, "/sbin/update_engine_sideload", retry_count, pipefd[1], &amp;args); #else int ret = update_binary_command(package, zip, "/tmp/update-binary", retry_count, pipefd[1], &amp;args); #endif if (ret) &#123; close(pipefd[0]); close(pipefd[1]); log_buffer-&gt;push_back(android::base::StringPrintf("error: %d", kUpdateBinaryCommandFailure)); return ret; &#125; /* ....... */ // When executing the update binary contained in the package, the // arguments passed are: // // - the version number for this interface // // - an FD to which the program can write in order to update the // progress bar. The program can write single-line commands: // // progress &lt;frac&gt; &lt;secs&gt; // fill up the next &lt;frac&gt; part of of the progress bar // over &lt;secs&gt; seconds. If &lt;secs&gt; is zero, use // set_progress commands to manually control the // progress of this segment of the bar. // // set_progress &lt;frac&gt; // &lt;frac&gt; should be between 0.0 and 1.0; sets the // progress bar within the segment defined by the most // recent progress command. // // ui_print &lt;string&gt; // display &lt;string&gt; on the screen. // // wipe_cache // a wipe of cache will be performed following a successful // installation. // // clear_display // turn off the text display. // // enable_reboot // packages can explicitly request that they want the user // to be able to reboot during installation (useful for // debugging packages that don't exit). // // retry_update // updater encounters some issue during the update. It requests // a reboot to retry the same package automatically. // // log &lt;string&gt; // updater requests logging the string (e.g. cause of the // failure). // // - the name of the package zip file. // // - an optional argument "retry" if this update is a retry of a failed // update attempt. // // Convert the vector to a NULL-terminated char* array suitable for execv. const char* chr_args[args.size() + 1]; chr_args[args.size()] = nullptr; for (size_t i = 0; i &lt; args.size(); i++) &#123; chr_args[i] = args[i].c_str(); &#125; pid_t pid = fork(); if (pid == -1) &#123; close(pipefd[0]); close(pipefd[1]); PLOG(ERROR) &lt;&lt; "Failed to fork update binary"; log_buffer-&gt;push_back(android::base::StringPrintf("error: %d", kForkUpdateBinaryFailure)); return INSTALL_ERROR; &#125; if (pid == 0) &#123; umask(022); close(pipefd[0]); execv(chr_args[0], const_cast&lt;char**&gt;(chr_args)); // Bug: 34769056 // We shouldn't use LOG/PLOG in the forked process, since they may cause // the child process to hang. This deadlock results from an improperly // copied mutex in the ui functions. fprintf(stdout, "E:Can't run %s (%s)\n", chr_args[0], strerror(errno)); _exit(EXIT_FAILURE); &#125; close(pipefd[1]); std::atomic&lt;bool&gt; logger_finished(false); std::thread temperature_logger(log_max_temperature, max_temperature, std::ref(logger_finished)); *wipe_cache = false; bool retry_update = false; char buffer[1024]; FILE* from_child = fdopen(pipefd[0], "r"); while (fgets(buffer, sizeof(buffer), from_child) != nullptr) &#123; std::string line(buffer); size_t space = line.find_first_of(" \n"); std::string command(line.substr(0, space)); if (command.empty()) continue; // Get rid of the leading and trailing space and/or newline. std::string args = space == std::string::npos ? "" : android::base::Trim(line.substr(space)); /* 下面代码的主要逻辑是，对接收到的命令执行相应的处理操作 */ &#125; /* ....... */&#125;&#125; &emsp;&emsp;try_update_binary 将升级包中的 META-INF/com/google/android/update-binary 拷贝到设备的/tmp 目录并 fork 出一个进程，执行 update-binary 脚本update-binary 脚本用于读取 META-INF/com/google/android/update-binary/updater-script解析执行升级脚本中的命令。父进程通过管道接收 update-binary 传来的命令，并执行相应的操作。&emsp;&emsp;Recovery 在读取并解析升级脚本的过程中，会把升级包中 recovery 目录下的 etc/install-recovery.sh 和recovery.img 释放到设备的 system 目录下。当升级成功，在重启进入 Android 的过程中，系统会运行一个名为 flash_recovery 的 service ,该 service 会运行 install-recovery.sh 脚本，在脚本中会把 recovery.img 直接 dd到 recovery 分区。烧完后，删除 recovery.img 。 【拓展】Bootloader、BCB、Recovery与Main System之间的交互&emsp;&emsp;Recovery System与Main System的交互，主要是通过/cache分区下的文件进行信息交互的。具体如下： /cache文件 方向 功能说明 /cache/recovery/command INPUT Main System传递给Recovery的命令行，比如update_package的存放路径等 /cache/recovery/last_flag OUTPUT 似乎Rockchip平台独有，用于记录自动升级结果 /cache/recovery/intent OUTPUT Recovery给Main Syatem传递的信息 /cache/recovery/last_install OUTPUT Recovery升级结果文件，主系统可以读取这个文件以便知道系统升级的结果，然后可以给用户相应的提示 /cache/recovery/last_locale OUTPUT 关系到Recovery模式下，UI文字的语言呈现形式，比如以英文显示，以中文显示等，如果进入recovery时获取不到&lt;-locale&gt;启动参数，则会尝试读取/cache下的 /cache/recovery/log OUTPUT Recovery模式下的整个过程的日志，在系统进入Main Systen后，文件名不是以“last_”为前缀的文件会被删除 /cache/recovery/last_log OUTPUT Recovery模式下的日志，取自上面所说的log（但可能完整性不及log），一般来说，分析Recovery问题的时候，经常会分析这份log command的值一般有以下一个或多个。 &emsp;&emsp;Bootloader与Recovery和Main System之间也是存在交互的： Bootloader会通过解析BCB模块，决定启动系统到Recovery或Main System。而Recovery或Main System也能够操作BCB，进而影响到Bootloader的行为。 table th:nth-of-type(1){ width: 30%; } table th:nth-of-type(2){ width: 15%; } table th:nth-of-type(3){ width: 55%; }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的系统架构、核心组件及源码结构]]></title>
    <url>%2F2019%2F09%2F19%2F0036-Android%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言基于Android 9.0 Android系统架构介绍&emsp;&emsp;Android系统架构分为五层，从下到上依次是Linux内核层、硬件抽象层、系统运行库层、应用框架层和应用层。 Linux内核层&emsp;&emsp;Android站在巨人的肩膀之上，其基于Linux对Linux的依赖主要包括核心和驱动程序两部分。 硬件抽象层&emsp;&emsp;Android的硬件抽象层，简单来说，就是对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。也就是将Linux内核对硬件的支持分成了两层，一层放在用户空间（User Space），一层放在内核空间（Kernel Space），其中，硬件抽象层运行在用户空间，对应具体的驱动实现细节，而Linux内核驱动程序运行在内核空间，只提供简单的数据访问逻辑。 Android系统为什么要把对硬件的支持划分为两层来实现呢？&emsp;&emsp;Linux内核代码遵循GPL1协议，如果在Android系统所使用的Linux内核中添加或者修改了代码，那么就必须将它们公开。因此，如果Android系统像其他的Linux系统一样，把对硬件的支持完全实现在硬件驱动模块中，那么就必须将这些硬件驱动模块源代码公开，这样就可能会损害移动设备厂商的利益，因为这相当于暴露了硬件的实现细节和参数。 为什么将其抽象到硬件抽象层就可以规避这个问题呢？&emsp;&emsp;Android 系统代码是遵循Apache License2协议的，它允许移动设备厂商添加或者修改Android系统源代码，而又不必公开这些代码。因此，如果把对硬件的支持完全实现在Android系统的用户空间中，那么就可以隐藏硬件的实现细节和参数。然而，这是无法做到的，因为只有内核空间才有特权操作硬件设备。一个折中的解决方案便是将对硬件的支持分别实现在内核空间和用户空间中，其中，内核空间仍然是以硬件驱动模块的形式来支持，不过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现细节和参数。这样就可以保护移动设备厂商的利益了。 系统运行层（库Libraries和运行环境Runtime）&emsp;&emsp;本层次对应一般的嵌入式系统，相当于中间件层次。Android的本层次分成两个部分，一个是各种库，另一个是Android运行环境。本层的内容大多是使用C语言实现。&emsp;&emsp;在一般情况下，Android的各种库是以系统中间件的形式提供的，它们的显著特点是与移动设备平台的应用密切相关。另外，Android的运行环境主要是基于Dalvik（虚拟机）技术的。而Dalvik与一般的Java虚拟机（Java Virtual Machine，JVM）有如下区别： Java虚拟机：执行的是Java标准的字节码（Bytecode）。 Dalvik：执行的是Dalyik可执行格式（.dex）的文件。在执行的过程中，每一个应用程序即一个进程（Linux的一个Process）。 &emsp;&emsp;二者最大的区别在于，JVM是基于栈的虚拟机（Stack-based），而Dalvik是基于寄存器的虚拟机（Register-based）。显然，后者最大的好处在于可以依据硬件实现更大的优化，这更适合移动设备的特点。 应用框架层（Application Framework）&emsp;&emsp;在整个Android系统中，与应用开发最相关的是Application Framework，在这一层，Android为应用程序层的开发者提供了各种功能强大的APIs，这实际上是一个应用程序的框架。由于上层的应用程序是以Java构建的。在本层提供了程序中所需要的各种控件，例如：Views（视图组件）、List（列表）、Grid（栅格）、Text Box（文本框）、Button（按钮），甚至还有一个嵌入式的Web浏览器。&emsp;&emsp;这一层提供的主要组件有： 名称 描述 Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager(位置管理器) 提供地理位置以及定位功能服务 Package Manager(包管理器) 管理所有安装在Android系统中的应用程序 Notification Manager(通知管理器) 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager(电话管理器) 管理所有的移动设备功能 Window Manager（窗口管理器） 管理所有开启的窗口程序 Content Providers（内容提供器） 使得不同应用程序之间可以共享数据 View System（视图系统） 构建应用程序的基本组件 应用层（Application）&emsp;&emsp;系统内置的应用程序以及非系统级的应用程序都是属于应用层。Android的应用程序负责与用户进行直接交互（GUI），通常基于Java进行开发，有时候还包含各种被放置在“res”目录中的资源文件。Java源码和相关资源在经过编译后会生成一个APK包。此外应用程序的开发者还可以使用应用程序框架层的API实现自己的程序。应用层是Android巨大潜力的体现。 Android源码结构&emsp;&emsp;源码的全部工程可以分为三个部分： Core Project：核心工程部分，这是建立Android系统的基础，保存在根目录的各个文件夹中。 External Project：扩展工程部分，可以使其他开源项目具有扩展功能，保存在external文件夹中。 Package：包部分，提供了Android的应用程序、内容提供者、输入法和服务，保存在package文件夹中。 &emsp;&emsp;源码中包含了原始的Android的目标机器代码、主机编译工具和仿真环境。第一级别目录结构如下： 名称 描述 abi 应用程序二进制接口 art 全新的ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发包配置 cts Android兼容性测试套件标准 dalvik dalvik虚拟机 developers 开发者目录 development 应用程序开发相关代码 device 设备相关配置 docs 参考文档目录 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码。Android NDK（Android Native Development Kit）是一系列的开发工具，允许程序开发人员在Android应用程序中嵌入C/C++语言编写的非托管代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 底层文件系统库、应用和组件，C语言实现 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 学习资料Android系统源码阅读清华大学开源软件镜像站 参考文章https://juejin.im/post/5c0f7b90f265da613b6f9e97 table th:nth-of-type(1){ width:35%; } table th:nth-of-type(2){ width: 65%; }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式软件开发工程师知识点]]></title>
    <url>%2F2019%2F09%2F16%2F0035-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[什么是预编译，何时需要预编译？&emsp;&emsp;预编译又称预处理，是做一些代码文本的替换工作，处理‘#’开头的指令 , 比如拷贝 #include包含的文件代码， #define 宏定义的替换 , 条件编译等就是为编译做的预备工作的阶段预编译指令指示了在程序正式编译前就由编译器进行了操作，可以放在程序的任何位置。&emsp;&emsp;何时使用：当大部分文件代码基本上不会更改时，比如 MFC的一些头文件以及一些必要的API 使用代码，也可以把你自己的一部分代码封装起来到一个 C或 C++文件中，（比如在其中包含一些头文件或必要的代码什么的， 然后在 VC-C/C++–PreCompiled Headers 里选择第三项 Create compiled Header file ）来指定为预编译头文件，这样就在以后的程序修改中编译时不会反复编译这部分。 注意：过多的使用预编译头文件会大大降低编译的速度。 左定值右定向&emsp;&emsp;深入理解 char &#42; const p,char const &#42; p,const char &#42; p 的区别 关键看 const 修饰的是谁 由于没有 const &#42; 的运算，若出现 const &#42; 的形式，则 const 实际上是修饰前面的。 &emsp;&emsp;char &#42; const p （const 修饰的是 p）：只能对“某个固定的位置” 进 行读写操作，并且在定义 p 时就必须初始化 （因为在后面不能执行“ p=.. ”的操作， 因此就不能在后面初始化，因此只能在定义时初始化） 。 “某个固定的位 置”是相对于 char &#42; p 来说所限定的内容。 &emsp;&emsp;char const&#42; p, 由于没有const&#42;运算，则const实际上是修饰前面的char，因此char const&#42; p等价于const char&#42; p。const char&#42; p 或者char const &#42; p （因为没有 const&#42; p 运算，因此const修饰的还是前面的char，可以对任意位置 （非系统敏感区域） 进行“只读” 操作。 “只读”是相对于 char &#42; p 来说所限定的内容。 指针的长度？&emsp;&emsp;一个 32 位的机器 , 该机器的指针是多少位?：&emsp;&emsp;指针是多少位只要看地址总线的位数就行了。 80386 以后的机子都是 32 的数据总线。所以指针的位数就是 4 个字节了。 进程的同步机制&emsp;&emsp;列举几种进程的同步机制，并比较其优缺点 。 原子操作 信号量机制 自旋锁 管程 会合 分布式系统 进程之间通信的途径&emsp;&emsp;途径归纳而言如下： 数据传输：一个进程向另一个进程传输数据，一般在一个字节和几 M字节之间。 共享数据 资源共享： 多个进程之间共享同样的资源， 为了做到这一点需要内核提供锁和同步机制。 通知事件 : 一个进程向另一个进程或一组进程发送消息， 通知他梦发生了某种事件 （如进程终止样通知付进程） 进程控制：有些进程希望完全控制另一个进程（ Debug进程），此时控制进程希望能够拦截另一个进程的所有的陷入和异常，并能够及时知道他的状态改变。 管道 ( pipe ) ：&emsp;&emsp;管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。&emsp;&emsp;创建一个简单的管道，可以使用系统调用 pipe() 。它接受一个参数，也就是一个包括两个整数的数组。 如果系统调用成功， 此数组将包括管道使用的两个文件描述符。 创建一个管道之后，一般情况下进程将产生一个新的进程。 1234567891011121314151617181920212223242526/*****************************************************系统调用： pipe();原型： int pipe(int fd[2]);返回值：如果系统调用成功，返回 0。如果系统调用失败返回 -1 ：errno=EMFILE( 没有空亲的文件描述符）EMFILE （系统文件表已满）EFAULT （fd 数组无效）注意： fd[0] 用于读取管道， fd[1] 用于写入管道。*****************************************************//*管道的创建*/#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int pipe_fd[2]; if(pipe(pipe_fd)&lt;0)&#123; printf("pipe create error\n"); return -1; &#125; else printf("pipe create success\n"); close(pipe_fd[0]); close(pipe_fd[1]);&#125; 管道的读写管道主要用于不同进程间通信。实际上，通常先创建一个管道，再通过 fork 函数创建一个子进程。 子进程写入和父进程读的命名管道： 管道读写注意事项：&emsp;&emsp;可以通过打开两个管道来创建一个双向的管道。但需要在子理程中正确地设置文件描述符。&emsp;&emsp;必须在系统调用 fork() 中调用 pipe() ，否则子进程将不会继承文件描述符。当使用半双工管道时，任何关联的进程都必须共享一个相关的祖先进程。因为管道存在于系统内核之中，所以任何不在创建管道的进程的祖先进程之中的进程都将无法寻址它。 而在命名管道中却不是这样。&emsp;&emsp;管道实例见： pipe_rw.c 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;unistd.h&gt;#include&lt;memory.h&gt;#include&lt;errno.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int pipe_fd[2]; pid_t pid; char buf_r[100]; char* p_wbuf; int r_num; memset(buf_r,0,sizeof(buf_r)); 数组中的数据清 0； if(pipe(pipe_fd)&lt;0)&#123; printf("pipe create error\n"); return -1; &#125; if((pid=fork())==0)&#123; printf("\n"); close(pipe_fd[1]); sleep(2); if((r_num=read(pipe_fd[0],buf_r,100))&gt;0)&#123; printf("%d numbers read from be pipe is %s\n",r_num,buf_r); &#125; close(pipe_fd[0]); exit(0); &#125;else if(pid&gt;0)&#123; close(pipe_fd[0]); if(write(pipe_fd[1],"Hello",5)!=-1) printf("parent write success!\n"); if(write(pipe_fd[1]," Pipe",5)!=-1) printf("parent wirte2 succes!\n"); close(pipe_fd[1]); sleep(3); waitpid(pid,NULL,0);exit(0); &#125;&#125; 有名管道(named pipe)&emsp;&emsp;有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号量(semophore)&emsp;&emsp;信号量是一个计数器，可以用来控制多个进程对共享资源的访问。 它常作为一种锁机制， 防止某进程正在访问共享资源时， 其他进程也访问该资源。 因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列(message queue)&emsp;&emsp;消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。 消息队列克服了信号传递信息少、 管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号(sinal)&emsp;&emsp;信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。信号是软件中断。信号（ signal ）机制是 Unix 系统中最为古老的进程之间的能信机制。它用于在一个或多个进程之间传递异步信号。很多条件可以产生一个信号。 共享内存(shared memory)&emsp;&emsp;共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。 它往往与其他通信机制， 如信号两， 配合使用，来实现进程间的同步和通信。 套接字(socket)&emsp;&emsp;套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 死锁&emsp;&emsp;死锁产生的原因及四个必要条件: 产生死锁的原因： 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当等。 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 其次， 进程运行推进顺序与速度不同， 也可能产生死锁。 产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件， 只要系统发生死锁， 这些条件必然成立， 而只要上述条件之一不满足，就不会发生死锁 。 死锁的解除与预防：&emsp;&emsp;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 所以，在系统设计、 进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法， 避免进程永久占据系统资源。 此外， 也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 操作系统中进程调度策略有哪几种？ FCFS(先来先服务 ) 优先级 时间片轮转 多级反馈 纯虚函数&emsp;&emsp;纯虚函数如何定义？使用时应注意什么？ 1virtual void f()=0; 是接口，子类必须要实现 数组和链表的区别数组&emsp;&emsp;数据顺序存储，固定大小。 链表&emsp;&emsp;数据可以随机存储，大小可动态改变 网络编程ISO 的七层模型是什么？&emsp;&emsp;OSI（Open System Interconnection ）参考模型是国际标准化组织（ ISO）制定的一个用于计算机或通信系统间互联的标准体系， 一般称为 OSI 参考模型或七层模型。 它是一个七层的、抽象的模型，不仅包括一系列抽象的术语或概念，也包括具体的协议 &emsp;&emsp;网卡、集线器、hub工作在物理层&emsp;&emsp;路由器(router)工作在网络层&emsp;&emsp;交换机(switch)工作在数据链路层&emsp;&emsp;常见的网络层协议： IP 协议、 ICMP、 IGMP、 MPLS、 ARP&emsp;&emsp;常见的传输层协议： TCP、 UDP&emsp;&emsp;常见的应用层协议： TELNET、 SMTP、 HTTP、 FTP、 DHCP、 SNMP tcp/udp 是属于哪一层？&emsp;&emsp;tcp /udp 属于传输层&emsp;&emsp;TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等&emsp;&emsp;与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、 流控制以及错误恢复功能等。由于 UDP 比 较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好，开销大，实时性较差。udp: 包头小，开销小 , 占用资源少，实时性较好，缺点是不可靠。 tcp 是面向连接的可靠字节流 tcp/udp 有何优缺点？&emsp;&emsp;udp 是无连接的不可靠报文传递。&emsp;&emsp;TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须在双方之间建立一个 TCP连接，之后才能传输数据， TCP提供超时重发、丢弃重复数据、检验数据、流控制等功能，保证数据能从一端传输到另一端。&emsp;&emsp;UDP是用户数据报协议，是一个简单的面向数据报的运输层的协议。 UDP不提供可靠性，他只是把应用程序传给 IP 层的数据报发送出去。但是并不保证它们到达目的地，由于 UDP在传输前不需要在客户端与服务器端之间建立一个连接， 且没有超时重发机制， 故而传输速度很快。 1234main()&#123;int a[5]=&#123;1,2,3,4,5&#125;;int *ptr=(int *)(&amp;a+1); 已知一个数组 table ，用一个宏定义，求出数据的元素个数1#define NIBL （sizeof(table)/sizfof(table[0]) ） 对于一个频繁使用的短小函数 , 在 C语言中应用什么实现 , 在 C++中应用什么实现 ?答案： c 用宏定义， c++用 inline 软件测试&emsp;&emsp;软件测试都有那些种类 ? 黑盒测试黑盒测试&emsp;&emsp;指的是把被测的软件看作是一个黑盒子， 我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。它只检查程序功能是否按照需求规格说明书的规定正常使用， 程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。 白盒测试&emsp;&emsp;白盒测试， 指的是把盒子盖子打开， 去研究里面的源代码和程序结果。 它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作 灰盒测试&emsp;&emsp;灰盒测试介于黑盒测试与白盒测试之间。&emsp;&emsp;可以这样理解， 灰盒测试关注输出对于输入的正确性， 同时也关注内部表现， 但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。 关于枚举1Enumstring &#123; x1, x2, x3=10, x4, x5, &#125;x; &emsp;&emsp;问 x；&emsp;&emsp;枚举元素的值不可以改变 但是你可以在定义时对其进行初始化 若都不赋值依次为 0 1 2 3 4 5 。。。若赋了一个值则后面的值为前面的一次加一对其进行赋值如 12345678enum string&#123; x1=1, x2, x3=10, x4=12, x5,&#125;x; &emsp;&emsp;那么现在元素的值依次为：1 2 10 12 13 关于指针1234unsigned char *p1; unsigned long *p2; p1=(unsigned char*)0x801000; p2=(unsigned long *)0x810000; 请问： 12p1+5=?;p2+5=?; &emsp;&emsp;答案： 12p1+5=801005;p2+5=810014; 不要忘记了这个是 16 进制的数字， p2 要加 20 变为 16 进制就是 14 TCP/IP 通信建立的过程怎样，端口有什么作用？&emsp;&emsp;三次握手，确定是哪个应用程序使用该协议&emsp;&emsp;TCP/IP 的三次握手 第一次握手： 客户端发送 syn 包(syn=j) 到服务器， 并进入 SYN_SEND状态， 等待服务器确认 ; 第二次握手：服务器收到 syn 包，必须确认客户的 SYN(ack=j+1) ，同时自己也发送一个SYN包(syn=k) ，即 SYN+ACK包，此时服务器进入 SYN_RECV状态 ; 第三次握手：客户端收到服务器的 SYN+ACK包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。 &emsp;&emsp;理想状态下， TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP连接的请求，断开过程需要经过“四次握手” ( 过程就不细写了，就是服务器和客户端交互，最终确定断开 ) TCP/UDP区别&emsp;&emsp;TCP-传输控制协议， 提供的是面向连接、 可靠的字节流服务。 但客户端和服务器端彼此交换数据前，必须现在双方建立 TCP连接，然后才能传输数据。TCP提供方超时重发，丢弃重复的数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。&emsp;&emsp;UDP：用户数据报协议，是一个简单的面向数据报的运输层协议， UDP不提供平可靠性，他只是负者吧应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能够到达目的地，&emsp;&emsp;由于 UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度快 局部变量能否和全局变量重名？&emsp;&emsp;能， 局部会屏蔽全局。 要用全局变量， 需要使用 “::” 局部变量可以与全局变量同名，在函数内引用这个变量时， 会用到同名的局部变量， 而不会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多个同名的局部变量， 比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 如何引用一个已经定义过的全局变量？extern 可以用引用头文件的方式， 也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？&emsp;&emsp;可以，在不同的 C文件中以 static 形式来声明同名全局变量。可以在不同的 C文件中声明同名的全局变量， 前提是其中只能有一个 C文件中对此变量赋初值， 此时连接不会出错 无限循环的表示方式for( ; 1 ; )&emsp;&emsp;语句 for( ; 1 ; ) 有什么问题？它是什么意思？ 1和while(1) 相同。 队列和栈队列和栈有什么区别 ？1队列先进先出，栈后进先出 内存分配&emsp;&emsp;内存分配应该注意什么问题？ 检查内存是否分配成功 内存生命周期，程序结束时记得 free ，避免内存的泄露 使用过程中，避免指针的越界访问，会导致不必要的错误。 线程和进程区别 进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。 优缺点&emsp;&emsp;线程和进程在使用上各有优缺点： 线程执行开销小， 但不利于资源管理和保护，而进程正相反。 同时，线程适合于在 SMP机器上运行，而进程则可以跨机器迁移。 &emsp;&emsp;根本区别就一点：用多进程每个进程有自己的地址空间 (address space) ，线程则共享地址空间。所有其它区别都是由此而来的： 速度： 线程产生的速度快， 线程间的通讯快、 切换快等， 因为他们在同一个地址空间内。 资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 同步问题： 线程使用公共变量 / 内存时需要使用同步机制还是因为他们在同一个地址空间内。 实时操作系统 ： 所谓实时操作系统， 实际上是指操作系统工作时， 其资源可以根据需要随时进行动态分配，由于各种资源可以进行动态分配，因此其处理事务的能力较强、速度较快。其主要的特点是提供及时的响应和高可靠性。 堆栈溢出的主要原因是没有回收垃圾资源。C语言的定义和声明定义&emsp;&emsp;编译器在创建一个对象时， 为该对象申请开辟的内存空间， 这个空间的的名字就是变量名或者对象名。同一个变量名在摸个区域内只能定义一次，重复定义会出现错误的。 声明&emsp;&emsp;声明有两种作用： 告诉编译器， 这个变量或者函数， 我已经定义了 （开辟空间了） ， 但是在别的地方，我先说明一下，免得编译器报错。当然，声明可以多次出现。 告诉编译器，这个变量名或者对象名，我先预定了， 其他地方不可以用了。和在饭馆吃饭（人多）要提前预约一样的道理。 定义和声明最本质的区别在于， 声明没开辟空间， 而定义则创建对象 （变量） 并开辟了空间。这是最重要的一点。 结构体的大小&emsp;&emsp;这个结构体的大小多少？ 1234567struct Test&#123; int Num ；char*Pc ；short sDtate ；char ch[2];short S[4];&#125;*p; &emsp;&emsp;int：占 4 个字节（ 32 系统）。&emsp;&emsp;char pc：指针相当于地址，地址就是你当前操作系统的位数。如果是指针数组即存放指针的数组，占用的空间是 4数组的个数。&emsp;&emsp;如果是数组指针即指向数组的指针，指针指向的是数组的地址，占用 4 个字节。 123short sDtate：2 个char ch[2]：2 个short S[4]：2*4=8 short 型数组 &emsp;&emsp;所以一起占用：4+4+2+2+8=20 字节。 在C++中引用C&emsp;&emsp;如何在 C++中引用 C？&emsp;&emsp;C++和 C是两种完全不同的编译连接处理方式，如果直接在 C++里面调用 C函数，会找不到函数体， 报连接错误， 就要在 C++文件中面申明哪些函数是 C写的， 要用 C的处理方式处理。&emsp;&emsp;1、 引用头文件前需要加上 extern “C”如： 1234extern "C"&#123; #include "S.h"&#125; &emsp;&emsp;2、 C++调用 C函数的方法，将用到的函数全部重新声明一遍，如 1234Extern "C"&#123; Externa void A_app(int);&#125; &emsp;&emsp;C++语言支持函数的重载， C语言不支持函数的重载。函数被 C++编译后在库中的名字与 C语言的不同， 所以 C++程序不能直接调用 C函数， C++提供一个 C连接交换指定符号 extern ” C”来解决这个问题。 C语言中嵌入汇编&emsp;&emsp;C语言中嵌入汇编？&emsp;&emsp;为什么需要嵌入汇编： C语言是一种中级语言，可以实现高级语言的模块化编程，又可以实现对底层的操作。但是，与汇编相比， C语言的效率还是比较低的。因此，在对效率与硬件操作要求比较高的地方，可以采用将部分汇编语句嵌入到 C语言中的方式。&emsp;&emsp;在 gcc 中，可以使用 asm_表示后面代码为内嵌汇编代码， _volatile 表示编译器不要优化代码。语法 asm volatile( 汇编语句模板：输出部分：输入部分：破坏描述部分 )&emsp;&emsp;汇编语句模板是汇编命令的字符串， 输出部分是需要输出到 C变量参数列表， 输入部分是需要从 C变量输入到 ASM汇编的参数列表， 破坏描述部分是执行汇编指令会破坏的寄存器描述。 预处理指令#error&emsp;&emsp;#error 预处理指令的作用是 ，编译程序时，只要遇到 #error 就会生成一个编译错误提示消息，并停止编译。其语法格式为： #error error-message Linux的内存管理&emsp;&emsp;早期的计算机中，程序直接运行在物理内存上。但是不适合现在的系统，这些支持多任务，多进程的。 这个时候我们就要考虑将系统的有限的物理内存如何及时有效的分配给多个程序，这个事情本身我们称之为内存管理。&emsp;&emsp;内存管理想要解决的问题： 进程地址空间不能分割，由于程序直接访问的是物理内存，这个时候程序锁使用的内存空间不是隔离的。 内存使用的效率低， 程序运行的地址不能确定， 程序每次运行的时候， 都要在内存中开辟一块足够大的空闲区域， 而这个空闲区域位置是不确定的，这会带来重定位的问题。 &emsp;&emsp;内存管理无非就是想办法解决上面三个问题， 如何使进程的地址空间隔离， 如何提高内存的使用效率，如何解决程序运行时的重定位问题？&emsp;&emsp;这里引用计算机界一句无从考证的名言： “计算机系统里的任何问题都可以靠引入一个中间层来解决。”&emsp;&emsp;内存管理的几种方式： 页式管理。 段式管理。 断页式管理 X86与X64&emsp;&emsp;Intel 曾用 8086,80286,80386 等作为其PC用 CPU的型号表示法： X86 是 Intel 制造的普通CPU； X64是 X86_64的缩写，是 X86 的改进版，加入了 64 位地址扩展等性能。 linux系统的Socket 网络编程&emsp;&emsp;socket 相当于进行网络通信两端的插座， 只要对方的 socket 和自己的 socket 有通信连接，双方就可以通信。&emsp;&emsp;服务器端的程序编写： 调用 ServerSocket （int port ）创建一个服务器端的套接字，并绑定到指定的端口号。 调用 accept （），监听连接请求，则接收连接，返回通信套接字。 调用 Socket 类的 getOutStream （）和 getinputStream() 获取输出流和输入流，开始网络的输出与输入。 关闭通信套接字 Socket.close （） &emsp;&emsp;客户端的程序编写： 调用 Socket 创建一个流套接字，并连接到服务器。 调用 Socket 类的 getoutputstream() 和 fetInputStream 获取输出流和输入流，开始网络的数据的发送和接收。 关闭通信套接字 socket.close(). 网络中常见的 ping 命令是什么协议 ?&emsp;&emsp;Ping 的原理是，向指定的 ip 地址发送一定长度的数据包，按照约定，若指定的 IP 地址存在，会返回同样大小的数据包。在特定的时间没有返回，就是超时，一般认为指定的 IP 地址不存在。 Ping 使用的是 ICMP（Internet Control message protocol Internet 控制消息协议）。&emsp;&emsp;有些防火墙会屏蔽 ICMP协议，所以有时候 ping 的结果只能做参考， ping 不同并不表示对方的 IP 不存在。 他是一把双刃剑， 别人使用 ping 命令可能会探测到你的计算机上的许多消息。可以安装防火墙，或创建一个禁止所有计算机 ping 本机地址的安全策略。]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式常见经典考点总结]]></title>
    <url>%2F2019%2F09%2F09%2F0034-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、预处理器（Preprocessor）用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）1#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL &emsp;&emsp;我在这想看到几件事情： #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等） 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。1 #define MIN(A,B) （（A） &lt;= (B) ? (A) : (B)) &emsp;&emsp;这个测试是为下面的目的而设的： 标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。 懂得在宏中小心地把参数用括号括起来 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？1least = MIN(*p++, b); 预处理器标识#error的目的是什么？&emsp;&emsp;如果你不知道答案，请看参考[附录]。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。 二、死循环（Infinite loops）&emsp;&emsp;嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？这个问题用几个解决方案。我首选的方案是： 1234while(1)&#123;&#125; &emsp;&emsp;一些程序员更喜欢如下方案： 1234for(;;)&#123;&#125; 这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是：”我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。 &emsp;&emsp;第三个方案是用 goto 123Loop:...goto Loop; 应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。 三、数据声明（Data declarations）&emsp;&emsp;用变量a给出下面的定义： a) 一个整型数（An integer） b)一个指向整型数的指针（ A pointer to an integer） c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r d)一个有10个整型数的数组（ An array of 10 integers） e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ） &emsp;&emsp;答案是： a) int a; // An integer b) int *a; // A pointer to an integer c) int **a; // A pointer to a pointer to an integer d) int a[10]; // An array of 10 integers e) int *a[10]; // An array of 10 pointers to integers f) int (*a)[10]; // A pointer to an array of 10 integers g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？ 四、Static&emsp;&emsp;关键字static的作用是什么？&emsp;&emsp;这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用： 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。 五、Const&emsp;&emsp;关键字const有什么含意？ 1用于限定一个变量为只读 &emsp;&emsp;我只要一听到被面试者说：”const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着”只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）&emsp;&emsp;如果应试者能正确回答这个问题，我将问他一个附加的问题：&emsp;&emsp;下面的声明都是什么意思？ 12345const int a;int const a;const int *a;int * const a;int const * a const; 前两个的作用是一样，a是一个常整型数。 第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。 第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。 最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。 如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由： 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。 六、Volatile&emsp;&emsp;关键字volatile有什么含意?并给出三个不同的例子。&emsp;&emsp;一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量&emsp;&emsp;回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。&emsp;&emsp;假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。 一个参数既可以是const还可以是volatile吗？解释为什么。 一个指针可以是volatile 吗？解释为什么。 下面的函数有什么错误：1234int square(volatile int *ptr)&#123; return *ptr * *ptr;&#125; &emsp;&emsp;下面是答案： 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。 这段代码有点变态。这段代码的目的是用来返指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：1234567int square(volatile int *ptr) &#123; int a,b; a = *ptr; b = *ptr; return a * b;&#125; &emsp;&emsp;由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： 123456long square(volatile int *ptr) &#123; int a; a = *ptr; return a * a;&#125; 七、位操作（Bit manipulation）&emsp;&emsp;嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。&emsp;&emsp;对这个问题有三种基本的反应: 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：1234567891011#define BIT3 (0x1 &lt;&lt; 3)static int a;void set_bit3(void) &#123; a |= BIT3;&#125;void clear_bit3(void) &#123; a &amp;= ~BIT3;&#125; &emsp;&emsp;一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。 八、访问固定的内存位置（Accessing fixed memory locations）&emsp;&emsp;嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下： 123int *ptr;ptr = (int *)0x67a9;*ptr = 0xaa55 &emsp;&emsp;A more obscure approach is:&emsp;&emsp;一个较晦涩的方法是： 1*(int * const)(0x67a9) = 0xaa55; &emsp;&emsp;即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。 九、中断（Interrupts）&emsp;&emsp;中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 interrupt。下面的代码就使用了interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码。 123456__interrupt double compute_area (double radius) &#123; double area = PI * radius * radius; printf("\nArea = %f", area); return area;&#125; &emsp;&emsp;这个函数有太多的错误了，以至让人不知从何说起了： ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。 ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。 重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这 样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。 十、代码例子（Code examples）12 . 下面的代码输出是什么，为什么？ void foo(void) { unsigned int a = 6; int b = -20; (a+b &gt; 6) ? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;); }&emsp;&emsp;这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。 评价下面的代码片断：123unsigned int zero = 0;unsigned int compzero = 0xFFFF; /*1's complement of zero */ &emsp;&emsp;对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下： 1unsigned int compzero = ~0; &emsp;&emsp;这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。&emsp;&emsp;到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧… 十一、动态内存分配（Dynamic memory allocation）&emsp;&emsp;尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所以回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？ 12345char *ptr;if ((ptr = (char *)malloc(0)) == NULL) puts("Got a null pointer");else puts("Got a valid pointer"); &emsp;&emsp;这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。 十二、Typedef&emsp;&emsp;Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子： 12#define dPS struct s *typedef struct s * tPS; &emsp;&emsp;以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子： 12dPS p1,p2;tPS p3,p4; 第一个扩展为 1struct s * p1, p2; //宏定义的只对就近的那个生效 &emsp;&emsp;上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。 十三、晦涩的语法&emsp;&emsp;C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是，它会做些什么？ 12int a = 5, b = 7, c;c = a+++b; &emsp;&emsp;这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成： 1c = a++ + b; &emsp;&emsp;因此, 这段代码持行后a = 6, b = 7, c = 12。&emsp;&emsp;如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。 十四、递增&amp;减运算符：++ &amp; –&emsp;&emsp;紧凑的代码让程序更为整洁，通常其生成的机器代码效率更高。&emsp;&emsp;递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)： ++出现在其作用的变量前面—前缀模式(++a)1q = 2*++a; 首先，a递增1； 然后，2乘以a，并将结果赋给q ++出现在其作用的变量后面—后缀模式(a++)1q = 2*a++; 首先，2乘以a，并将结果赋给q； 然后，a递增1 出现在其作用的变量前面—前缀模式(–a)出现在其作用的变量后面—后缀模式(a–)]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>知识总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux搬砖三剑客之shell]]></title>
    <url>%2F2019%2F08%2F29%2F0033-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bshell%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;这里讨论的shell，基于Bourne shell（默认shell） shell的特殊变量 特殊变量 描述 $0 当前脚本的文件名。 $n 这些变量对应于调用脚本的参数。这里n是对应于参数位置的正十进制数（第一个参数是$ 1，第二个参数是$ 2，依此类推）。 $# 提供给脚本的参数数量。 $* 所有参数都是双引号。如果脚本收到两个参数，$ *相当于$ 1 $ 2。 $@ 所有参数都是双引号。如果脚本收到两个参数，$ @相当于$ 1 $ 2。 $? 执行最后一个命令的退出状态。退出状态是每个命令完成后返回的数值。通常，大多数命令如果成功则返回退出状态0，如果不成功则返回1。 $$ 当前shell的进程号。对于shell脚本，这是它们执行的进程ID。 $! 最后一个后台命令的进程号。 $ *和$ @两者的行为相同，除非它们用双引号括起来，“”。这两个参数都指定命令行参数。但是，“$ *”特殊参数将整个列表作为一个参数，其间带有空格，“$ @”特殊参数获取整个列表并将其分隔为单独的参数。 shell的运算符算术运算符&emsp;&emsp;示例中,假设变量a为10，变量b为20。 操作符 描述 示例 + （加法）在运算符的任一侧添加值 expr $a + $b 将给出30 - （减法）从左手操作数中减去右手操作数 expr $a - $b 将给-10 * （乘法）将运算符两侧的值相乘 expr $a \* $b 将给出200 / （除法）用左手操作数除左手操作数 expr $b / $a 将给出2 % （取模）用左手操作数除左手操作数并返回余数 expr $b ％ $a 将给出0 = （赋值）在左操作数中指定右操作数 a = $b 会将b的值赋给a == （等于）比较两个数字，如果两个数字相同则返回true。 [ $a == $b ] 会返回false。 != （不等于）比较两个数字，如果两个数字不同则返回true。 [ $a != $b ] 会返回true。 关系运算符&emsp;&emsp;示例中,假设变量a为10，变量b为20。 操作符 描述 示例 -eq 检查两个操作数的值是否相等; 如果是，则条件成立。 [ $a -eq $b ] is not true. -ne 检查两个操作数的值是否相等; 如果值不相等，则条件成立。 [ $a -ne $b ] is true. -gt 检查左操作数的值是否大于右操作数的值; 如果是，则条件成立。 [ $a -gt $b ] is not true. -lt 检查左操作数的值是否小于右操作数的值; 如果是，则条件成立。 [ $a -lt $b ] is true. -ge 检查左操作数的值是否大于或等于右操作数的值; 如果是，则条件成立。 [ $a -ge $b ] is not true. -le 检查左操作数的值是否小于或等于右操作数的值; 如果是，则条件成立。 $a -le $b ] is true. 所有条件表达式应放在方括号内并且周围有空格是非常重要的。例如，[ $a &lt;= $b ]是正确的，而[$a&lt;=$b]是不正确的。 布尔运算符&emsp;&emsp;示例中,假设变量a为10，变量b为20。 操作符 描述 示例 ! 这是合乎逻辑的否定。这将真实条件反转为假，反之亦然。 [ ! false ] is true. -o 这是合乎逻辑的OR。如果其中一个操作数为true，则条件成立。 [ $a -lt 20 -o $b -gt 100 ] is true. -a 这是合乎逻辑的和。如果两个操作数都为真，则条件变为true，否则为false。 [ $a -lt 20 -a $b -gt 100 ] is false. 字符串运算符&emsp;&emsp;示例中,假设变量a为“abc”，而变量b为“efg”。 操作符 描述 示例 = 检查两个操作数的值是否相等; 如果是，则条件成立。 [ $a = $b ] is not true. != 检查两个操作数的值是否相等; 如果值不相等则条件变为真。 [ $a != $b ] is true. -z 检查给定的字符串操作数大小是否为零; 如果长度为零，则返回true。 [ -z $a ] is not true. -n 检查给定的字符串操作数大小是否为非零; 如果它是非零长度，则返回true。 [ -n $a ] is not false. str 检查str是否不是空字符串; 如果它是空的，则返回false。 [ $a ] is not false. 文件测试操作符&emsp;&emsp;这些运算符可用于测试与Unix文件相关的各种属性。&emsp;&emsp;示例中，假设变量文件包含现有文件名“test”，其大小为100字节，并具有读取，写入和执行权限。 操作符 描述 示例 -b file 检查文件是否是块特殊文件; 如果是，则条件成立。 [ -b $file ] is false -c file 检查文件是否是字符特殊文件; 如果是，则条件成立。 [ -c $file ] is false. -d file 检查文件是否是目录; 如果是，则条件成立。 [ -d $file ] is not true. -f file 检查文件是普通文件而不是目录或特殊文件; 如果是，则条件成立。 [ -f $file ] is true. -g file 检查文件是否设置了组ID（SGID）位; 如果是，则条件成立。 [ -g $file ] is false. -k file 检查文件是否设置了粘滞位; 如果是，则条件成立。 [ -k $file ] is false. -p file 检查文件是否是命名管道; 如果是，则条件成立。 [ -p $file ] is false. -t file 检查文件描述符是否打开并与终端关联; 如果是，则条件成立。 [ -t $file ] is false. -u file 检查文件是否设置了其用户ID（SUID）位; 如果是，则条件成立。 [ -u $file ] is false. -r file 检查文件是否可读; 如果是，则条件成立。 [ -r $file ] is true. -w file 检查文件是否可写; 如果是，则条件成立。 [ -w $file ] is true. -x file 检查文件是否可执行; 如果是，则条件成立。 [ -x $file ] is true. -s file 检查文件的大小是否大于0; 如果是，则条件成立。 [ -s $file ] is true. -e file 检查文件是否存在; 即使file是目录但存在，也是如此。 [ -e $file ] is true. shell修炼秘籍shell命令图谱 shell的种类 &emsp;&emsp;shell是一个用户终端，是内核与用户之间的翻译官。内核解释shell翻译过来的用户命令从而指挥CPU和其他计算机硬件如何执行特定任务。每次用户登录时，都会启动shell。shell的类型取决于用户的选择，在大多数情况下默认设置为bash。 bash&emsp;&emsp;Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell，它是用户帐户最常见的默认shell。 csh&emsp;&emsp;C Shell被创造的Bill Joy在加州大学伯克利分校。他的主要目的是使用类似C语言的语法创建一个shell。因此，它包括控制结构和表达式语法之类的功能。&emsp;&emsp;其他功能包括历史记录和编辑机制，别名，目录堆栈，代字符表示法，cdpath，作业控制和路径哈希等等。 tcsh&emsp;&emsp;将tcsh被开发成为与C shell兼容。t in tcsh来自TENEX，这是一个操作系统。&emsp;&emsp;tcsh与csh命令行编辑和其他功能等扩展非常接近。Mac OS X以前是tcsh默认配置，但在版本10.3中切换为bash。 zsh&emsp;&emsp;Z shell是专为交互式使用而设计的。&emsp;&emsp;Z shell的一些功能包括拼写检查，在单个缓冲区中编辑多行命令，改进的变量和数组处理，自定义，可编程命令行完成和可主题提示。 还有很多甚至更多&emsp;&emsp;还有很多shell可供选择！当我们了解有关终端和shell的更多信息时，可能希望升级到另一个shell。但是一般而言，bash已经很好地满足我们的需求了。 table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 90%; } table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 65%; } table th:nth-of-type(3){ width: 25%; }]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux搬砖三剑客之vi&vim]]></title>
    <url>%2F2019%2F08%2F28%2F0032-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bvi%26vim%2F</url>
    <content type="text"><![CDATA[前言不可不知的两大编辑器： 编辑器之神——Vim 神之编辑器——Emacs &emsp;&emsp;有趣的编辑器之战。 &emsp;&emsp;vim与神的编辑器emacs的争论从来没有停止过。两种编辑器的设计哲学完全不同，风格迥异。vim的特点是Composability（组合性），Emacs的特点是Extensibility（可扩展性）。vim使用键序列输入，Emacs则经常使用组合键（同时按）输入，所以Emacs有个绰号Esc + Meta + Alt + Ctrl + Shift。正因为各种显著的差异各种争论在所难免，对此我们应该端正自己的心态：提高自己的格局，少一些争论。 磨刀不误砍柴工&emsp;&emsp;不做无谓的争论，工欲善其事必先利其器，我们只管选择一种自己顺手的工具（我选择vi&amp;vim）来学习，不断深入学习，提高自己的同时，不断与工具磨合，早日达到人剑合一的境界，笑看江湖。 进入vim的姿势 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +num filename 打开文件，并将光标置于第n行首 vim + filename 打开文件，并将光标置于最后一行首 vim +/pattern filename 打开文件，并将光标置于第一个与pattern匹配的串处 vim -r filename 在上次正用vim编辑时发生系统崩溃，恢复filename vim filenae1…filenamen 打开多个文件，依次编辑 vim配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位（Ctrl+1）和行尾标志（$）显示行号 number 显示由面向行的命令修改过的数目 report 显示简短的警告信息 terse 在转到别的文件时若没保存当前文件则显示NO write信息 nomagic 允许在搜索模式中，使用前面不带“V的特殊字符 nowrapscan 禁止vi在搜索到达文件两端时，又从另一端开始 mesg 允许vi显示其他用户用write写到自己终端上的信息 :set number 显示行号 :set nonumber 不显示行号 set ruler 显示标尺 set noruler 不显示标尺 :set hlsearch 高亮显示查找到的单词 :set nohlsearch 关闭高亮显示 :syntax on 语法高亮显示行号 :set tabstop=8 设置tab大小，8为最常用最普遍的设置4.4个空格，8.正常的制表符，12:一个制表符4个空格，16.两个制表符 :set autoindent 自动缩进 :set cindent C语言格式里面的自动缩进 移动光标 命令 描述 k 向上移动 j 向下移动 h 向左移动 l 向右移动 k nk 向上移动n行 j nk 向下移动n行 h nh 向左移动n行 l nl 向右移动n行 Spach 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e/e 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至段落开头 { 光标移至段落结尾 n$ 光标移至第n行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 （注意是数字零）光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符a上 F 与f相反 % 移动到与制匹配的括号上去（），}，Ⅱ，&lt;&gt;等 nG 移动到第n行上 G 到最后一行 屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl+b 向文件首翻一屏 nz 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部 插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符，直至按ESC键 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 删除命令 命令 描述 x/X 删除一个字符，x删除光标后的，而X删除光标前的 dw 删除一个单词（删除光标位置到下一个单词开始的位置） dnw 删除n个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后n-1行 dnl 向右删除n个字母 dnh 向左删除n个字母 dnj 向下删除n行，当前行+其上n行 dnk 向上删除n行，当期行+其下n行 cnw[word] 将n个word改变为word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 复制粘贴 命令 描述 p 粘贴用x或d删除的文本 ynw 复制n个单词 yy 复制一行 ynl 复制n个字符 y$ 复制当前光标至行尾处 nyy 拷贝n行 撤销|u |撤销前一次的操作|shif+u(U) |撤销对该行的所有操作 搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索pattern ?pattern 从光标开始处向文件首搜索pattern n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令 cw newword 替换为newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有p1均用p2替代，g表示执行用c表示需要确认 :n1,n2 s/p1/p2/g 将第n1至n2行中所有p1均用p2替代 :g/p1/s//p2/g 将文件中所有p1均用p2替换 :1,$ s/string1/string2/g 在全文中将string1替换为string2 书签 命令 描述 ,[a-z] 在文中做标记，标记号可为a-z的26个字母 `a 移动到标记a处 visual模式 命令 描述 v 进入visual模式 V 进入行的visual模式 ctrl+V 进如块操作模式用o和O改变选择的边的大小 在所有行插入相同的内容如include&lt; 将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按1（shit+），后插入要插入的文本，按IESC]完成 行方式命令 命令 描述 :n1,n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下 :n1,n2 m n3 将n1行到n2行之间的内容移至到第n3行下 :n1,n2 d 将n1行到n2行之间的内容删除 :n1,n2 wlcommand 将文件中n1行至n2行的内容作为command的输入并执行之 若不指定n1，n2，则表示将整个文件内容作为command的输入 | 宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏 reg 显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z] 操作窗口 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件fle.c分隔窗口 :nsplit file.c 为另一个文件file.c分隔窗口，并指定其行数 ctrl + W 在窗口中切换 :close 关闭当前窗口 文件及其他 命令 描述 :q退出vi :q! 不保存文件并退出vi/vim :e filename 打开文件filename进行编辑 :e! 放弃修改文件内容，重新载入该文件编辑 :W 保存当前文件 :wq 存盘后再退出 :ZZ 保存当前文档并退出vi/vim :!command 执行shell命令command :r!command 将命令command的输出结果放到当前行 :n1,n2 write temp.c :read file.c 将文件file.c的内容插入到当前光标所在的下面 修炼秘籍寓教于乐&emsp;&emsp;非常有趣的VIM学习小游戏。 修炼秘籍vim命令图解（中文版） vim命令图解（英文版） vim命令图解大全&emsp;&emsp;此图内容比较繁多，窃以为入门学习上面两个图足矣。 &emsp;&emsp;当然，如果对此资源感兴趣，可前往此处获取更全面的资源。 其他未分类资源 参考&emsp;&emsp;编辑器之战 table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 80%; }]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux搬砖三剑客之git]]></title>
    <url>%2F2019%2F08%2F21%2F0031-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BGit%2F</url>
    <content type="text"><![CDATA[git指令速查表 创建复制一个已创建的仓库1$ git clone ssh://user@domain.com/repo.git 创建一个新的本地仓库1$ git init 本地修改显示工作路径下全部已修改的文件1$ git status 显示与上次提交版本文件的不同1$ git diff 把当前所有修改添加到下次提交中1$ git add . 指定某个文件的修改添加到下次提交中1$ git add -p &lt;file&gt; 提交本地的所有修改1$ git commit -a 提交之前已标记的变化1$ git commit 修改上次提交1$ git commit --amend 提交历史从最新提交开始显示所有的提交记录1$ git log 显示指定文件的所有修改1$ git log -p &lt;file&gt; 谁，在什么时间，修改了文件的什么内容？1$ git blame &lt;file&gt; 分支与标签显示所有分支1$ git branch -av 切换当前分支1$ git checkout &lt;branch&gt; 基于当前分支，创建新分支1$ git branch &lt;new-branch&gt; 基于远端分支，创建新的可追溯的分支1$ git checkout --track &lt;remote/branch&gt; 删除本地分支1$ git branch -d &lt;branch&gt; 给当前的提交打标签1$ git tag &lt;tag-name&gt; 更新与发布列出当前配置的远端1$ git remote -v 显示远端信息1$ git remote show &lt;remote&gt; 添加新的远端1$ git remote add &lt;shortname&gt; &lt;url&gt; 下载远端的所有改动到本地，不会自动合并到当前1$ git fetch &lt;remote&gt; 将本地版本发布到远端1$ git push &lt;remote&gt; &lt;branch&gt; 删除远端分支1$ git branch -dr &lt;remote/branch&gt; 发布标签1$ git push --tags 合并与重置将分支合并到当前1$ git merge &lt;branch&gt; 将当前版本充值到分支中1$ git rebse &lt;branch&gt; 请勿重置已发布的提交！ 退出重置1$ git rebase --abort 解决冲突后继续重置1$ git rebase --continue 使用配置好的合并工具去解决冲突1$ git mergetool 在编辑器中手动解决冲去后，标记文件未已解决冲突12$ git add &lt;resolved-file&gt;$ git rm &lt;resolved-file&gt; 撤销放弃工作目录下的所有修改1$ git reset --hard HEAD 放弃某个文件的所有本地修改1$ git checkout HEAD &lt;file&gt; 通过创建一个截然不同的新的提交重置一个提交1$ git revert &lt;commit&gt; 将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改1$ git reset --hard &lt;commit&gt; 将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改1$ git reset &lt;commit&gt; 将HEAD重置到上一次提交的版本，并保留未提交的本地修改1$ git reset --keep &lt;commit&gt; git信条 提交要对应修改&emsp;&emsp;一次提交应该对应一个相关的改动，例如，两个不同的错误应该对应两次不同的提交、使它更容易让其他开发人员明白这个改动，如果这次改动存在问题，也可以方便的回滚到改动之前的状态，通过需存区标记功能。Git可以轻松打造非常精确的提交。 经常性地提交修改&emsp;&emsp;经常的提交改动可以更方便为它作注释。从而更容易确保提交的注释和改动的一致性，通过频繁快速的提交来与其他的开发人员共享这些改动。那样就会避免或减少代码整合时带来的冲突、反之，非常庞大的提交将会增大整合时出现冲突的风险。 不提交不完整地改动&emsp;&emsp;对于一个很大的功能模块来说.完成后再提交并不意味若必须整体完成后才可以，而是要把它正确分割成小的完整的逻辑模块进行经常性的提变，一定不要提交一些不完整的改动。仅仅是因为下班。&emsp;&emsp;同祥，如果只是为了得到一个干净的工作区城也不需要立即提交，可以通过Git的&lt;&gt;命令把这些改动移到另外的分支。 提交前进行代码测试&emsp;&emsp;不要提交还没有经过完整测试的改动。只有经过测试，并确定无误的改动才能提交。把改动发送给开发团队其他成员前，必须确定所有修改已经完整测试过。这样才算是真正的完成。 高质量地提交注释&emsp;&emsp;提交注释的开头需要一个少于50个字的简短说明.在一个空白的分割行之后要写出一个详细的提交细节.比如回答如下的两个问题； 出于什么理由需要这个修改？ 基于当前版本.具体改动了什么？ &emsp;&emsp;为了和自动生成的注释保持一致（例如：git merge），一定要使用现在时态祈使句（比如使用change 而不要使用changed和changes）. 版本控制不是备份&emsp;&emsp;版本控制系统具有一个很强大的附带功能，那就是服务器端的备份功能，但是不要把VCS当成一个备份系统。一定要注意.只需要提交那些有意义的改动而不要仅仅作为文件存储系统来使用。 使用分支功能&emsp;&emsp;自始至终Git的核心就是提供一个快速，简单和灵活的分支功能，分支是一个非常优秀的工具，用来帮助开发人员解决在日常团队开发中存在的代码冲突的问题。因此分支功能应该广泛的运用在不同的开发流程中，比如：开发新的功能、修错等等。 合理的工作流程&emsp;&emsp;Git可以支持很多不同流程；长期分支.特性分支，合并或是重置，git-flow等等选择哪一种流程要取决于如下一些因素；什么项目，什么样的开发，部署模式和（可能是量重要的）开发团队人员的个人习惯.不管怎样。选择什么样的流程都要得到所用开发人员的认同并且一直遭循它 使用帮助文档&emsp;&emsp;显示给定git指令的帮助文档 1$ git help &lt;command&gt; 修炼秘籍http://www.git-tower.com/learnhttp://rogerdudler.github.io/git-guide/http://www.git-scm.org/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统的编译]]></title>
    <url>%2F2019%2F08%2F16%2F0030-Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：http://source.android.com/source/initializing.html Android模块编译流程&emsp;&emsp;在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易。 第一步使build/envsetup.sh生效&emsp;&emsp;命令“source build/envsetup.sh”引入了 build/envsetup.sh脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。 123$ . build/envsetup.sh# 或者$ source build/envsetup.sh envsetup.sh脚本文件里包含vendorsetup.sh 、lunch、 m mm mmm的定义 第二步选择编译类型&emsp;&emsp;lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。编译类型会影响最终系统中包含的模块。&emsp;&emsp;如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，此时可以通过输入编号或者名称进行选择。 123$ lunch full# 或者$ lunch &lt;选择一个特定的编译类型&gt; 最后一步make1$ make -j8 &emsp;&emsp;在这里，make的选择有多种，具体内容分到下小节讨论。 make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。 最最后一步清理编译结果清理所有编译结果&emsp;&emsp;执行清理，相当于：rm -rf out/。 1$ make clean 清理一个指定模块的编译结果。1$ make clean-&lt;local_target&gt; 关于make的更多选项&emsp;&emsp;以下编译的编译选项可加上 “-j &lt;线程数&gt;”来启动多线程编译，加快编译的速度。 编译当前选定产品的OTA全量包&emsp;&emsp;也叫整包编译(all partitions)。 1$ make otapackage 编译所有内容&emsp;&emsp;编译所有内容，不管当前产品的定义中是否会包含。 1$ make all 编译boot.img1$ make bootimage 编译uboot.bin1$ ./mk &lt;uboot对应的版本&gt; --systemroot 编译 recovery.img(ramdisk-recovery.img)1$ make recoveryimage 编译vendor.img1$ make vendorimage 编译system.img1$ make systemimage 编译 userdata.img1$ make odm_image 编译 userdata.img1$ make userdataimage 编译ramdisk.img1$ make ramdisk 编译logo.img1$ make logoimage 快速重建系统镜像&emsp;&emsp;从已经编译出的包快速重建系统镜像。 1$ make snod 编译 dtb1$ make dtbimage 编译出 Android 的 SDK1$ make sdk 编译所有 JNI framework1$ make libandroid_runtime 编译所有 Java framework1$ make framework 编译系统服务和相关内容1$ make services 编译指定模块&emsp;&emsp;编译一个指定的模块，local_target 为模块的名称。 1$ make &lt;local_target&gt; 获取所有产品的编译配置信息&emsp;&emsp;显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。 1$ make dump-products 编译指定产品1$ make PRODUCT-xxx-yyy 获取帮助信息&emsp;&emsp;显示帮助信息，显示主要的make目标。 1$ make help 其他编译选项m编译m：编译整个安卓系统。（makes from the of the tree） mm编译mm：编译当前目录下的模块，当前目录下需要有Android.mk这个makefile文件，否则就往上找最近的Android.mk文件。（builds all of the moudles in the current directory）mma：当前目录新增或删除文件后，可以用mma重新编译。 mmm编译mmm：编译指定路径下的模块，指定的路径下面需要有Android.mk这个makefile文件。（builds all of the moudles in the supplies directory）mmma：指定目录下新增或删除文件后，可以用mmma重新编译。 // 未全编译的情况下，可以使用该命令单编译模块 mmm命令的编译过程1234567891011121314├── build/core/main.mk（是Android编译系统的入口文件） ├── build/core/config.mk（会定好编译类型和目标文件） ├── build/core/definitions.mk（定义在编译过程中用到的宏） ├── ONE_SHOT_MAKEFILE-&gt;build/core/package.mk（编译Apk库文件） ├── build/core/java_library.mk（编译Java库文件） ├── build/core/static_java_library.mk（编译Java静态库文件） ├── build/core/shared_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则） ├── build/core/dynamic_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则） ├── build/core/binary.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则） ├── build/core/base_rules.mk （ 计算一些基本变量的值，并创建一些基本的依赖规则） ├── build/core/static_library.mk（编译.a静态库文件） ├── build/core/executable.mk（编译可执行文件） ├── build/core/prebuilt.mk（编译已经预编译好的第三方库文件） ├── build/core/Makfile（有system.img、boot.img、recovery.img等镜像文件生成规则） 环境变量ONE_SHOT_MAKEFILE中存放要编译模块的Android.mk的文件路径，如果环境变量值为空，表示执行的是m或者make命令，会对Android源代码中的所有模块进行编译。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的分区和启动流程]]></title>
    <url>%2F2019%2F08%2F15%2F0029-Android%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%98%A0%E5%83%8F%2F</url>
    <content type="text"><![CDATA[Android分区什么是分区&emsp;&emsp;Android的分区就像是盖房子那样一块块砖块垒起来的，每块砖块放在合适的位置，遇到特特殊的需求，我们就将砖块修正一下（增加或裁减分区），这样我们的房子（Android系统）就慢慢起来了。盖房子需要很多砖头，但是我们Android的大楼主要是由几块砖块组成，这样我们学习起来就简单很多了，毕竟我们不用学习怎么盖一栋楼那么难（手动滑鸡）。&emsp;&emsp;分区的重要性我们可以总结起来：分划决定发展，大小决定成败 分划决定我们要划分不同的大小不同的分区，这个决定了整个平台的规划分区的大小，影响了我们存储的数据量 分区的类型&emsp;&emsp;分区类型有裸分区和文件系统分区两部分。 裸分区&emsp;&emsp;裸分区是指二进制存储到flash中的数据分区：如fashboot、boot、recovery、misc等 文件系统分区&emsp;&emsp;文件系统分区是指通过挂载进行文件操作的分区，如cache、system、data等 各个分区的作用&emsp;&emsp;通过以上的介绍我们初步了解了分区，也知道了分区的类型，下面对常见分区进行简要的介绍，这些分区在启动过程中发挥不同的作用： boot：boot 分区包含通过 mkbootimg 组合在一起的内核映像和 RAM 磁盘。为了直接刷写内核而不刷写新的 boot 分区，可以使用虚拟分区： kernel：kernel 虚拟分区仅覆盖内核（zImage、zImage-dtb、Image.gz-dtb），方法是写入新的映像来覆盖旧的映像。为此，它会确定 eMMC 中现有内核映像的起始位置并将新内核映像复制到该位置。请记住，新内核映像可能会大于现有内核映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。如果提供的开发内核不兼容，则可能需要使用相关的内核模块更新 dtb 分区（如果存在）、vendor 分区或 system 分区。 ramdisk：ramdisk 虚拟分区通过将新映像写入旧磁盘来仅覆盖 RAM 磁盘。为此，它会确定 eMMC 中现有 ramdisk.img 的起始位置并将新 RAM 磁盘映像复制到该位置。请记住，新 RAM 磁盘映像可能会大于现有 RAM 磁盘映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。 system：system 分区主要包含 Android 框架。 recovery：recovery 分区用于存储在 OTA 过程中启动的恢复映像。如果设备支持 A/B 更新，则恢复映像可以是启动映像中包含的 RAM 磁盘，而不是单独的映像。 cache：cache 分区用于存储临时数据，如果设备使用 A/B 更新，则可以不要此分区。cache 分区不需要可从引导加载程序写入，而只需要可清空。大小取决于设备类型和 userdata 分区的可用空间。目前，50MB 至 100MB 应该没问题。 misc：misc 分区供恢复映像使用，存储空间不能小于 4KB。 userdata：userdata 分区包含用户安装的应用和数据，包括自定义数据。 metadata：如果设备被加密，则需要使用 metadata 分区，该分区的存储空间不能小于 16MB。 vendor：vendor 分区包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，则可以省略此分区。 radio：radio 分区包含无线装置映像。只有包含无线装置且在专用分区中包含无线装置专用软件的设备才需要此分区。 tos：tos 分区用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用。 摘自：source.android.google &emsp;&emsp;注：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。 通用的Android系统分区&emsp;&emsp;安卓手机和平板一般包括以下分区： 名称 作用 /u-boot 启动分区，引导加载kernel和烧录的作用 /partition partition/parameter.txt存储分区表信息 /misc 存储标记升级存储的一些升级信息 /logo 开机画面 /recovery 升级模块 /boot 内核分区（启动Android系统） /system 系统分区 /cache 缓存临时文件，和下载升级包存储升级 /data 用户数据分区，安装的apk，缓存文件，系统启动的必要文件，数据库等用户相关信息。 misc&emsp;&emsp;此分区包含了一些系统设置和系统功能启用禁用的相关设置。这些设置包括CID(运营商或区域识别码）、USB设置和一些硬件设置等等。这是一个很重要的分区，如果此分区损坏或者部分数据丢失，手机的一些特定功能可能不能正常工作。 recovery&emsp;&emsp;在正常分区或内核分区被破坏，不能正常启动时，可以进入此分区进行恢复，他相当与一个简易的OS或blos，可以认为是一个boot分区的替代品，通过他可以让我们在这一分区进行备份维护和恢复，我们通常说的刷机便指的是此分区。&emsp;&emsp;进入此分区方法： 121、通过 adb reboot recovery2、通过组合键，电源键+音量键 boot&emsp;&emsp;此分区可以保证设备正常启动，它包含了kernel（内核）、ramdisk（虚拟内存盘：通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，可以极大的提高在其上进行的文件访问的速度)，如果没有此分区，设备通常不能正常启动。只有必要的时候，才去通过Recovery软件擦除（format）这个分区，一旦擦除，设备只有再重新安装一个新的boot分区，可以通过安装一个包含boot分区的ROM来实现，否则无法启动安卓系统。 system&emsp;&emsp;此分区用来存放除kernel和ramdisk以外的系统相关配置，他包括了用户界面、手机预装的软件等。擦除这个分区将会删除整个系统，但不会导致不能启动。可以通过进入Recovery程序或者bootloader程序中，安装一个新ROM(安卓系统)。 data&emsp;&emsp;此分区包含了用户的数据信息，如：联系人、短信、设置、用户安装的程序的，擦除此分区，相当于手机恢复出厂设置，可以在Recovery模式中选择“data/factory reset ”擦除此分区。 &emsp;&emsp;此分区下的一些常见目录： 12345/data/data/[packagename]/files 文件缓存目录,一般存小的文件缓存，如果是图片，不建议放这里，一般放到外置卡;/data/data/[packagename]/cache目录，存放一些其他缓存;/data/data/[packagename]/databases，存放数据库;/data/data/[packagename]/lib，应用的so目录;/data/data/[packagename]/shared_prefs 应用的SharedPreferences保存; cache&emsp;&emsp;此分区是安卓系统缓存区，他保存系统最常访问的数据和应用程序。擦除这个分区，不会影响个人数据，只是删除了这个分区中已经保存的缓存内容，缓存内容会在后续手机使用过程中重新自动生成。 Android的启动流程&emsp;&emsp;Android 从 Linux 系统启动有 4 个步骤； init 进程启动 Native 服务启动 System Server，Android 服务启动 Home 启动 init(initial)进程启动(system\core\init)&emsp;&emsp;init 进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序 init 的方式，完成引导进程。init 始终是第一个进程.&emsp;&emsp;init 进程一起来就根据 init.rc 和 init.xxx.rc 脚本文件建立了几个基本的服务： servicemanamger zygote &emsp;&emsp;最后 init 并不退出，而是担当起 property service 的功能。Property service 就是属性设置 通过init.rc启动服务&emsp;&emsp;system/core/init/init.c 中parse_config_file(Init.rc)&emsp;&emsp;解析脚本文件：init.rc 和 init.xxxx.rc(硬件平台相关)init.rc 是 Android自己规定的初始化脚本(Android Init Language,System/Core/Init/readme.txt)&emsp;&emsp;该脚本包含四个类型的声明： Action(动作) Commands(命令) Services(服务) Options(选项) Zygote&emsp;&emsp;Servicemanager和zygote进程就奠定了Android的基础。Zygote 这个进程起来才会建立起真正的Android运行空间，初始化建立的 Service 都是 Navtive&emsp;&emsp;service.在.rc 脚本文件中zygote的描述： 1service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote &emsp;&emsp;所以 Zygote 从 main(…) frameworks/base/cmds/app_main.cpp 开始 main(…) frameworks/base/cmds/app_main.cpp 建立 Java Runtime runtime.start(“com.android.internal.os.ZygoteInit”, startSystemServer); runtime.start AndroidRuntime.cpp 建立虚拟机 运行：com.android.internal.os.ZygoteInit：main 函数。 main() com.android.internal.os.ZygoteInit//正真的 Zygote。 registerZygoteSocket();//登记 Listen 端口 startSystemServer(); 进入 Zygote 服务框架。 &emsp;&emsp;经过这几个步骤，Zygote就建立好了，利用Socket通讯，接收ActivityManangerService的请求，Fork应用程序。&emsp;&emsp;startSystemServer com.android.internal.os.ZygoteInit在Zygote上 fork了一个进程:com.android.server.SystemServer. 于是SystemServer (SystemServer.java）就建立了。Android的所有服务循环框架都是建SystemServer(SystemServer.java)上。在SystemServer.java中看不到循环结构，只是可以看到建立了init2的实现函数，建立了一大堆服务，并 AddService到service Manager。 Home启动&emsp;&emsp;在ServerThread@SystemServer.java后半段，我们可以看到系统在启动完所有的Android服务后，做了这样一些动作： 使用xxx.systemReady()通知各个服务，系统已经就绪。 特别对于ActivityManagerService.systemReady(回调) &emsp;&emsp;Widget.wallpaper,imm(输入法)等ready通知。 &emsp;&emsp;Home就是在ActivityManagerService.systemReady()通知的过程中建立的。下面是ActivityManagerService.systemReady()的伪代码： 1234systemReady()@ActivityManagerService.javaresumeTopActivityLocked()startHomeActivityLocked();//如果是第一个则启动HomeActivity。startActivityLocked（。。。）CATEGORY_HOME]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之源起]]></title>
    <url>%2F2019%2F08%2F14%2F0028-Android%E4%B9%8B%E6%BA%90%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Android（读音：英：[‘ændrɔɪd]，美：[ˈænˌdrɔɪd]），常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。 Android的成立&emsp;&emsp;2003年10月，有“Android之父”之称的安迪·鲁宾（Andy Rubin）、利奇·米纳尔（Rich Miner）、尼克·席尔斯（Nick Sears）、克里斯·怀特（Chris White）在美国加利福尼亚州帕罗奥图共同成立了Android科技公司（Android Inc.），鲁宾把Android项目描述为“有极大的潜能以开发更智能的移动设备，以更了解其用家的位置及偏好。”该公司早期的方向是为数字相机开发先进的操作系统，此亦是2004年4月该公司向投资者介绍的基础。尽管Android科技公司的创始人和员工过去都具有各自的科技成就，但是Android科技公司的经营只显露出它在智能手机软件的方面，该公司随后认为相机市场不足以实现其目标，并且在5个月之后努力把Android转移到一款可跟Symbian及微软Windows Mobile互相媲美的手机操作系统。 Android的后续发展： 2005年7月11日Android Inc.被美国科技企业Google收购。 2007年11月，Google与84家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良Android，随后，Google以Apache免费开放源代码许可证的授权方式，发布了Android的源代码，开放源代码加速了Android普及，让生产商推出搭载Android的智能手机，Android后来更逐渐拓展到平板电脑及其他领域上。 2010年末数据显示，Andrioid超越称霸逾十年的诺基亚Symbian系统，成为全球第一大智能手机操作系统。 2013年6月最高曾有5.38亿台活跃的安卓设备；2013年6月最高曾有10亿台活跃的安卓设备 2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。 2018年8月6日，Android 9宣布发行。 Android命名由来&emsp;&emsp;Android一词最早出现于法国作家维利耶·德·利尔－阿达姆·利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃（L’Ève future）》中。他把外表像人的机器人取名为Android。 Android标志&emsp;&emsp;Android是一个全身绿色的机器人，半圆形的头部，有两支天线和空白的点作为眼睛。它的头部与身体之间有空白的区域，相似于一枚有平底的鸡蛋，两侧各有两个圆角矩形，作为它的双臂。Android的标志是由Ascender公司设计，颜色采用了PMS 376C和RGB中十六进制的#A4C639来绘制，这是Android操作系统的品牌象征。当中的文字使用了Ascender公司专门制作的称之为“Google Droid”的字体有时候，它会以纯文字的标志展示。 Android机器人 Android字标 Android系统架构&emsp;&emsp;Android系统架构包含以下组件： 应用框架。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息，因此如果作为硬件开发者，需要非常了解其中的 API。 Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。 系统服务。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。 应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。 硬件抽象层 (HAL)。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。 Linux 内核。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含几个特殊的补充功能，例如：Low Memory Killer（一种内存管理系统，可更主动地保留内存）、唤醒锁定（一种 PowerManager 系统服务）、Binder IPC 驱动程序以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。 Android堆栈&emsp;&emsp;Android 是一个针对多种不同设备类型打造的开放源代码软件堆栈。Android 的主要目的是为运营商、OEM 和开发者打造一个开放的软件平台，使他们能够将创新理念变为现实，并推出能够卓有成效地改善用户移动体验的真实产品。&emsp;&emsp;Android 平台的设计可确保不存在一个集中瓶颈，即没有任何行业参与者可一手限制或控制其他参与者的创新。这样，我们不但可以打造功能完善的高品质消费类产品，而且可以完全开放源代码，供第三方自由定制和移植。 Android更新时间表 名称 版本号 发行日期 API等级 安全性更新状态 Android 1.0 1.0 2008年9月23日 1 不支持 Android Petit Four 1.1 2009年2月9日 2 不支持 Android Cupcake 1.5 2009年4月27日 3 不支持 Android Donut 1.6 2009年9月15日 4 不支持 Android Eclair 2.0 – 2.1 2009年10月26日 5 – 7 不支持 Android Froyo 2.2 – 2.2.3 2010年5月20日 8 不支持 Android Gingerbread 2.3 – 2.3.7 2010年12月6日 9 – 10 不支持 Android Honeycomb 3.0 – 3.2.6 2011年2月22日 11 – 13 不支持 Android Ice Cream Sandwich 4.0 – 4.0.4 2011年10月18日 14 – 15 不支持 Android Jelly Bean 4.1 – 4.3.1 2012年7月9日 16 – 18 不支持 Android KitKat 4.4 – 4.4.4 2013年10月31日 19 – 20 不支持 Android Lollipop 5.0 – 5.1.1 2014年11月12日 21 – 22 不支持 Android Marshmallow 6.0 – 6.0.1 2015年10月5日 23 支持 Android Nougat 7.0 – 7.1.2 2016年8月22日 24 – 25 支持 Android Oreo 8.0 – 8.1 2017年8月21日 26 – 27 支持 Android Pie 9.0.0 2018年8月6日 28 支持 Android Q 未知 2019年3月13日 29 测试中 参考资源 wikiAndroid社区 table th:nth-of-type(1){ width: 35%; } table th:nth-of-type(2){ width: 16%; } table th:nth-of-type(3){ width: 25%; } table th:nth-of-type(4){ width: 16%; } table th:nth-of-type(5){ width: 18%; }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言操作符优先级]]></title>
    <url>%2F2019%2F08%2F09%2F0027-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;表达式的求值顺序是由3个因素决定的：操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序。两个相邻的操作符哪个先执行取决于他们的优先级，如果两者的由优先级相同，那么它们的执行顺序由他们的结核性决定。 C语言操作符的优先级表 5.1 列出了C语言中每个操作符的所有属性： 操作符 描述 用法示例 结果类型 结合性 控制求值顺序? () 聚组 (表达式) 与表达式同 N/A 否 () 函数调用 rexp(rexp,…,rexp) rexp L-R 否 [] 下标引用 rexp[rexp] lexp L-R 否 . 访问结构成员 lexp.member_name lexp L-R 否 -&gt; 访问结构指针成员 rexp-&gt;member_name lexp L-R 否 ++ 后缀自增 lexp++ rexp L-R 否 &#45;&#45; 后缀自减 lexp– rexp L-R 否 ! 逻辑反 !rexp rexp R-L 否 ~ 按位取反 ~rexp rexp R-L 否 + 单目，表示正值 +rexp rexp R-L 否 &#45; 单目，表示负值 -rexp rexp R-L 否 ++ 前缀自增 ++lexp rexp R-L 否 &#45;&#45; 前缀自减 –lexp rexp R-L 否 * 间接访问 *rexp rexp R-L 否 &amp; 取地址 &amp;lexp rexp R-L 否 sizeof 取其长度 sizeof rexp; sizeof(类型) rexp R-L 否 (类型) 类型转换 (类型)rexp rexp R-L 否 * 乘法 rexp*rexp rexp L-R 否 / 除法 rexp/rexp rexp L-R 否 % 整数取余 rexp%rexp rexp L-R 否 + 加法 rexp+rexp rexp L-R 否 &#45; 减法 rexp&#45;rexp rexp L-R 否 &lt;&lt; 左移位 rexp&#60;&#60;rexp rexp L-R 否 &gt;&gt; 右移位 rexp&gt;&gt;rexp rexp L-R 否 &gt; 大于 rexp&gt;rexp rexp L-R 否 &gt;= 大于等于 rexp&gt;=rexp rexp L-R 否 &lt; 小于 rexp&#60;rexp rexp L-R 否 &lt;= 小于等于 rexp&#60;=rexp rexp L-R 否 == 等于 rexp==rexp rexp L-R 否 != 不等于 rexp!=rexp rexp L-R 否 &amp; 位于 rexp&amp;rexp rexp L-R 否 ^ 位异或 rexp^rexp rexp L-R 否 &#124; 位或 rexp&#124;rexp rexp L-R 否 &amp;&amp; 逻辑与 rexp&amp;&amp;rexp rexp L-R 否 &#124;&#124; 逻辑或 rexpre&#124;&#124;rexp rexp L-R 是 ?: 条件操作符 rexp?rexp:rexp rexp N/A 是 = 赋值 lexp=rexp rexp R-L 否 += 以…加 lexp+=rexp rexp R-L 否 -= 以…减 lexp-=rexp rexp R-L 否 &#42;= 以…乘 lexp &#42;=rexp rexp R-L 否 /= 以…除 lexp/=rexp rexp R-L 否 %= 以…取模 lexp%=rexp rexp R-L 否 &lt;&lt;= 以…左移 lexp&lt;&lt;=rexp rexp R-L 否 &gt;&gt;= 以…右移 lexp&gt;&gt;=rexp rexp R-L 否 &amp;= 以…与 lexp&amp;=rexp rexp R-L 否 ^= 以…异或 lexp^=rexp rexp R-L 否 &#124;= 以…或 lexp&#124;=rexp rexp R-L 否 , 逗号 rexp,rexp rexp L-R 是 附：Markdown特殊字符转义&emsp;&emsp;虽然hexo的语法是Markdown格式的，但是在书写时对于特殊字符使用“\“转义是不严谨的做法，最好的方式是使用特殊字符对应的编码，对应如下： 123456789101112131415161718192021222324 &amp;emsp; --&gt; 空格(Space)! &amp;#33; --&gt; 惊叹号 (Exclamation mark) ” &amp;#34; &amp;quot; --&gt; 双引号 (Quotation mark)# &amp;#35; --&gt; 数字标志 (Number sign)$ &amp;#36; --&gt; 美元标志(Dollar sign)% &amp;#37; --&gt; 百分号(Percent sign)&amp; &amp;#38; &amp;amp; --&gt; 和号(Ampersand)| &amp;#124; --&gt; 竖线(Vertical bar) ‘ &amp;#39; --&gt; 单引号(Apostrophe) ( &amp;#40; --&gt; 小括号左边部分(Left parenthesis) ) &amp;#41; --&gt; 小括号右边部分(Right parenthesis) + &amp;#43; --&gt; 加号(Plus sign)- &amp;#45; &amp;minus; --&gt; 减号(Minus sign)* &amp;#42; --&gt; 星号(Asterisk)\ &amp;#92; --&gt; 反斜杠(Reverse solidus (backslash)) &lt; &amp;#60; &amp;lt; --&gt; 小于号(Less than) = &amp;#61; --&gt; 等于符号(Equals sign)&gt; &amp;#62; --&gt; 大于号(Greater than)? &amp;#63; --&gt; 问号(Question mark)@ &amp;#64; --&gt; 在标志(Commercial at)[ &amp;#91; --&gt; 中括号左边部分(Left square bracket) ] &amp;#93; --&gt; 中括号右边部分(Right square bracket)&#123; &amp;#123; --&gt; 大括号左边部分(Left curly brace) &#125; &amp;#125; --&gt; 大括号右边部分(Right curly brace) table th:nth-of-type(1){ width: 10%; } table th:nth-of-type(2){ width: 20%; } table th:nth-of-type(3){ width: 30%; } table th:nth-of-type(4){ width: 15%; } table th:nth-of-type(5){ width: 10%; } table th:nth-of-type(6){ width: 15%; }]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Repo入门]]></title>
    <url>%2F2019%2F08%2F08%2F0026-repo%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 前言&emsp;&emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自动化部分开发工作流程。但是Repo并不是要取代Git，只是为了让Git更容易使用。repo命令只是一个可执行的Python脚本，我们可以将其放在路径中的任何位置。 Repo、Git、Gerrit三者的区别1.1 Git&emsp;&emsp;Git 是一个开放源代码的版本控制系统，专用于处理分布在多个代码库上的大型项目。在 Android 环境中，我们会使用 Git 执行本地操作，例如建立本地分支、提交、查看更改、修改。 1.2 Repo&emsp;&emsp;Repo 是我们以 Git 为基础构建的代码库管理工具。Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到我们的修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让我们在 Android 环境中更轻松地使用 Git。Repo 命令是一段可执行的 Python 脚本，我们可以将其放在路径中的任何位置。使用 Android 源代码文件时，就可以使用 Repo 执行跨网络操作。例如，可以借助单个 Repo 命令，将文件从多个代码库下载到本地工作目录。 1.3 Gerrit&emsp;&emsp;Gerrit 是一个基于网页的代码审核系统，适用于使用 Git 的项目。Gerrit 允许所有授权用户提交更改（如果通过代码审核，这些更改会自动纳入项目中），以此鼓励其他人更集中地使用 Git。此外，Gerrit 可以在浏览器中并排显示更改，并支持代码内注释，使得审核工作变得更轻松！ 2. Repo的工作原理&emsp;&emsp;repo需要关注当前git库的数量、名称、路径等，有了这些基本信息，才能对这些git库进行操作。通过集中维护所有git库的清单，repo可以方便的从清单中获取git库的信息。 这份清单会随着版本演进升级而产生变化，同时也有一些本地的修改定制需求，所以，repo是通过一个git库来管理项目的清单文件的，这个git库名字叫manifests。&emsp;&emsp;当打开repo这个可执行的python脚本后，发现代码量并不大(不超过1000行)，难道仅这一个脚本就完成了AOSP数百个git库的管理吗？并非如此。 repo是一系列脚本的集合，这些脚本也是通过git库来维护的，这个git库名字叫repo。&emsp;&emsp;在客户端使用repo初始化一个项目时，就会从远程把manifests和repo这两个git库拷贝到本地，但这对于Android开发人员来说，又是近乎无形的(一般通过文件管理器，是无法看到这两个git库的)。 repo将自动化的管理信息都隐藏根目录的.repo子目录中。 3. 安装Repo创建目录并修改环境变量 12$ mkdir ~/bin$ PATH=~/bin:$PATH 3.1 下载repo12$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 3.3 获取帮助&emsp;&emsp;安装 Repo 后，运行以下命令可以找到最新文档（开头是包含所有命令的摘要） 1$ repo help 3.4 查询具体命令的帮助&emsp;&emsp;在 Repo 树中运行以下命令来获取有关某个命令的信息 1$ repo help &lt;COMMAND&gt; 3.5 查看Repo init 参数的说明和选项列表&emsp;&emsp;此命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 init。） 1$ repo help init 4. 初始化仓库&emsp;&emsp;初始化仓库命令： 1$ repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;] &emsp;&emsp;示范： 123$ mkdir MY_WORKING_DIRECTORY$ cd MY_WORKING_DIRECTORY$ repo init -u https://android.googlesource.com/platform/manifest &emsp;&emsp;这将在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。选项： -u：指定要从中检索清单代码库的网址。可以在 https://android.googlesource.com/platform/manifest 中找到常见清单 -m：在代码库中选择清单文件。如果未选择任何清单名称，则会默认选择 default.xml。 -b：指定修订版本，即特定的清单分支。 注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo/ 的父目录或相应父目录的子目录。 5. 拉取仓库12$ repo sync$ repo sync PROJECT0 PROJECT1 PROJECT2 ... 选项： -j ： 多任务，一般8核心可以开到16任务,过多会起反作用 -c： 只下载当前分支代码 -d： 让工程回退到manifest指定的版本 -f： 如果某个工程同步失败，继续同步 6. 修改仓库结构&emsp;&emsp;如果想修改repo的结构，应该在 .repo/manifests 文件夹里面修改 default.xml 文件，然后用git命令提交。default.xml 文件内容: 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;manifest&gt; &lt;remote name="shift" fetch="git://git.mygit.com/" /&gt; &lt;default revision="kk-shift" remote="shift" sync-j="1" /&gt; &lt;project path="packages/shift/VideoPlayer" name="platform/packages/shift/VideoPlayer" /&gt; &lt;include name="another_manifest.xml" /&gt;&lt;/manifest&gt; 该文件内容的理解，请移步 7. 理解repo init后生成的.repo目录结构&emsp;&emsp;当我们执行repo init命令之后会在当前目录下生成’.repo’目录： 12345678$ tree .repo -L 1.repo├── manifests├── manifests.git├── manifest.xml -&gt; manifests/default.xml├── project.list├── projects└── repo .repo目录理解： manifests：一个git库，包含default.xml文件，用于描述repo所管理的git库的信息 manifests.git：manifest这个git库的实体，manifest/.git目录下的所有文件都会链接到该目录 manifests/default.xml：工作树的主配置文件，一般不要编辑这个文件 projects/：每个git工程的 .git结构 manifest.xml：这是一个指向 .repo/manifests/ 目录中所选清单的符号链接 project.list：git库的所有仓库列表 repo/： 一个git库，包含repo运行的所有脚本 8. default.xml 文件解读 manifest&emsp;&emsp;这个是配置的顶层元素，即根标志 remote name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。 alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径 review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果 default设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。 remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了） revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch sync_j ： 在repo sync中默认并行的数目 sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容 sync_s ： 如果设置为true，则会同步git的子项目 manifest-server它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务，它要支持一下RPC方法： GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。 target参数来自环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT，组成$TARGET_PRODUCT-$TARGET_BUILD_VARIANT GetManifest(tag) ：返回指定tag的manifest project需要clone的单独git name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样 remote ：定义remote name，如果没有定义的话就用default中定义的remote name revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值 groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于 name:’name’ 和path:’path’组。例如，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载 sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。 sync_s ： 如果设置为true，则会同步git的子项目 upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间 annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量 include通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径) name ：另一个需要导入的manifest文件名字可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project remove-project&emsp;&emsp;从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义 9. Google提供的参考资源&emsp;&emsp;主页：https://gerrit.googlesource.com/git-repo/&emsp;&emsp;错误报告：https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo&emsp;&emsp;资料来源：https://gerrit.googlesource.com/git-repo/&emsp;&emsp;概述：https://source.android.com/source/developing.html&emsp;&emsp;文档：https://source.android.com/source/using-repo.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言显示数据处理进度条]]></title>
    <url>%2F2019%2F07%2F11%2F0025-C%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。&emsp;&emsp;我们见过比如使用git clone命令下载的时候显示的进度那样的效果，类似的还有很多，很多linux命令执行后一般都会有进度条显示，那么我们该怎样实现那样的效果呢？ 操作环境：linux；Linux+GCC 从C语言printf格式化控制台移动光标说起&emsp;&emsp;在Linux环境下，光标的移动、背景色和字体颜色的设置非常简单。如： 1printf("\033[47;31mhello world\033[5m"); &emsp;&emsp;47是字背景颜色, 31是字体的颜色, hello world是字符串. 后面的\033[5m是控制码。字背景颜色范围: 40–49 字颜色: 30–39。表2-1 字背景颜色及字颜色范围表 数值 背景颜色 数值 字颜色 40 黑 30 黑 41 红 31 红 42 绿 32 绿 43 黄 33 黄 44 蓝 34 蓝 45 紫 35 紫 46 深绿 36 深绿 47 白色 37 白色 表2-2 ANSI控制码表 ANSI控制码 作用 \033[0m 关闭所有属性 \033[1m 设置高亮度 \03[4m 下划线 \033[5m 闪烁 \033[7m 反显 \033[8m 消隐 \033[30m – \033[37m 设置前景色 \033[40m – \033[47m 设置背景色 \033[nA 光标上移n行 \03[nB 光标下移n行 \033[nC 光标右移n行 \033[nD 光标左移n行 \033[y;xH 设置光标位置 \033[2J 清屏 \033[K 清除从光标到行尾的内容 \033[s 保存光标位置 \033[u 恢复光标位置 \033[?25l 隐藏光标 \33[?25h 显示光标 实现显示进度条代码&emsp;&emsp;这个方法的优点是，由于每次打印显示之前都是先将光标移动到行首并将其后的所有输出内容清除，因此当控制台有其他字符输出时，也不会导致显示位置错乱。 123456789101112131415161718192021222324252627282930313233343536/*** @brief 在控制台打印显示进度条** @param[in] progress（进度百分比，取值为0~100）** @return i,本次显示进度条时所输出的字符个数*/int display_progress(int progress) &#123; int i = 0; /* 移动到行首并清除从当前光标到行尾的所有内容 */ printf("\r\033[k"); /* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */ for (i = 0; i &lt; progress; i++) &#123; printf("="); &#125; printf("&gt;&gt;"); /* 输出空格截止到第104的位置 */ for (i += 2; i &lt; 104; i++) &#123; printf(" "); &#125; /* 输出进度条百分比 */ i = i + printf("[%d%%]", progress); /* 系统必要的输出策略，刷新输出缓冲区才能显示 */ fflush(stdout); /* 返回本次显示进度条时所输出的字符个数 */ return i; &#125; 使用’\b’退格字符实现&emsp;&emsp;在C语言中，提供了转义字符’\b’来进行输出后的退格操作。在编程过程中，我们有时候需要进行退格操作。但是，我在以前使用的过程中，发现我使用语句printf(“abc\b”);之后，在输出结果中还是显示的abc并不是我希望得到的ab。 用法及原理&emsp;&emsp;在用’\b’进行退格操作的时候，实际上，每次使用’\b’字符之后，控制台的输出光标会后退一个字符的位置，但是并没有将相应的字符删除。所以，我们需要在’\b’字符后面紧跟一个字符，用来代替需要删除的字符。如果后面没有需要输出的字符，可以用至少一个空格跟在’\b’后面，用来替换需要删除的字符。&emsp;&emsp;该’\b’退格字符，也可以多个连用，以实现对多个字符的删除操作，但是需要注意的是，想要删除几个字符就要使用至少几个’\b’，对应的也需要有相等数量的字符用来替换待删除的字符。 示例对单个字符进行退格操作（删除单个字符）123printf("abc\bv"); //此处的输出结果是abv，后面的'v'就是用来替换'c'的字符printf("abc\b"); //此处的输出结果是abc，可以看出虽然用了'\b'退格，但是并没有提供相应的用来替换最后一个字符'c'的字符printf("abc\b "); //此处的输出结果是ab，因为在'\b'后面，跟了一个空格' '来替换了字符'c' 对多个字符进行退格操作（删除字符串）12printf("phrase\b\b\b\b.new"); //此处的输出结果是ph.new，后面的字符串".new"是用来替换"rase"的printf("phrase\b\b\b\b newString"); //此处输出的结果是ph newString，中间用了两个空格来代替字符串"ra"，紧接着用了两个字符"ne"来代替字符串"se"，再后面多出的"wString"字符串，则原样输出。 实现显示进度条代码&emsp;&emsp;这个方法有个致命的缺点，当控制台有其他字符输出的时候会打乱现有的显示位置，导致显示位置错乱。 1234567891011121314151617181920212223242526272829303132333435363738/*** @brief 在控制台打印显示进度条** @param[in] progress 进度百分比，取值为0~100* @param[in] last_char_count 上一次显示进度条时所用到的字符个数** @return i,目前进度条打印的字符个数**/int display_progress(int progress, int last_char_count) &#123; int i = 0; /*把上次显示的进度条信息全部清空*/ for (i = 0; i &lt; last_char_count; i++) &#123; printf("\b"); &#125; /* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */ for (i = 0; i &lt; progress; i++) &#123; printf("="); &#125; printf("&gt;&gt;"); /* 输出空格截止到第104的位置 */ for (i += 2; i &lt; 104; i++) &#123; printf(" "); &#125; /* 输出进度条百分比 */ i = i + printf("[%d%%]", progress); /* 系统必要的输出策略，刷新输出缓冲区才能显示 */ fflush(stdout); /*返回本次显示进度条时所输出的字符个数*/ return i; &#125; 实现效果1===================================================================================================&gt;&gt; [99%]]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用C语言对IP地址排序]]></title>
    <url>%2F2019%2F06%2F21%2F0024-%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AF%B9IP%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。&emsp;&emsp;程序运行环境： 12- windows 10 64-bit- Visual Studio 2015 解决思路&emsp;&emsp;假设IP地址格式为：a.b.c.d&emsp;&emsp;由观察可知：每个数字的范围在0~255之间，灭个字段都是模256的余数，则可以将所有字段按照所在位置乘以256的对应次幂。&emsp;&emsp;由观察可得公式：(a256^3) + (b256^2) + (c256^1) + (d256^0)这样我们就可以得到一个长整数。每个IP地址对应一个长整数，只要将IP地址与对应求得的长整数用链表保存起来。这样我们就将问题转换为基数排序，结果的排序即为索求排序，只需用指针或者下标等方法将两者对应。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231// Sort_ip_ddresses.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAX_LINE 128typedef struct ipAddr &#123; char *ip_Str; // 数据域 long long ip_Int; struct ipAddr *next; // 指针域&#125;link;/* 创建链表 */link *creatLink()&#123; /* 创建头结点 */ link * p = (link *)malloc(sizeof(link)); p-&gt;next = NULL; return p;&#125;/* 往链表增加项*/link * addLink(link * head, char *str, long long value)&#123; link *tempLink = head; link *targeLink = (link *)malloc(sizeof(link)); if (targeLink == NULL) &#123; printf("插入结点前申请内存失败！\n"); return NULL; &#125; else &#123; targeLink-&gt;ip_Int = value; targeLink-&gt;ip_Str = str; targeLink-&gt;next = NULL; &#125; while (tempLink-&gt;next != NULL) &#123; tempLink = tempLink-&gt;next; &#125; tempLink-&gt;next = targeLink; return tempLink;&#125;void swapStr(char *str1, char *str2)&#123; char *tempStr; tempStr = (char *)malloc(16); memset(tempStr, 0, 16); strcpy(tempStr, str1); strcpy(str1, str2); strcpy(str2, tempStr); free(tempStr);&#125;void swapValue(long long *value1, long long *value2)&#123; long long tempValue = *value1; *value1 = *value2; *value2 = tempValue;&#125;/* 排序链表【冒泡排序】*/link *sortTheLinkedList(link *head)&#123; link *tempLink = NULL; bool canSort = true; if (head == NULL || head-&gt;next == NULL) return head; while (tempLink != head-&gt;next &amp;&amp; canSort) &#123; link *q = head; canSort = false; q = q-&gt;next; for (; q-&gt;next &amp;&amp; q-&gt;next != q; q = q-&gt;next) &#123; //if ((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) &gt; 0)) //|| (((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) == 0)) &amp;&amp; (strlen(q-&gt;ip_Str) &gt; strlen(q-&gt;next-&gt;ip_Str))) if (q-&gt;ip_Int &gt; q-&gt;next-&gt;ip_Int) &#123; swapStr(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str); swapValue(&amp;q-&gt;ip_Int, &amp;q-&gt;next-&gt;ip_Int); canSort = true; &#125; &#125; tempLink = q; &#125; return head;&#125;/* 遍历并输出链表内容*/bool showLinkInf(link *head)&#123; int count = 0; link *tempLink = head; if (tempLink == NULL) &#123; return false; &#125; while (tempLink-&gt;next != NULL) &#123; count++; tempLink = tempLink-&gt;next; printf("IP地址：%s，\t大小：%lld\n", tempLink-&gt;ip_Str, tempLink-&gt;ip_Int); &#125; printf("链表长度: %d\n\n", count); return true;&#125;/* 清空链表*/void emptyList(link *head)&#123; link *tempLink; while (head != NULL) &#123; tempLink = head; head = head-&gt;next; free(tempLink); &#125;&#125;/* 复制字符串*/char * strCpy(char *str, int len)&#123; char *tempStr2 = (char *)malloc(sizeof(char)*16); memset(tempStr2, 0, 16); strncpy(tempStr2, str, len); return tempStr2;&#125;/* 假设IP地址格式为：a.b.c.d 由观察可知：每个数字的范围在0~255之间，则可以将其看成一个四位的256进制数。 由观察可得公式：(a*256^3) + (b*256^2) + (c*256^1) + (d*256^0)*/long long strToInt(char *str, int n)&#123; char *tokStr, *tempStr; long long calcValue = 0; long long strTIntVal; tempStr = (char *)malloc(sizeof(char)*strlen(str)); strcpy(tempStr, str); tokStr = strtok(tempStr, "."); while (tokStr) &#123; strTIntVal = (long long)atoi(tokStr); calcValue = calcValue * 256 + strTIntVal; tokStr = strtok(NULL, "."); &#125; return calcValue;&#125;void strTok(link * head, char *str)&#123; char *tokStr, *tempStr; long long tempLongData; tempStr = (char *)malloc(sizeof(char)*strlen(str)); strcpy(tempStr, str); /* 分割字符串 */ tokStr = strtok(tempStr, "\n"); while (tokStr) &#123; tempLongData = strToInt(tokStr, strlen(tokStr)); //tempStr = strCpy(tokStr, strlen(tokStr)); addLink(head, tokStr, tempLongData); // 加入链表 tokStr = strtok(NULL, "\n"); &#125;&#125;int main()&#123; char *buf; FILE *fp; int len, tempLen; int linkCount = 0; long long tempLongData; link * ipLink = creatLink(); buf = (char *)malloc(sizeof(char)*MAX_LINE); fp = fopen("ipAddress.txt", "r"); if (fp == NULL) &#123; printf("打开文件失败！\n"); free(buf); free(ipLink); return 0; &#125; while (fgets(buf, MAX_LINE, fp) != NULL) &#123; len = strlen(buf); tempLen = len; strTok(ipLink, buf); &#125; sortTheLinkedList(ipLink); if (!showLinkInf(ipLink)) printf("链表为空，遍历失败！\n"); emptyList(ipLink); fclose(fp); return 0;&#125; 需排序的IP地址文本12345678910111213141516171819202122232425262728293031192.168.1.1 192.168.2.15 192.168.1.1 192.168.1.2 192.168.2.3 192.168.1.4 192.168.3.3 192.168.1.6 192.168.1.7 192.168.1.9 192.168.1.3 192.168.1.21 192.168.1.5 192.168.3.4 192.168.1.8 192.168.3.5 192.168.2.2 192.168.1.2 182.168.2.3 172.168.1.4 162.168.3.3 152.168.1.6 142.168.1.7 132.168.1.9 122.168.1.3 112.168.1.21 102.168.1.5 92.168.3.4 82.168.1.8 72.168.3.5 62.168.2.2 程序运行结果123456789101112131415161718192021222324252627282930IP地址：102.168.1.5 ， 大小：1722286341IP地址：112.168.1.21 ， 大小：1890058517IP地址：122.168.1.3 ， 大小：2057830659IP地址：132.168.1.9 ， 大小：2225602825IP地址：142.168.1.7 ， 大小：2393374983IP地址：152.168.1.6 ， 大小：2561147142IP地址：162.168.3.3 ， 大小：2728919811IP地址：172.168.1.4 ， 大小：2896691460IP地址：182.168.2.3 ， 大小：3064463875IP地址：192.168.1.1 ， 大小：3232235777IP地址：192.168.1.1 ， 大小：3232235777IP地址：192.168.1.2 ， 大小：3232235778IP地址：192.168.1.2 ， 大小：3232235778IP地址：192.168.1.3 ， 大小：3232235779IP地址：192.168.1.4 ， 大小：3232235780IP地址：192.168.1.5 ， 大小：3232235781IP地址：192.168.1.6 ， 大小：3232235782IP地址：192.168.1.7 ， 大小：3232235783IP地址：192.168.1.8 ， 大小：3232235784IP地址：192.168.1.9 ， 大小：3232235785IP地址：192.168.1.21 ， 大小：3232235797IP地址：192.168.2.2 ， 大小：3232236034IP地址：192.168.2.3 ， 大小：3232236035IP地址：192.168.2.15 ， 大小：3232236047IP地址：192.168.3.3 ， 大小：3232236291IP地址：192.168.3.4 ， 大小：3232236292IP地址：192.168.3.5 ， 大小：3232236293链表长度: 31请按任意键继续. . .]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++,排序,链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C标准库--string.h]]></title>
    <url>%2F2019%2F06%2F13%2F0023-C%E6%A0%87%E5%87%86%E5%BA%93-string-h%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、strcmp、strcpy等等，更详细的可以到include文件夹里面查看该文件。 库变量&emsp;&emsp;头文件 string.h 中定义的变量类型： 变量 说明 size_t 这是无符号整数类型，它是 sizeof 关键字的结果 库宏头文件 string.h 中定义的宏： 宏 说明 NULL 这个宏是一个空指针常量的值 库函数头文件 string.h 中定义的函数，有下表列出的22种用法。 序号 函数&amp;描述 1 void *memchr(const void *str, int c, size_t n)在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。 2 int memcmp(const void *str1, const void *str2, size_t n)把 str1 和 str2 的前 n 个字节进行比较。 3 void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。 4 void *memmove(void *dest, const void *src, size_t n)另一个用于从 src 复制 n 个字符到 dest 的函数。 5 void *memset(void *str, int c, size_t n)复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 6 char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 7 char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。 8 char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。 9 int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 10 int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。 11 int strcoll(const char *str1, const char *str2)把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。 12 char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。 13 char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。 14 size_t strcspn(const char *str1, const char *str2)检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。 15 char *strerror(int errnum)从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。 16 size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。 17 char *strpbrk(const char *str1, const char *str2)检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。 18 char *strrchr(const char *str, int c)在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。 19 size_t strspn(const char *str1, const char *str2)检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。 20 char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。 21 char *strtok(char *str, const char *delim)分解字符串 str 为一组字符串，delim 为分隔符。 22 size_t strxfrm(char *dest, const char *src, size_t n)根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。 更详细的内容请查阅include文件夹中的文件。 table th:nth-of-type(1){ width: 8%; } table th:nth-of-type(2){ width: 92%; }]]></content>
      <categories>
        <category>C/++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程之进程调度]]></title>
    <url>%2F2019%2F06%2F04%2F0022-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。为了满足这些目标，进程调度器（process scheduler）选择一个可用进程（可能从多个可用进程集合中）到CPU上执行。单处理器系统不会具有多个正在运行的进程。如果有多个进程，那么余下的需要等待CPU空闲并能重新调度。 调度队列&emsp;&emsp;进程在进入系统时，会被加到作业队列（job queue），这个队列包括系统内的所有进程。驻留在内存中的、就绪的、等待运行的进程保存在就绪队列（ready queue）上。这个队列通常用链表实现；其头节点有两个指针，用于指向链表的第一个和最后一个PCB块，每个PCB还包括一个指针，指向就绪队列的下一个PCB。&emsp;&emsp;系统还有其他队列。当一个进程被分配了CPU后，它执行一段时间，最终退出，或被中断，或等待特定事件发生，如I/O请求的完成。我们假设进程向一个共享设备，如磁盘，发出I/O请求。由于系统具有许多进程，磁盘可能忙于其他进程的I/O请求，因此该进程可能需要等待磁盘空闲。等待特定I/O设备的进程列表，称为设备队列（device queue）。每个设备都有自己的设备队列。 图2-1 就绪队列和各种IO设备队列 &emsp;&emsp;进程调度通常用队列图（queueing diagram）来表示，如图1-2所示。每个举行框代表一个队列；这里具有两种队列：就绪队列和设备队列。圆圈表示服务队列的资源；箭头表示系统内的进程流向。 图2-2 表示进程调度的队列 &emsp;&emsp;最初，新进程被加载到就绪队列；之后它便在就绪队列中一直等待，知道被选中执行或被分配（dispatched）。当该进程分配到CPU并执行时，以下事件可能发生： * 进程可能发出I/O请求，并被放到I/O队列。 * 进程可能创建一个新的子进程，并等待其终止。 * 进程可能由于中断而被强制释放CPU，并被放回到就绪队列。 对于前面两种情况，进程最终从等待状态切换到就绪状态，并放回到就绪队列。进程重复这一循环直到终止；然后它会从所有队列中删除，其PCB和资源也被释放。 调度程序&emsp;&emsp;进程在整个生命周期中，会在葛总调度队列之间迁移。操作系统为了调度必须按一定方式从这些队列中选择进程。进程选择通过适当调度器或调度程序(scheduler)来执行。&emsp;&emsp;通常，对于批处理系统（又名批处理操作系统），提交的进程多于可以立即执行的。这些进程会被保存到大容量存储设备(通常为磁盘)的缓冲池，以便以后执行。长期调度程序(long-term scheduler)或作业调度程序(job scheduler)从该池中选择进程，加到内存，以便执行。短期调度程序（short-term scheduler）或CPU调度程序(CPU scheduler)从准备执行的进程中选择进程，并分配CPU。&emsp;&emsp;这两种调度程序的主要区别是执行频率。短期调度程序必须经常为CPU选择新的进程。进程可能执行几毫秒(ms)，就会等待I/0请求。通常，短期调度程序每100ms至少执行一次。由于执行之间的时间短，短期调度程序必须快速.如果花费10ms来确定执行一个运行一个100ms的进程，那么 10/(100+10)=9% 的CPU时间会用在(或浪费在)调度工作上。&emsp;&emsp;长期调度程序执行并不频繁；在新进程的创建之间，可能有几分钟间隔。长期调度程序控制多道程序程度(degree of multiprogramming)(内存中的进程数量)。如果多道程序程度稳定，那么创建进程的平均每度必须等于进程离开系统的平均速度。因此，只有在进程离开系统时，才需要长期调度程序的调度。由于每次执行之间的更长时间间隔，长期调度程序可以负担得起更多时间，以便决定应该选择执行哪个进程。&emsp;&emsp;重要的是，长期调度程序进行认真选择。通常，大多数进程可分为：I/0为主或CPU为主。I/0密集型进程(I/O-bound process)，执行I/0比执行计算需要花费更多时间。相反，CPU密集型进程(CPU-bound process)很少产生I/O请求，而是将更多时间用于执行计算。重要的是，长期调度程序应该选择I/O密集型和CPU密集型的合理进程组合。 如果所有进程都是I/O密集型的，那么就绪队列几乎总是为空，从而短期调度程序没有什么可做。 如果所有进程都是CPU密集型的，那么I/0等待队列几乎总是为空，从而设备没有得到使用，因而系统会不平衡。为了使得性能最佳，系统需要I/O密集型和CPU密集型的进程合理组合。 &emsp;&emsp;有的系统，可能没有或极少采用长期调度程序。例如，UNIX或微软Windows的分时系统通常没有长期调度程序，只是简单将所有新进程放于内存，以供短期调度程序使用。这些系统的稳定性取决于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么有的用户就会退出。&emsp;&emsp;有的操作系统如分时系统，可能引人一个额外的中期调度程序(medium-term scheduler)。中期调度程序的核心思想是可将进程从内存(或从CPU竞争)中移出，从而降低多道程序程度。之后，进程可被重新调人内存，并从中断处继续执行。这种方案称为交换（swap）。通过中期调度，进程可换出（swap out），并在后来可换入（swap in）。为了改善进程组合，或者由于内存需求改变导致过渡使用内存从而需要释放内存，就有必要使用交换。 图3-1 添加中级进程调度到队列 上下文切换&emsp;&emsp;中断导致CPU从执行当前任务改变到执行内核程序。这种操作在通用系统中经常发生。当中断发生时，系统需要保存当前运行在CPU上的进程的上下文，以便在处理后能够恢复上下文，即先挂起进程，在恢复进程。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等。通常，通过执行状态保存（state save），保存CPU当前状态（包括系统模式和用户模式）；之后，装填回复（state restore）重新开始运行。&emsp;&emsp;切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称上下文切换(context swiitch)。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。上下文切换的时间是纯粹的开销，因为在切换时系统并没有做任何有用工作。上下文切换的速度因机器不同而有所不同，它依赖于内存速度、必须复制的寄存器数量、是否有特殊指令(如加载或存储所有寄存器的单个指令)。典型速度为几毫秒。&emsp;&emsp;上下文切换的时间与硬件支持密切相关。例如，有的处理器(如Sun U1traspARC)提供了多个寄存器组，上下文切换只需简单改变当前寄存器组的指针。当然，如果活动进程数量超过寄存器的组数，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的就越多。高级的内存管理技术在每次上下文切换时，所需切换的数据会更多。例如，在使用下一个进程的地址空间之前，需要保存当前进程的地址空间。如何保存地址空间，需要做什么才能保存等，取决于操作系统的内存管理方法。 总结&emsp;&emsp;进程，当不执行时，位于某个等待队列。操作系统有两种主要队列：I/O请求队列和就绪队列。就绪队列包括所有准备执行并等待CPU的进程，每个进程都用PCB来表示。&emsp;&emsp;操作系统应从各个调度队列中选择进程。长期调度（用于作业）选择进程以便竞争CPU。通常长期调度充分考虑资源分配，尤其是内存管理。短期调度从就绪队列中选择进程。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程之基础概念]]></title>
    <url>%2F2019%2F06%2F03%2F0021-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。这些资源在创建进程或执行进程时得以分配。&emsp;&emsp;进程是大多数系统的工作单元。这种操作系统包含一组进程：操作系统进程执行系统代码，而用户进程执行用户代码。所有这些进程可以并发执行。&emsp;&emsp;操作系统负责进程和线程管理的多个方面：用户进程与系统进程的创建与删除，进程调度，用于进程同步、进程通信与进程死锁处理的机制等。 进程概念&emsp;&emsp;一个程序文件（program），只是一堆待执行的代码和部分待处理的数据，他们只有被加载到内存中，然后让CPU逐条执行其代码，并根据代码做出相应的动作，才能形成一个真正“活动”、动态的进程（process），因此进程时一个动态变化的过程，是一出有始有终的戏，而程序文件只是这一系列动作的原始蓝本，是一个静态的剧本。 图2-1 进程的内存结构 &emsp;&emsp;进程是执行的程序。进程不只是程序代码，进程代码有时称为“文本段（text section）”（或“代码段（code section）”）。 &emsp;&emsp;进程还包括： * 进程堆栈（stack）：包括临时数据，如函数参数、返回地址和局部变量。 * 数据段（data section）：包括全局变量 * 堆（heap）：可能包括堆，这是在进程运行时动态分配的内存。 > 进程还包括当前活动，如程序计数器（program）的值和处理器寄存器的内容等。 进程的状态&emsp;&emsp;进程在执行时会改变状态。进程的状态，部分取决于进程的当前活动。每个进程都有可能处于以下状态的某种状态： 新的（new）：进程正在创建； 运行（running）：指令正在执行； 等待（waiting）：进程正在等待发生某个时间（如I/O完成或受到信号）； 就绪（ready）：进程等待分配处理器； 终止（terminated）：进程已经完成执行。 图3-1 进程状态图 > 一次只有一个进程可在处理器上运行（running）；但是可多个进程处于就绪（ready）或者等待（waiting）状态。 程序与进程的关系&emsp;&emsp;程序本身不是进程。程序是被动（passive）实体，如存储在磁盘上包含一系列指令的文件（我们常称之为“可执行文件”（executable file））。相反，进程是活动（active）实体，具有一个程序计数器用于表示可执行命令和一组相关资源。当一个可执行文件被加载到内存时，这个程序就成为进程。 加载可执行文件通常由两种方法：双击一个代表可执行文件的图标或在命令行上输入可执行文件的名称（如prog.exe或a.out）。 图4-1 程序与进程的关系 &emsp;&emsp;虽然多个进程可以与同一个程序相关联，但是实际上每个都是单独的执行序列。比如，多个用户可以运行电子邮件的不同副本，或者同意用户可以调用Web浏览器程序的多个副本。每个副本（进程）都是单独运行的；虽然文本段相同，但是数据、堆、及堆栈却不同。进程在运行时也经常会生成许多进程（子进程）。 # 进程控制块 &emsp;&emsp;操作系统内的每个进程表示，都采用进程控制块表示（Process Control Block），也称任务控制块（task control block）。当可执行程序被进行时，内核中实际上产生了一个叫"task_struct{}"的结构体来表示这个进程，进程是一个“活动的实体”，这个活动的实体从一开始诞生就需要各种各样的资源以便于生存下去，而这些信息都被记录在"task_struct"结构体之中，这个结构体被常常称之为进程控制块（PCB，即Process Control Block）。 进程控制块包括： * 进程状态：状态可以包括由新的、就绪、运行、等待、停止等。 * 程序计数器：计数器表示进程将要执行的下个指令的地址。 * CPU寄存器：根据计算机体系的不同寄存器的类型和数量也会不同。他们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件吗信息寄存器。在发生中断时，这些状态信息与程序计数器一起需要保存，一边进程以后能正确地继续执行。 * CPU调度信息：这类信息包括进程优先级、调度队列地指针和气压调度参数。 * 内存管理信息：根据操作系统使用的内核系统，这类信息可以包括及地址和界限寄存器的值、页表或段表。 * 记账信息：这类信息包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。 I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开文件列表等。 &emsp;&emsp;简而言之，PCB简单地作为这些信息的仓库，这些信息也会随着进程的不同而不同。 图5-1 进程控制块 图5-2 进程间的CPU切换 Linux的进程表示&emsp;&emsp;Linux操作系统的进程控制块采用C语言结构体 task_struct 来表示，它位于Linux内核源代码目录内的头文件&lt;linux/sched.h&gt;。这个结构体包含用于表示进程的所有必要信息，包括进程的状态、调度和内存管理信息、打开文件列表、指向父进程的指针及指向子进程和兄弟进程列表的指针等。（父进程（parent process）为创建他的进程，子进程（child process）为它本身创建的进程，兄弟进程（sibling process）为具有同一父进程的进程。）这些成员包括： 1234567pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */struct task struct *parent; /* this process’s parent */ struct list head children; /* this process’s children */ struct files struct *files; /* list of open files */ struct mm struct *mm; /* address space of this process */ &emsp;&emsp;例如，进程状态是由这个结构的成员 long state 来表示的。在Linux内核中，所有活动进程的表示都采用task_struct 的双向链表。内核采用一个指针即 current，用于指向当前系统正在执行的进车. 图6-1 task_struct双向链表 Linux的进程表示&emsp;&emsp;下面举例说明，内核如何修改某个特定进程的 task_struct 的成员，假设系统需要将当前运行状态改成值 new_state。如果current 为指向当前运行进程的指针，那么可以这样改变状态： 1current-&gt;state = new_state; Linux内核代码纷繁复杂，千万头绪，这个结构体是系统进程在执行过程中所有设计的方方面面的缩影，因此以这个所谓的进程控制块（PCB）为切入点，是研究内核的一个很好的窗口。 总结&emsp;&emsp;进程是可执行的程序。随着进程的执行，它会改变状态。&emsp;&emsp;程序本身不是进程。程序只是被动实体，进程是活动实体，当一个可执行文件被加载到内存时，这个程序就成为进程。进程状态是由进程当前活动定义的。&emsp;&emsp;每个进程都可以处于如下状态的某一种：新的、就绪、运行、等待或终止。&emsp;&emsp;在操作系统中，每个进程通过它的进程控制块（PCB）来表示。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Makefile及典型的Makefile示例]]></title>
    <url>%2F2019%2F04%2F27%2F0020-%E7%90%86%E8%A7%A3Makefile%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%9A%84Makefile%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考GNU Make Manual Makefile到底是什么&emsp;&emsp;一个正式的软件工程中源文件可能数不胜数，并且源文件按类型、功能、模块等分别放在不同的目录下，在我们使用使用keil, Visual Studio, avr等工具开发程序时点点鼠标就可以编译了，但是对于其中的内部机制是什么？是怎么组织管理程序的？怎么决定编译哪一个文件？我们一概不知，因为IDE帮我们屏蔽了这方面的细节，让我们得以安心的投入到编码中。但是如果真要我们手工处理的话，那么我们每次都在命令行执行例如这样的指令： gcc a.c b.c c.c -o test ，显然是非常影响效率的！而Makefile是我们可以信赖的好伙伴，它定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&emsp;&emsp;综上所述，Makefile 就是一个用来帮助我们编译的工具，和 Windows 下的 IDE 类似，只不过 Makefile 需要我们自己动手编写，一个好的 Makefile 可以极大的提升工作的效率。 Makefile的核心—规则12345678910#######################################target ... : prerequisites ... command...##############################################################################目标 : 依赖1 依赖2 ...[TAB]命令...####################################### target 就是我们编译文件要生成的目标; prerequisites 就是我们编译文件需要的依赖; command 就是用依赖生成目标所需要执行的命令（注意需用tab开始）。 当”目标文件”[不存在], 或某个依赖文件比目标文件[“新”],则: 执行”命令” &emsp;&emsp;比如我们平时使用的 gcc a.c b.c -o test&emsp;&emsp;这里的 test 就是我们要生成的目标， a.c 就是我们生成目标需要的依赖，而 gcc a.c -o test 则是命令。将这行命令用 Makefile 的方式来写就是： 12test:a.c b.c gcc a.c b.c -o test 再次强调：Makefile 中的命令必须用 tab 开始，不能是空格。 &emsp;&emsp;Makefile 可以自动推导文件以及文件依赖关系后面的命令，在后面的示例中我们可以看到目标的依赖基本都是 .o 文件而不是 .c 文件，原因正是 Makefile 强大的自动推导功能。&emsp;&emsp;通常 Makefile 中还会有一个名为 clean 的目标，用来清除编译后产生的各种文件。一般情况下 Makefile 会根据依赖和目标的新旧来决定是否编译，但是如果不小心修改了目标而造成目标比依赖新的情况的话，Makefile 会因为目标比依赖新而忽略这个目标下的命令，这个时候显然会造成问题，一个解决的办法就是使用 clean 这样的目标来清除编译后的文件，然后 make 重新编译。&emsp;&emsp;clean 这个目标有点特殊，他是不需要依赖的，因此也叫伪目标。一般使用方式如下： 12clean: rm *.o test -f Makefile 使用&emsp;&emsp;make 命令执行时，需要一个 Makefile 文件(文件名为 Makefile 、 makefile 、 *.mk )，以告诉 make 命令需要怎么样的去编译和链接程序。执行时只用在命令行输入 make ， Makefile 就会自动执行第一个目标下的命令。而是否执行命令则取决于依赖，如果没有目标文件或是目标后的依赖文件比目标文件新，Makefile 就会执行其下面的命令： Makefile 中使用 # 注释,只注释 # 后的一行。 Makefile 中引用其他 Makefile，用 include 指令来引用。引用的效果就是原地展开。 Makefile 命令前面加 @ 来静默执行，即执行命令时不打印命令本身。 Makefile 语法Makefile 变量&emsp;&emsp;Makefile 中的变量和 shell 脚本中非常相似，都是直接定义，不需要类型，引用时用 $(var) 。&emsp;&emsp;伪目标（ .PHONY ）：伪目标形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。 Makefile 中的几种变量赋值运算符 运算符 说明 = 延时变量赋值，可以被赋值为变量的值，解析时取这个变量最后的值。 := 即时变量赋值，被赋值为变量时解析为变量在这行语句时的值，即变量如果后面改变这里的值也不改变。 ?= 延时变量赋值, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句。 += 附加, 它是即时变量还是延时变量取决于前面的定义。 关于 = 和 := ，比如 B=$(A)bcd ，那么 B 的值取决于变量 A 最后一次被赋值的值，即使 A 在 B 之后再次被赋值，变量 B 仍然会随着 A 的改变而改变。而 := 则只看之前 A 最后被赋值的值。 &emsp;&emsp;即时变量也叫简单变量，即时变量与延时变量的理解示例： 12A := xxx # A的值即刻确定，在定义时即确定B = xxx # B的值使用到时才确定 Makefile 中的自动变量&emsp;&emsp;自动变量是 Makefile 中提前预定义的特殊意义的符号，类似 C 语言中的宏 __LINE__ 等，提前被定义并被赋予了特殊含义。 符号 说明 $@ 目标文件名，比如上文的 test 。 $&lt; 第一个依赖文件名，如果依赖目标是以模式（即“ % “）定义的，那么” $&lt; “将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 $^ 依赖的文件集合，比如上文的 a.c b.c 。 &emsp;&emsp;此外还可以向 Makefile 传参， $# 存放传递参数个数， $1 存放第一个参数的字符串， $2 存放第二个参数的字符串…… Makefile 的环境变量 Makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。 环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。 其他&emsp;&emsp;通配符：比如在当前文件夹下有 1.c 2.c 12.c test.c 1.h 。 通配符 说明 % 若干个任意字符，和 * 很相似，但是 % 一般只用于规则描述中，又叫做规则通配符。 * 若干个任意字符 *.c 匹配 1.c 2.c 12.c test.c 。 ? 1个任意字符 ?.c 匹配 1.c 2.c 。 [] 将 [] 中的字符依次去和外面的结合匹配 [12].c 匹配 1.c 2.c 。 $@ 表示目标 $&lt; 表示第1个依赖文件 $^ 表示所有依赖文件 &emsp;&emsp;Makefile 与 shell 脚本非常相似，shell 脚本中能使用的 Makefile 也能使用，比如 awk 等工具。 Makefile 的函数123456789$(foreach var,list,text)$(filter pattern...,text) # 在text中取出符合patten格式的值$(filter-out pattern...,text) # 在text中取出不符合patten格式的值$(wildcard pattern) # pattern定义了文件名的格式, # wildcard取出其中存在的文件$(patsubst pattern,replacement,$(var)) # 从列表中取出每一个值 # 如果符合pattern # 则替换为replacement Makefile 典型示例&emsp;&emsp;请移步我的GitHub仓库。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是BootLoader？]]></title>
    <url>%2F2019%2F04%2F21%2F0019-%E4%BB%80%E4%B9%88%E6%98%AFBootloader%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoader 可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。&emsp;&emsp;Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。对于嵌入式系统，Bootloader是基于特定硬件平台来实现的。因此，几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。&emsp;&emsp;在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。 操作模式 自启动模式：在这种模式下，bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。 交互模式：在这种模式下，目标机上的bootloader将通过串口或网络等通行手段从开发主机（Host）上下载内核映像等到RAM中。可以被bootloader写到目标机上的固态存储媒质中，或者直接进入系统的引导。也可以通过串口接收用户的命令。 启动过程&emsp;&emsp;Bootloader启动大多数都分为两个阶段。第一阶段主要包含依赖于CPU的体系结构硬件初始化的代码，通常都用汇编语言来实现。这个阶段的任务有： 1. 基本的硬件设备初始化（屏蔽所有的中断、关闭处理器内部指令/数据Cache等）。 2. 为第二阶段准备RAM空间。 3. 如果是从某个固态存储媒质中，则复制Bootloader的第二阶段代码到RAM。 4. 设置堆栈。 5. 跳转到第二阶段的C程序入口点。 &emsp;&emsp;第二阶段通常用C语言完成，以便实现更复杂的功能，也使程序有更好的可读性和可移植性。这个阶段的任务有： 1. 初始化本阶段要使用到的硬件设备。 2. 检测系统内存映射。 3. 将内核映像和根文件系统映像从Flash读到RAM。 4. 为内核设置启动参数。 5. 调用内核。 在第一阶段中为什么要关闭Cache？通常使用Cache以及写缓冲是为了提高系统性能，但由于Cache的使用可能改变访问主存的数量、类型和时间，因此Bootloader通常是不需要的。 常见的BootloaderBootLoader可以是U-Boot\Eboot\vivi等待其他一切方式。BootLoader是所有boot的总称。 ARMboot&emsp;&emsp;ARMboot是一个ARM平台的开源固件项目，它特别基于PPCBoot，一个为PowerPC平台上的系统提供类似功能的姊妹项目。鉴于对PPCBoot的严重依赖性，已经与PPCBoot项目合并，新的项目为U-Boot。&emsp;&emsp;ARMboot发布的最后版本为ARMboot-1.1.0，2002年ARMboot终止了维护。 U-Boot&emsp;&emsp;U-Boot是由开源项目PPCBoot发展起来的，ARMboot并入了PPCBoot，和其他一些arch的Loader合称U-Boot。2002年12月17日第一个版本U-Boot-0.2.0发布，同时PPCBoot和ARMboot停止维护。&emsp;&emsp;U-Boot支持的处理器构架包括PowerPC (MPC5xx，MPC8xx，MPC82xx，MPC7xx，MPC74xx，4xx)， ARM （ARM7，ARM9，StrongARM，Xscale），MIPS (4Kc，5Kc)，x86等等， U-Boot（Universal Bootloader）从名字就可以看出，它是在GPL下资源代码最完整的一个通用Boot Loader。&emsp;&emsp;U-Boot提供两种操作模式：启动加载（Boot loading）模式和下载（Downloading）模式,并具有大型Boot Loader的全部功能。&emsp;&emsp;U-Boot的功能是如此之强大，涵盖了绝大部分处理器构架，提供大量外设驱动，支持多个文件系统，附带调试、脚本、引导等工具，特别支持Linux,为板级移植做了大量的工作。U-Boot1.1.1版本特别包含了对SA1100和44B0芯片的移植，所以44B0移植主要是针对Board 的移植，包括FLASH、内存配置以及串口波特率等等。U-Boot的完整功能性和后续不断的支持，使系统的升级维护变得十分方便。 Eboot&emsp;&emsp;是使用网口的意思，是微软提供的一般是wince下的bootloader，但是经过修改也可以兼容运行在其他OS下，如linux。如果直接说eboot也是bootloader”这样说不够严谨，对于基于norflash的bootloader来说是对的，如果bootloader是从nandflash开始执行就不对了，但我们所说的bootloader=nboot+eboot，其中nboot负责把eboot加载到SDRAM指定的内存处，然后运行eboot，接着eboot会把NK加载到SDRAM中并且执行。 vivi&emsp;&emsp;vivi是韩国mizi 公司开发的bootloader, 适用于ARM9处理器。Vivi有两种工作模式：启动加载模式和下载模式。启动加载模式可以在一段时间后（这个时间可更改）自行启动linux内核，这是vivi的默认模式。在下载模式下，vivi为用户提供一个命令行接口，通过接口可以使用vivi提供的一些命令 Redboot&emsp;&emsp;Redboot是Redhat公司随eCos发布的一个BOOT方案，是一个开源项目。&emsp;&emsp;Redboot支持的处理器构架有ARM，MIPS，MN10300，PowerPC， Renesas SHx，v850，x86等，是一个完善的嵌入式系统Boot Loader。&emsp;&emsp;Redboot是在ECOS的基础上剥离出来的，继承了ECOS的简洁、轻巧、可灵活配置、稳定可靠等品质优点。它可以使用X-modem或Y-modem协议经由串口下载，也可以经由以太网口通过BOOTP/DHCP服务获得IP参数，使用TFTP方式下载程序映像文件，常用于调试支持和系统初始化（Flash下载更新和网络启动）。Redboot可以通过串口和以太网口与GDB进行通信，调试应用程序，甚至能中断被GDB运行的应用程序。Redboot为管理FLASH映像，映像下载，Redboot配置以及其他如串口、以太网口提供了一个交互式命令行接口，自动启动后，REDBOOT用来从TFTP服务器或者从Flash下载映像文件加载系统的引导脚本文件保存在Flash上。&emsp;&emsp;Redboot是标准的嵌入式调试和引导解决方案，支持几乎所有的处理器构架以及大量的外围硬件接口，并且还在不断地完善过程中。 Blob&emsp;&emsp;Blob(Boot Loader Object)是由Jan-Derk Bakker and Erik Mouw发布的，是专门为StrongARM 构架下的LART设计的Boot Loader。&emsp;&emsp;Blob也提供两种工作模式，在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 Blob 切换到下载模式。如果在 10 秒内没有用户按键，则 Blob 继续启动 Linux内核。&emsp;&emsp;Blob功能比较齐全，代码较少，比较适合做修改移植，用来引导Liunx，目前大部分S3C44B0板都用Blob修改移植后来加载uClinux。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件描述符、文件指针和文件偏移量之甄别]]></title>
    <url>%2F2019%2F04%2F18%2F0018-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%8B%E7%94%84%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在 C 程序中,文件由文件指针或者文件描述符表示。 文件描述符&emsp;&emsp;在 linux 系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，也就是说每一个文件描述符都是一个问文件的索引，当然也可以出现多个不同的文件描述符索引同一个文件。Linux标准文件描述符: 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误输出 文件指针&emsp;&emsp;C语言中使用文件指针做为 I/O 的句柄。文件指针指向进程用户区中的一个被称为 FILE 结构的数据结构。 FILE 结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在 Windows 系统上，文件描述符被称作文件句柄）。 文件偏移量&emsp;&emsp;每个打开的文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下.so、.ko、.a、.o文件的区别]]></title>
    <url>%2F2019%2F04%2F16%2F0017-Linux%E4%B8%8B-so%E3%80%81-ko%E3%80%81-a%E3%80%81.o%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&emsp;&emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是linux/unix的哲学核心思想。这句话中的“文件”不仅仅是我们通常所指的文件，在linux和unix中它代表的更为宽泛。目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”。然而有些文件对于在嵌入式Linux中是比较值得注意的，那就是.so、.ko、.a文件，我们可能会在有意或无意间遇到过，若是初次见面它们很容易就把我们迷惑了，下面概要的说明下这几者的区别。 .so文件&emsp;&emsp;&emsp;&emsp;.so(share object)文件是用户层的动态链接库，相当于Windows的.dll文件，用于用户层的动态链接使用，内核态的代码同样不能直接访问。 .ko文件&emsp;&emsp;&emsp;&emsp;.ko(kernel object)文件是内核态的动态链接库，用于内核态的动态链接使用，可以用于内核之间的模块相互调用。用户态的代码不可直接调用内核态的代码，但是可以通过其他方式进行通信。 .a文件&emsp;&emsp;&emsp;&emsp;.a文件是用于静态链接时，使用的静态库。 .o文件&emsp;&emsp;&emsp;&emsp;.o文件是目标文件，编译生成,相当于windows中的.obj文件。.a文件就是由.o文件打包生成的。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是操作系统？]]></title>
    <url>%2F2019%2F04%2F08%2F0016-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。&emsp;&emsp;操作系统是管理计算机硬件的软件。硬件必须提供适当机制，以确保计算机系统的正确运行并且防止用户程序干扰系统的正常运行。&emsp;&emsp;操作系统可以采用许多不同的组织方式，因此内部结构也有很大差异。设计新的操作系统的任务是艰巨的。在设计开始之前，明确界定设计系统的目标是非常重要的。这些目标是选择不回算法和策略的基础。&emsp;&emsp;操作系统既庞大又复杂，因此应分块构造。每块都应具有描述明确的系统部分，并且具有严格定义的输入、输出和功能。 有一个重点我们是必须get住的，那就是：操作系统（operating system）是管理计算机硬件的程序。也就是说操作系统是只是一个管理、控制的程序，它为其他应用程序提供基础，并且从当计算机用户和计算机硬件的中介，所以我们平时所作的所有操作都是在操作系统这个程序下进行的。 什么是操作系统&emsp;&emsp;操作系统的存在是因为其提供了合理的方式来解决创建可用计算系统的问题，计算机系统的根本目的是，执行用户程序帮助用户解决实际问题。&emsp;&emsp;操作系统是一直运行在计算机上的程序（通常称为内核（kernel））。除了内核外还有其他两类程序：系统程序（system program）和应用程序。前者是与系统运行息息相关的程序（其保证着系统的正常运作），但不是内核的一部分，后者是与系统运行无关的其他应用程序（可以理解为用户程序）。 操作系统的功能&emsp;&emsp;计算机操作系统可粗分了四个组件：硬件、操作系统、应用程序和用户。 计算机系统组件的抽象视图 硬件（hardware）为我们的系统提供基本的计算资源； 应用程序规定了用户为解决计算问题而使用硬件资源的方式； 而操作系统决定应用程序使用资源的方式和权限。 至此，计算机系统也可分为硬件、软件和数据，当计算机系统运行时，操作系统提供正确的手段来让这些资源得到合理的利用。 正如刚才强调的，至此，我们可以更形象的将操作系统理解为：操作系统类似于政府，其本身不能实现任何有用的功能，而是为其他程序的执行提供一个合理安全的环境。 用户视角&emsp;&emsp;计算机的用户视角因使用界面的不同而不同。&emsp;&emsp;大多数的计算机用户的都是普通用户，即PC又显示器、键盘、鼠标和主机。这样的计算机是为了让单个用户单独使用资源，目的是优化用户进行的工作（或娱乐）。因此在对于这类群体，操作系统的设计的主要目的是为了用户的使用便利，而次要的是性能，不在乎资源的共享和利用。当然其中也包括我们程序员这一群体。&emsp;&emsp;接着就是服务器了，对于这个视角的用户面对的是与大型机或小型机相连的终端前。这类系统的设计目标是优化资源的利用效率，确保所有的CPU时间、内存和I/O都能得到有效的使用，并且确保没有用户使用操作限制以外的资源。&emsp;&emsp;与我们日常工作接触的是这样一种情况，我们处于工作站内，这类工作站与其他工作站和服务器相连。这时我们作为用户不仅可以使用专用资源，而且可以使用网络和服务器的共享资源，如：文件，计算和打印服务等。这类的操作系统的设计便是上述两种情况的折中方案，即考虑资源利用率与便利性。 系统视角&emsp;&emsp;从计算机的是视角来看，操作系统是与硬件紧密相连的程序。因此，可将操作系统看作资源分配器。操作系统管理着（如：CPU时间、内存空间、文件存储空间、I/O设备等）这些资源，当面对许多甚至冲突的资源请求时，操作系统应该考虑如何为各个程序和用户分配资源，以便计算机能有效且公平地运行。 说到资源请求，此时操作系统是一个控制程序，它特别注重I/O设备的运行和控制，其管理着用户程序的执行，以防止计算机资源的错误或不当使用。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）]]></title>
    <url>%2F2019%2F04%2F07%2F0015-Arduino%E6%8E%A7%E5%88%B6ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的控制需要有精确到微秒级PWM；然而Linux系统很繁忙，最多只能达到毫秒级别的控制，所以对于安装了基于ARM架构的Debian的树莓派达不到我们要求的精确控制。由此自然联想到了使用单片机进行辅助控制，而其中使用Arduino最为简单，因此最终选择Arduino作为项目的辅助控制外设模块。 项目简介&emsp;&emsp;本文实现了对五线四相八拍步进电机（28BYJ8）的较为精确的控制，同时加入了EEPROM记录的功能，在运行过程中能记录步进电机目前的位置，在意外掉电重启后能定位自身所处角度并恢复到设定的位置。 硬件模块&emsp;&emsp;步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲：当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。我们可以通过控制脉冲个来控制角位移量，从而达到准确定位的目的；同时亦可通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。 &emsp;&emsp;步进电机28BYJ48型四相八拍电机，电压为DC5V—DC12V。当对步进电机施加一系列连续不断的控制脉冲时，它可以连续不断地转动。每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的通电方式有单（单相绕组通电）四拍（A-B-C-D-A…），双（双相绕组通电）四拍（AB-BC-CD-DA-AB-…），八拍（A-AB-B-BC-C-CD-D-DA-A…） 12uchar code CCW[8]=&#123;0x08,0x0c,0x04,0x06,0x02,0x03,0x01,0x09&#125;; //逆时钟旋转相序表uchar code CW[8]=&#123;0x09,0x01,0x03,0x02,0x06,0x04,0x0c,0x08&#125;; //正时钟旋转相序表 &emsp;&emsp;五线四相八拍步进电机（28BYJ8）：五线四相八拍步进电机（28BYJ8） &emsp;&emsp;ULN2003驱动模块： ULN2003驱动模块 &emsp;&emsp;全局概览： 全局概览 项目代码&emsp;&emsp;详细代码及更多内容请参考我在GitHub仓库中的项目。]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题]]></title>
    <url>%2F2019%2F04%2F06%2F0014-Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3TensorFlow%E4%B8%AD%E7%9A%84OpenCV%E8%A7%86%E9%A2%91%E6%B5%81%E8%AF%BB%E5%8F%96%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的 read() 函数时发现其数据处理与数据产生的速度跟不上而导致延迟非常高，甚至内存溢出，因此开始思考解决措施。 1retval, image = cv.VideoCapture.read([, image]) &emsp;&emsp;这是因为OpenCV读取视频流时，数据处理程序需要消耗的CPU时间过于长（不同硬件配置情况不可一概而论），而VideoCapture的read是按帧队列读取且先进先出，最后导致视频帧数据产生的速度与读取、处理速度不平衡，所以出现了上面所说的问题。由此联想到我们可以试图将需要读取视频数据和处理视频数据的过程分开处理，从而解决延迟问题。 思路分析&emsp;&emsp;我们可以使用多进程或多线程将读取视频数据和处理视频数据的过程分开处理，但是由于实时视频处理属于CPU密集型任务，多线程的优势发挥不出来，因此我们选择多进程方式。 所用到的库&emsp;&emsp;实现多进程所用到的库： 1234import osimport cv2import gcfrom multiprocessing import Process, Manager &emsp;&emsp;两个子进程： 12write()read() 在两个子进程中传递参数 multiprocessing中有Quaue、SimpleQuaue等进程间传参类，以及Manager统领全局。 使用Manager我们可以在进程键传递字典、列表灯Python原生数据类型 Quaue时严格的数据结构队列类型 在读取进程中得到最新的视频帧数据 首先 VideoCapture 是队列，先进先出。因此我们需要将其转换为压栈存储视频帧数据，才能达到后进先出而获取最新的视频帧数据，因此不能使用Quaue来传递参数。 为了达到压栈的效果，我们可以使用Python的列表，其append与pop操作可以达到模拟压栈的效果。因此，我们可以使用 multiprocessing.Manager.list 进行进程间传参类型最为理想不过。 清理传参栈&emsp;&emsp;由于压栈频率肯定是要比出栈频率高的，时间一长就会在栈中积累大量无法出栈的视频帧，会导致程序崩溃，因此我们需要考虑传参栈自动清理的问题，我们需要一个自动清理的机制： 我们可以设定传参栈的容量，每当达到这个容量时就直接把栈清空，再利用gc库手动发起一次python垃圾回收，这样就不会导致严重的内存溢出和程序崩溃。 实现代码&emsp;&emsp;综上所述，实际上这个程序就是把VideoCapture的队列读取改成了栈读取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226# -*- coding: UTF-8 -*-__author__ = 'YobeZhou'########################################################## File name: object_detection.py# Author: YobeZhou# Date: 2018/12/12########################################################## Import packagesimport osimport cv2import numpy as npimport tensorflow as tfimport sysimport socketimport timeimport threadingimport gcfrom multiprocessing import Process, Manager#import pdb# Import utilitesfrom utils import label_map_utilfrom utils import visualization_utils as vis_utilprocess_result = 'ok'# 向共享缓冲栈中写入数据:def write(stack, cam, top: int) -&gt; None: """ :param cam: 摄像头参数 :param stack: Manager.list对象 :param top: 缓冲栈容量 :return: None """ print('Process to write: %s' % os.getpid()) video = cv2.VideoCapture(cam) ret = video.set(3,1280) ret = video.set(4,720) retval = video.get(5) print (cam) print(retval) while(video.isOpened()): ret, img = video.read() if ret: stack.append(img) # 每到一定容量清空一次缓冲栈 # 利用gc库，手动清理内存垃圾，防止内存溢出 if len(stack) &gt;= top: del stack[:] gc.collect() # Press 'q' to quit if cv2.waitKey(1) == ord('q'): print ("Write process has safely exited...") break # Clean up video.release() cv2.destroyAllWindows()# read进程的子线程，用以监听接收socket通信数据包# 这是从 threading.Thread 继承创建一个新的子类class myThread (threading.Thread): def __init__(self, threadID, newSocket, data): threading.Thread.__init__(self) self.threadID = threadID self.newSocket = newSocket self.data = data self.cmd = 'o' def run(self): while(True): if (self.cmd == 'q'): break self.data = self.newSocket.recv(4) #print (self.data) print ("Receiving data thread has safely exited...")# 在缓冲栈中读取数据:def read(stack) -&gt; None: #DST_IP = '192.168.1.106' DST_IP = '10.3.141.1' DST_PORT = 8666 # time.sleep(2) print('Process to read: %s' % os.getpid()) # 包含正在使用的对象检测模块的目录的名称 MODEL_NAME = 'inference_graph' # 抓取当前工作目录的路径 CWD_PATH = os.getcwd() # 冻结检测图.pb文件的路径，其中包含用于对象检测的模型 PATH_TO_CKPT = os.path.join(CWD_PATH,MODEL_NAME,'frozen_inference_graph.pb') # 标签映射文件的路径 PATH_TO_LABELS = os.path.join(CWD_PATH,'training','labelmap.pbtxt') # 声明对象检测器可以识别的类数 NUM_CLASSES = 4 # 加载标签 label_map = label_map_util.load_labelmap(PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) # 将Tensorflow模型加载到内存中 detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') sess = tf.Session(graph=detection_graph) # 输入张量是图像 image_tensor = detection_graph.get_tensor_by_name('image_tensor:0') # 输出张量是检测框，分数和类 # 每个框表示检测到特定对象的图像的一部分 detection_boxes = detection_graph.get_tensor_by_name('detection_boxes:0') # 每个分数代表每个对象的置信水平 # 分数与结果图像一起显示在结果图像上 detection_scores = detection_graph.get_tensor_by_name('detection_scores:0') detection_classes = detection_graph.get_tensor_by_name('detection_classes:0') # 检测到的对象数量 num_detections = detection_graph.get_tensor_by_name('num_detections:0') #建立Socket，SOCK_STREAM表示Socket类型为TCP print("Starting socket: TCP...") socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #在客户端开启心跳维护 socket_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) socket_tcp.connect((DST_IP, DST_PORT)) # 创建新线程 thread1 = myThread(1, socket_tcp, 'ok') # 启动新线程 thread1.start() #socket_tcp.send(bytes("Tensorflow ok!",encoding="utf-8")) socket_tcp.send(b'Tensorflow ok!') while(True): if len(stack) != 0: # 获取框架并扩展框架尺寸以具有形状：[1，无，无，3] # 即单列阵列，其中列中的每个项目具有像素RGB值 frame = stack.pop() frame_expanded = np.expand_dims(frame, axis=0) # 通过以图像作为输入运行模型来执行实际检测 (boxes, scores, classes, num) = sess.run( [detection_boxes, detection_scores, detection_classes, num_detections], feed_dict=&#123;image_tensor: frame_expanded&#125;) # 绘制检测结果（也称为“可视化结果”） # 可视化图像阵列上的框和标签 image,tablename = vis_util.my_visualize_boxes_and_labels_on_image_array( frame, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8, min_score_thresh=0.60) # 将结果绘制在框架上并显示出来。 cv2.imshow('Object detector V1.0 Author:Yobe Zhou', frame) datar = thread1.data print (datar) if (datar == b'ok'): print (tablename) if tablename == "metal": socket_tcp.sendall(b'metal') elif tablename == "plastic": socket_tcp.sendall(b'plastic') elif tablename == "paper": socket_tcp.sendall(b'paper') elif tablename == "peel": socket_tcp.sendall(b'peel') # 按'q'退出 if cv2.waitKey(1) == ord('q') : socket_tcp.sendall(b'exit') thread1.cmd = 'q' break # Clean up thread1.join() socket_tcp.close() print ("Read process has safely exited...") if __name__ == '__main__': print(tf.__version__) sys.path.append("..") # Initialize webcam feed (Raspberry) url = 'http://10.3.141.1:8081/' # 父进程创建缓冲栈，并传给各个子进程： q = Manager().list() pw = Process(target=write, args=(q, url, 100)) pr = Process(target=read, args=(q,)) pw.start() pr.start() # 等待进程结束 pw.join() pr.join() print ("End of program!")]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt串口读取连贯数据]]></title>
    <url>%2F2019%2F04%2F05%2F0013-Qt%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%8F%96%E8%BF%9E%E8%B4%AF%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Qt的“信号与槽”机制极大的便利了内部事件的处理，但是在接收串口数据时我们利用到Qt的这一机制，却发现接收到的数据往往是不连贯的，这是由于当有数据到来时便立即触发读取操作，串口数据发送亦然，借此我们的程序能够及时处理串口中的数据。然而由于串口传输速率以及延迟问题，此时如果没有对接收到的串口数据做缓冲处理，最终导致我们接收到的数据呈现出来的将是断断续续的状态。因此下面的笔记为Qt中加了缓冲区的串口读取操作。 串口缓冲区读取操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 创建静态全局变量，用以串口读取缓冲区 */static QByreArry s_serialDataBuf;/*！ * \rief Qt串口数据读取 * \param 无输入参数 * \return 无返回值 * \attention 仅作参考 * \author Yobe Zhou*/void MainWindow::readSerialData()&#123; QString readData; /* 读取串口数据，当串口有数据到来时马上读取 */ const QByreArry bufferData = m_serial-&gt;readAll(); /* 将读取到数据追加到缓冲区 */ s_serialDataBuf.append(bufferData); /* 追加数据直到缓冲区有至少一条目标语句 */ if (s_serialBuffer.contains('B')) &amp;&amp; (s_serialDataBuf.contains('\n')) &#123; QString tempString; QList&lt;QByteArry&gt; lineList; int listCount = 0; tempString = s_serialDataBuf; /* 根据字头标识分割各条语句 */ lineList = s_serialDataBuf.split('B'); /* 清空缓冲区用以下一轮接收 */ s_serialDataBuf.clear(); /* 确定有多少目标语句 */ listCount = lineList.count(); /* 处理分割后的每条语句 */ for (int i = 0; i &lt; listCount; i++) &#123; readData = lineList.at(i); /* 当出现语句不完整（断句） */ if (!(readData.contains('\n'))) &#123; /* 当前处理语句为待处理语句的最后一句（有效断句） */ if (i == listCount - 1) &#123; /* 为断句补充标识 */ s_serialDataBUf.append('B'); /* 保存断句（存入清空后的缓冲区），承接下一轮接收 */ s_serialDataBuf.append(readData); continue; &#125; /* 不是有效断句，直接跳过 */ else &#123; continue; &#125; &#125; /* 语句中包含标识字符1 */ if (readData.contains("Target character2")) &#123; /* code */ &#125; /* 语句中包含标识字符2 */ else if (readData.contains("Target character")) &#123; /* code */ &#125; /*....*/ else &#123; /* code */ &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准库函数与运算符的区别]]></title>
    <url>%2F2019%2F04%2F01%2F0012-%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。下面来看他们的区别。 标准库函数与运算符的区别一、操作对象有所不同&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。 &emsp;&emsp;对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。 &emsp;&emsp;运算符是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。 库函数是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。 二、在用法上也有所不同&emsp;&emsp;函数malloc的原型如下： 1void * malloc(size_t size); &emsp;&emsp;用malloc 申请一块长度为length 的整数类型的内存，程序如下： 1int *p = (int *) malloc(sizeof(int) * length); &emsp;&emsp;我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 malloc返回值的类型是void *，所以在调用malloc时要显示地进行类型转换，将void * 转换成所需要的指针类型。 mallo函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。 &emsp;&emsp;函数free的原型如下： 1void free( void * memblock ); 为什么free 函数不象malloc 函数那样复杂呢？&emsp;&emsp;这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。 new/delete的使用要点&emsp;&emsp;运算符new使用起来要比函数malloc简单得多，例如 12int *p1 = (int *)malloc(sizeof(int) * length); int *p2 = new int[length]; &emsp;&emsp;这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。 &emsp;&emsp;如果new创建对象数组，那么只能使用对象的无参构造函数。例如： 1Obj *objects = new Obj[100]; // 创建100 个动态对象 &emsp;&emsp;不能写成 1Obj *objects = new Obj[100](1);// 创建100 个动态对象的同时赋初值1 &emsp;&emsp;在用delete 释放对象数组时，留意不要丢了符号‘[ ]’。例如 12delete []objects; // 正确的用法 delete objects; // 错误的用法 &emsp;&emsp;后者相当于delete objects[0]，漏掉了另外99个对象。 两者区别 new自动计算需要分配的空间，而malloc需要手工计算字节数 new是类型安全的，而malloc不是，比如： 12int* p = new float[2]; // 编译时指出错误 int* p = malloc(2*sizeof(float)); // 编译时无法指出错误 new operator 由两步构成，分别是 operator new 和 construct（构造） operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力 new将调用constructor（构造函数），而malloc不能；delete将调用destructor（析构函数），而free不能。 malloc/free要库文件支持，new/delete不要。 本质区别&emsp;&emsp;malloc/free是c/C++语言的标准库函数，new/delete是C++的运算符。&emsp;&emsp;对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。 123456789101112131415161718192021222324class Obj &#123; public : Obj( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; ~ Obj( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; void Initialize( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; void Destroy( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; &#125;; void UseMallocFree( ) &#123; Obj * a = (Obj * ) malloc( sizeof ( Obj ) ); // allocate memory a -&gt; Initialize(); // initialization // … a -&gt; Destroy(); // deconstruction free(a); // release memory &#125; void UseNewDelete( void ) &#123; Obj * a = new Obj; // … delete a; &#125; &emsp;&emsp;类Obj的函数Initialize实现了构造函数的功能，函数Destroy实现了析构函数的功能。函数UseMallocFree中，由于 malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成“构造”与“析构”。（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。&emsp;&emsp;所以我们不要用 malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言 malloc/free和new/delete是等价的。 两者的联系&emsp;&emsp;既然new/delete的功能完全覆盖了malloc /free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用 free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete，malloc/free必须配对使用。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客主页文章展示实用设置]]></title>
    <url>%2F2019%2F03%2F31%2F0011-Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E5%AE%9E%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[调整主页文章展示间距，最后添加 1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 20px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: $grey-dim; background: none; border: none; border-bottom: 2px solid $grey-dim; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125; 修改为 12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 5px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: Red; // http://cc.oulu.fi/~thu/jwz/Colours/545454.html background: none; border: none; border-bottom: 2px solid Red; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的三种地址及其转换]]></title>
    <url>%2F2019%2F03%2F31%2F0010-%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址（以80x86微处理器为例）： 逻辑地址（logical address）：机器语言指令中用来指定一个操作数或者一条指令的地址，每一个逻辑地址由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。 线性地址（linear address 也叫做虚拟地址 virtual address）：是一个 32 位无符号整数，可以用来表达 4GB 的地址，通常用十六进制数表示。 物理地址（physical address）：用于内存芯片内的内存单元寻址，它们从微处理器的地址引脚发送到内存总线上的电信号对应。 以上内容来自 《Understanding The Linux Kernel》 内存管理单元（Memory Management Unit, MMU）通过分段单元的把一个逻辑地址转换成线性地址，通过分页单元把线性地址转换成物理地址。 三种内存地址逻辑地址&emsp;&emsp;包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在 80X86 著名的分段结构中表现得尤为具体，它促使 MS-DOS 或 Windows 程序员把程序分成若干段。每一个逻辑地址都是有一个段和偏移量组成，偏移量指明了从段开始的地方到时间地址之间的距离。 线性地址（虚拟地址）&emsp;&emsp;是一个32位无符号整数，可以用来表示高达4GB的地址，也就是高达4294967296个内存单元。线性地址通常用十六进制数字表示。 物理地址&emsp;&emsp;用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。 &emsp;&emsp;内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址 分段与分页机制&emsp;&emsp;从 80286 开始，Intel 处理器以两种不同的方式执行地址转换，分别为实模式（real mode）和保护模式（protected mode）。下面我们就展开描述，在保护模式下，硬件的分段机制和分页机制 分段机制&emsp;&emsp;段选择符和段寄存器&emsp;&emsp;逻辑地址有两部分组成：一个段标识符和一个偏移量。短标识符是一个 16 位的字段，成为段选择符；偏移量是一个 32 位长的字段。&emsp;&emsp;为了快速找到段选择符，处理器提供了段寄存器用来存放段选择符，分别为 cs，ss，ds，es，fs，gs。&emsp;&emsp;其中有三个有专门的用途： cs：代码段寄存器，指向包含程序指令的段 ss：栈段寄存器，指向包含当前程序栈的段 ds：数据段寄存器，指向包含静态数据或者全局数据段&emsp;&emsp;其中，cs 含有一个两位的字段，用来指明当前的 CPU 特权等级（CPL），0 代表最高等级、3 代表最低等级。 Linux 只用到了 0 和 3，分别称为 内核态 和 用户态 段描述符&emsp;&emsp;每个段由一个 8 字节的段描述符表示，描述了段的基本信息。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）中。&emsp;&emsp;通常只会定义一个 GDT，每个进程除了放在 GDT 中的段以外，如还需要创建附加的段，就可以有自己的 LDT。GDT 在主存中的地址和大小存放在 gdtr 控制寄存器中，LDT 的地址和大小则存放在 ldtr 中。&emsp;&emsp;段描述符包涵以下关键字段： |Base| 包含段的首字节的线性地址|Type| 描述了段的类型特征和它的存取权限|DPL| 限制对这个段的存取权限，表示访问这个段的要求的最小 CPU 特权等级|P| Segment-Present 标志，表明当前段是否在内存中。Linux 总是把这个标志设为 1，从来不会把整个段交换到磁盘上去 分段单元&emsp;&emsp;那么逻辑地址是如何转换到线性地址的呢？ 先检查段选择符的TI字段，已决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址） 从段选择符的index字段计算段描述符的地址，index字段的值乘以8，这个结果与gdtr或ldtr寄存器的内容相加 把逻辑地址的偏移量与段描述符base字段的值相加就得到了线性地址 &emsp;&emsp;第二个称为分页单元的硬件电路把线性地址转化成一个物理地址。 12 分段单元 分页单元逻辑地址 ----&gt; 线性地址 ----&gt; 物理地址 &emsp;&emsp;实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间，与分段相比，Linux更喜欢使用分页方式。因为当所有进程使用相同的段寄存器值时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持很有限。在多处理系统中，所有与CPU都共享同一内存；这意味着RAM芯片可以由独立的CPU并发访问。因为在RAM芯片上的读或写操作必须串行的执行。因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间，作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含有一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。 在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如：双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。 &emsp;&emsp;仲裁器由硬件电路管理，是隐藏的。 快速访问分段机制&emsp;&emsp;如果每次都执行上述的过程，可能会比较耗时，因为 GDT 是存储在主存中的，每次都访问主存，可能会比较慢，所以为了提高逻辑地址到线性地址的转换速度，80x86 处理器提供了一组6个不可编程寄存器。每一个不可编程寄存器含有 8 个字节的段描述符，具体的值由相对应的段寄存器中的段描述符确定。每当一个段选择符被装入段寄存器，相对应的段描述符就由主存装入到对应的不可编程寄存器，这样就可以不需要上面三个过程中的前两个，就可以得到线性地址了。 分页机制页、页框和页表&emsp;&emsp;分页单元把线性地址转换成物理地址，其中的关键任务是把所请求的访问类型与线性地址的访问权限做对比。 页：为了更高效和更经济的管理内存，线性地址被分为以固定长度为单位的组，成为页。页内部连续的线性地址空间被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和对应的存取权限，而不用指定全部线性地址的存取权限。这里说页，同时指一组线性地址以及这组地址包含的数据 页框：分页单元把所有的 RAM 分成固定长度的页框，每一个页框包含一个页。页框是主存的一部分，因此也是一个存储区域。页和页框相比，前者只是一个数据块，可以存放在页框或者磁盘中。 页表：把线性地址映射到物理地址的数据结构成为页表，页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化 常规的分页&emsp;&emsp;从 80386 开始，Intel 处理器的页大小为 4KB。&emsp;&emsp;32 位的线性地址被分为 3 个域： Directory（目录）：最高 10 位 Table（页表）：中间 10 位 Offset（偏移量）：最低 12 位&emsp;&emsp;线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表成为页目录表，第二种转换表成为页表。 &emsp;&emsp;为什么需要两级呢？目的在于减少每个进程页表所需的 RAM 的数量。如果使用简单的一级页表，将需要高达 2^20 个表项来表示每个进程的页表，即时一个进程并不使用所有的地址，二级模式通过职位进程实际使用的那些虚拟内存区请求页表来减少内存容量。每个活动的进程必须有一个页目录，但是却没有必要马上为所有进程的所有页表都分配 RAM，只有在实际需要一个页表时候才给该页表分配 RAM。 &emsp;&emsp;页目录项和页表项的结构如下： Present 标志：为 1 则表示页在主存中；如果为 0 则表示不在内存中，如果执行一个地址转换的时候，所需的页表项或者页目录项中的该标志为 0，那么分页单元就把该线性地址存在在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。 包含页框物理地址最高 20 位的字段 Dirty：当对页框进行写操作时就设置这个标志 Read/Write 标志：含有页或者页表的存取权限 User/Supervisor：含有访问页或者页表所需的特权等级 &emsp;&emsp;了解了以上结构之后，我们看看如何从线性地址转换到物理地址的： 线性地址中的 Directory 字段决定页目录中的目录项，目录项指向适当的页表 线性地址中的 Table 字段又决定页表的页表项，页表项含有页所在页框的物理地址 线性地址中的 Offset 地段决定了页框内的相对位置，由于 offset 为 12 为，所以一页含有 4096 字节的数据 总结&emsp;&emsp;以上描述的为 80x86 微处理器硬件分页机制，不同架构的 64 位处理器分页机制，大体的思路就是将二级模式拓展为三级（ia64）或者四级（x86_64），以达到对更大范围寻址空间的支持。 笔记：16进制线性地址转换&emsp;&emsp;16进制的线性地址转化为地址的物理空间大小。&emsp;&emsp;如：0x00000000 - 0x08000000的物理空间大小为128MB 换算：0x08000000 === 134217728 (Bytes) 134217728(Bytes) / 1024 = 131072(KB) 131072(KB) / 1024 = 128(MB)]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>嵌入式</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提交搜索引擎收录（Google+Baidu）]]></title>
    <url>%2F2019%2F03%2F31%2F0009-Hexo%E6%8F%90%E4%BA%A4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%EF%BC%88Google-Baidu%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[递增与减运算符：++与--]]></title>
    <url>%2F2019%2F03%2F31%2F0008-%E9%80%92%E5%A2%9E%E4%B8%8E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%2B%2B%E4%B8%8E--%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;紧凑的代码让程序更为整洁，而且通常其生成的机器代码效率更高。 递增与递减运算符&emsp;&emsp;递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)： 1. &quot;++&quot;出现在其作用的变量前面---前缀模式(++a) 如：q = 2*++a; • 首先，a递增1； • 然后，2乘以a，并将结果赋给q 2. &quot;++&quot;出现在其作用的变量后面---后缀模式(a++) 如：q = 2*a++; • 首先，2乘以a，并将结果赋给q； • 然后，a递增1&emsp;&emsp;同理可得： &quot;--&quot;出现在其作用的变量前面 ----&gt; 前缀模式(--a) &quot;--&quot;出现在其作用的变量后面 ----&gt; 后缀模式(a--)]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加Gitment评论系统]]></title>
    <url>%2F2019%2F03%2F30%2F0007-Hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Hexo框架搭建好之后，默认的功能模块有限，因此很多模块需要我们自己去添加，对于我们的博客网站来说，没有评论系统怎么行呢？毕竟我们需要采集良言，及时发现文章的不足并且可以帮助仍有疑问的朋友解答问题。话不多说，我们开始搭建博客的评论系统吧。 Gitment评论系统&emsp;&emsp;我们首先了解一下国内的几个第三方评论系统，如“多说”，“畅言”，“友言”，“新浪云跟贴”： 多说，曾经较火的评论系统，网上介绍文章比较多，但已关闭，无法再用了。 畅言，sohu旗下的，但是需要个人博客备案后才能使用，但github pages个人博客感觉备案比较难。 友言，jiaThis旗下的，由于时http请求，github pages现在都是https了， 在https站点无法调用http请求，故也无法使用。 网易云跟贴，曾被当作“多说”的替代品，可惜官方通报说也将在2017.08.01关闭了。 Gitment，一款由国内大神imsun开发的基于github issues的评论系统, 具体介绍请看项目主页 Gitment简介&emsp;&emsp;&emsp;&emsp;Gitment 是基于 GitHub Issues 的评论系统，是 imsun 利用 github 上的 issues 做的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown&amp;GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。想了解具体效果，可以点击查看官方Demo Page:Gitment Demo。 注册OAuth Application&emsp;&emsp;首先我们先去 OAuth application 进行注册，申请一个 Github OAuth Application。填写参考如下： Application name: 博客名字 Homepage URL: 网站主页地址(这里我填写的是域名或github项目地址/index.html大部分的默认网页都是index.html) Application description: 描述，选填 Authorization callback URL: 填写域名或github项目地址 &emsp;&emsp;填写相关信息时注意在 Authorization callback URL 一项填自己的网站url： 1https://username.github.io &emsp;&emsp;填写完毕后点击 Register application 若创建成功则将跳转到另外一个界面，此时我们会得到一个 client ID 和一个 client secret，它们将被用于之后的用户登录。 修改 _config.yml&emsp;&emsp;我们需要在 Hexo 主题目录下编辑修改 _config.yml 配置文件。不同的主题的配置文件存放路径有所差别，下面以 netx 主题为例说明： 1next主题的配置文件路径：&quot;/themes/next/_config.yml&quot; &emsp;&emsp;打开配置文件后，我们搜索关键字“Gitment”将定位到配置位置。默认的配置内容为： 1234567891011121314# Gitmentgitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled &emsp;&emsp;我们修改成自己的配置内容： 123456789101112131415# 添加Gitment评论系统# Gitmentgitment: enable: true # 修改为 true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: 123456 # 填写自己的 github ID github_repo: xxx.github.io # 存储评论内容的仓库名 client_id: abcd123456abcd # 填写获取到的 client_id client_secret: abcd123456efg # 填写获取到的 client_secret proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 获取自己的 Github ID&emsp;&emsp;在浏览器中打开下面的地址，”Your github username”需要修改为自己的Github username: 1https://api.github.com/users/"Your github username" 验证&emsp;&emsp;在 Hexo 根目录输入： 1$ hexo s &emsp;&emsp;浏览器打开地址： 1http://localhost:4000/ &emsp;&emsp;浏览自己的一篇博客到最后，如果发现有评论界面则大功告成！如果没有应该时配置信息没写对，请检查自己的配置内容。 ![Gitment_test_interface](/images/Gitment_test_interface.png) &emsp;&emsp;但是此时出现了错误： 1Error:Not Found &emsp;&emsp;经过检查后发现是 owner 或 repo 配置错误 将 github_user 直接填写自己的Github用户名即可。 &emsp;&emsp;然而此时仍有可能出现如下的问题： &emsp;&emsp;或英文提示：”Error: Comments Not Initialized”。原因有如下两点： 在该页面的Gitment评论区登陆GitHub账号 之前OAuth Application callback填写有误&emsp;&emsp;若当点击评论区的“使用Github登陆”跳转出现报错，则可以确定是之前“OAuth Application callback”填写有误，我们需要返回到自己的Github设置上去修改过来：1Github头像下拉菜单 --&gt; Settings --&gt; 左边Developer settings下的OAuth Application --&gt; Register a new application，进入到填写相关信息页面。 12Authorization callback URL 一定要写自己Github Pages的URL.如：https://Yobe.github.io &emsp;&emsp;检查无误可正常使用后，即可部署到我们的 Github 上: 1$ hexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机术语-簇]]></title>
    <url>%2F2019%2F03%2F30%2F0006-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD-%E7%B0%87%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;数据存储在硬盘的时候都是以簇为单位，所以无论文件大小是多少，除非正好是簇大小的倍数，否则文件所占用的最后一个簇或多或少都会产生一些剩余的空间，且这些空间又不能给其它文件使用，即使这个文件只有0字节，也不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。 中文名 簇 外文名 CLUST 存储管理 最小单位 属 性 单位名称 本 意 “一群”、“一组” 解 释 一组扇区 &emsp;&emsp;图1-1 磁盘上的磁道扇区和簇： 磁盘上的磁道扇区和簇： &emsp;&emsp;微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇” &emsp;&emsp;一个文件通常存放在一个或多个簇里，但至少要单独占据一个“簇”。 也就是说两个文件不能存放在同一个簇中。 簇（CLUST）的本意就是“一群”、“一组”，即一组扇区(一个磁道可以分割成若干个大小相等的圆弧，叫扇区)的意思。因为扇区的单位太小，因此把它捆在一起，组成一个更大的单位更方便进行灵活管理。簇的大小通常是可以变化的，是由操作系统在所谓“（高级）格式化”时规定的，因此管理也更加灵活。 &emsp;&emsp;通俗地讲文件就好比是一个家庭，数据就是人，即家庭成员；所谓簇就是一些单元套房；扇区是组成这些单元套房的一个个大小相等的房间。一个家庭可能住在一套或多套单元房子里，但一套房子不能同时住进两个家庭的成员。 文件系统是操作系统与驱动器之间的接口，当操作系统请求从硬盘里读取一个文件时，会请求相应的文件系统（FAT 16/FAT32/NTFS）打开文件。扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 &emsp;&emsp;为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；如果文件实际大小小于一簇，它也要占一簇的空间。如果文件实际大小大于一簇，根据逻辑推算，那么该文件就要占两个簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。 &emsp;&emsp;一个簇只能容纳一个文件占用，即使这个文件只有0字节，也决不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本设置]]></title>
    <url>%2F2019%2F03%2F30%2F0005-Hexo%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Hexo+Github Page+个人域名”搭建个人专属博客]]></title>
    <url>%2F2019%2F03%2F30%2F0004-%E2%80%9CHexo%2BGithub_Page%2B%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E2%80%9D%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;使用 Hexo+Github我们快速的搭建自己的个人博客，整个过程下来我们几乎不需要什么金钱成本（在个人服务器上部署可选），所付出的仅仅是自己对于其的时间精力上的管理成本。而 Hexo 基于MakrDown 语法编辑页面，在书写方面我们将得到极大的便利。最后绑定自己的个人域名我们的博客访问过程将更加便利。 本文的操作环境为： Windows 10 64bit Hexo简介&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，我们可以非常方便快速地利用靓丽的主题生成自定义的静态网页。 Hexo的优缺点分析 优点 免费 - GitHub 快速 - Node运行环境、前端个人站点首选 简洁 - MarkDown 轻量 - 全部静态文件 支持导入WordPress等博客 不足 更换电脑不变 - 需重新安装环境 静态博客 - 不便于后期维护 多媒体管理不方便 Hexok工作原理&emsp;&emsp;hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。&emsp;&emsp;我们不需要将 Hexo 部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，也就是说我们可以几乎没有任何成本地搭建一个自己的个人博客。简而言之：hexo是个静态页面生成、上传的工具。 Hexo 环境搭建&emsp;&emsp;我们可以在服务器上或在自己的本地电脑上安装部署 Hexo，安装 Hexo 的过程非常简单，只需几分钟即可完成！ 安装前提&emsp;&emsp;在安装前，我们必须检查电脑中是否已安装下列应用程序，如果是第一次安装请先去对应的官网下载安装包： Node.js Git 安装Node.js&emsp;&emsp;Node.js的过程非常简单按照提示安装即可，打开cmd命令行，成功界面如下： 安装git&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。我们用 git 来管理自己的hexo博客文章，并上传到GitHub。&emsp;&emsp;git的过程非常简单按照提示安装即可，安装成功后我们在电脑上任何位置鼠标右键能够出现如下两个选择： 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 安装Hexo&emsp;&emsp;前面 Node.js 和 git 安装好后，现在我们就可以安装hexo了，我们先找到一个合适的位置（以后的博客文章都存放于此处再上传至服务器），然后创建一个文件夹如“blog” ，最后在命令行模式下定位当前目录到这个文件夹下（或者在这个文件夹下直接右键 “git bash Here” 打开）（或者在文件下的路径处输入 “cmd” 并回车）。gotocmd 1$ npm install -g hexo-cli &emsp;&emsp;初始化自己的 blog 文件夹（需要耐心等待） 1$ hexo init &emsp;&emsp;初始化完成后将会看到如下内容，即说明初始化成功： 1INFO Start blogging with Hexo! &emsp;&emsp;最后安装所需的组件： 1$ npm install &emsp;&emsp;万事具备！我们来开始首次体验 Hexo吧！输入下面的命令，将最后得到 Hexo 本地运行的地址复制到浏览器即可预览 demo： 1$ hexo g &amp;&amp; hexo s 假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p [端口号]”来改变端口号。&emsp;&emsp;在 Hexo 保持在本地运行的状态时 “hexo s”，我们对 Hexo 的任何更改都会立即被应用，只需刷新网页即可预览。 Github部分&emsp;&emsp;如果没有自己的 Github 账户，就先去 注册 自己的 Github 账户吧。注册完成并登录后，在 GitHub.com 中看到一个New repository，我们点击它以新建仓库。 &emsp;&emsp;接下来我们需要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。这里我是已经建过了所以会报错： 在Github中创建的与自己用户名相同的仓库，会被识别为 Github page 的展示默认主页（唯一的），而其他仓库则被是为普通项目。 修改配置使与 Github 仓库关联&emsp;&emsp;打开“blog”根目录下的”_config.yml”。需要修改的地方有：网站名，介绍，关键字（这部分自己取），url 即是“http://用户名.github.io“。 12345678910111213141516171819202122# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: YobeZhou # 网站名，默认为 Hexosubtitle:description: # 网站介绍keywords: # 网站关键字# author: John Doeauthor: 周岳标language: zh-Hans # 设置语言为汉语timezone:avatar: /images/touxiang.jpg # 头像# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: http://yoursite.comurl: YobeZhou.github.io # 你的网址，也为个人域名root: /permalink: :year/:month/:day/:title/permalink_defaults: &emsp;&emsp;但这些都不是必要的，必不可少的是将hexo与我们的Github P仓库关联起来。下面我们打开 Github 获取仓库地址, 点击头像 -&gt; Your profile &emsp;&emsp;点击查看对应的仓库（即为之前新建的 Github page 专用仓库），选择点击右上角的“Use ssh”之后再点击“Clone or download”，这样就复制好自己的仓库地址了：&emsp;&emsp;紧接着我们回到刚刚编辑的”_config.yml”文件中，搜索定位“deploy”所在位置，我获取到的仓库地址为：“git@github.com:YobeZhou/YobeZhou.github.io.git” ，这要填写在下面的“repo: ”中，请参考我的配置： 12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:YobeZhou/YobeZhou.github.io.git branch: master# branch: [branch] #published. branch: master# message: [message] &emsp;&emsp;至此,我们把hexo与我们的github仓库配置信息关联起来了，接下来我们要将这个配置实现起来，也就是hexo能登陆到我们的github Page上，并将更改的内容提交到对应的仓库中，然后我们访问的时候就可以看到提交的内容（博客）。 对语法格式要求严格，修改时请务必注意缩进对齐和空格个数。 配置GitHub SSH&emsp;&emsp;做完这最后一步，我们就可以将自己编写的文章上传到我们的github仓库中去了。 设置Git账户&emsp;&emsp;本机主机第一次git时，我们需要设置git的user name和user email&emsp;&emsp;首先打开”Git Bash Here”，输入以下内容： 12git config --global user.name &quot;xxxxxxx&quot;git conglfig --global user.email &quot;“xxxxxxxxx@xx.com&quot; 这里“xxx”替换成自己的GitHub用户名，邮箱替换成自己的GitHub邮箱。 生成SSH Key&emsp;&emsp;以下所有的操作都是在”Git Bash Here”中进行。&emsp;&emsp;输入ssh-keygen -t rsa”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\YourUserName.ssh）。 1ssh-keygen -t rsa &emsp;&emsp;生成SSH Key后输入以下命令来检查SSH配置文件是否已经生成: 12cd ~/.sshdir &emsp;&emsp;过程如下图所示，由于我这里之前已经生成过SSH Key所以会提示覆盖警告。 出现上面内容就说明成功生成”id_rsa”和”id_rsa.pub”两个文件，”id_rsa.pub”为公钥，”id_rsa”为私钥，它们都是隐藏文件。 添加SSH Key到GitHub上&emsp;&emsp;直接使用cat命令查看 “id_rsa.pub” 文件的内容，然后复制显示出来的所有内容备用： &emsp;&emsp;最后我们将公钥id_rsa.pub添加到GitHub上就可以了，首先登陆GitHub进入设置界面，进入”Settings”，如图所示： &emsp;&emsp;在”Setting”页面中，选择”SSH and GPG keys”选项：&emsp;&emsp;粘贴刚刚复制的SSH Key即可： &emsp;&emsp;最后，输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 &emsp;&emsp;到此为止，所有的配置都已经完成，万事具备，只欠东风。现在我们可以将自己的文章上传到自己的GitHub Page并通过外网随时随地访问了。 生成并部署！&emsp;&emsp;我们先回到之前新建的blog目录下，在文件下的路径处输入 cmd 并回车。&emsp;&emsp;我们先新建一篇博客，在cmd执行命令：hexo new post “博客名”。&emsp;&emsp;这时候在文件夹_posts目录下将会看到已经创建的文件。&emsp;&emsp;在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save &emsp;&emsp;拓展安装完成后，使用编辑器编好文章，就可以使用命令：hexo d -g，生成以及部署了： 12生成命令： hexo g部署命令： hexo d &emsp;&emsp;或者一键生成部署命令： 1$ hexo d -g &emsp;&emsp;显示出 “INFO Deploy done: git” 表示成功发布到github上！现在在浏览器上输入 “用户名.github.io” 即可访问自己的博客（你可以把这个链接发布给小伙伴啦） 绑定个人域名&emsp;&emsp;待续。。。 域名申请&emsp;&emsp;待续。。。 域名解析&emsp;&emsp;待续。。。 博客域名升级Https&emsp;&emsp;Github 从 2009 年开始支持自定义域名，从 2016 年开始 *.github.io 域名支持 Https，从2018年5月1日 GitHub Pages 上的自定义域名也开始支持 Https。&emsp;&emsp;Github 和 Let’s Encrypt 合作对建立在其上的自定义域名站点进行的证书颁发和认证。如果之前域名是做的 CNAME 或者 Alias 的 DNS 记录，则直接支持 Https 访问；如果是 A 记录做的解析，则需要更换 A 记录指向的 IP 地址为新的给定地址。最后在 Github Pages 仓库的设置页选中 “Enforce HTTPS” 选项即可。&emsp;&emsp;配置过程非常简单，设置完稍等几分钟再次访问自己的主页将会发现已经升级成功！ 后续学习&emsp;&emsp;本文中介绍完基于Hexo及Github page搭建专属的个人博客的详细方法。万事开头难，现在我们仅仅是把平台搭建好了，接下来我们应该趁热打铁继续深入学习探索，请参考我的其他文章：&emsp;&emsp;&emsp;&emsp;Hexo基本设置&emsp;&emsp;&emsp;&emsp;hexo使用技巧&emsp;&emsp;&emsp;&emsp;Hexo的专用编辑器-HexoEditor&emsp;&emsp;&emsp;&emsp;什么是Markdown？]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的专用编辑器-HexoEditor]]></title>
    <url>%2F2019%2F03%2F30%2F0003-Hexo%E7%9A%84%E4%B8%93%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8-HexoEditor%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&emsp;&emsp;’Hexo’ 是一款基于 ‘Node.js’ 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 ‘GitHub’ 和 ‘Coding’ 上，是搭建博客的首选框架。 由于 ‘Hexo’ 使用[markdown]语法的纯文本编辑，所以在写作的时候我们需要使用一些工具方能达到事半功倍的效果。 HexoEditor简介&emsp;&emsp;接下来要介绍给大家的 ‘HexoEditor’ 便是网上有人针对 ‘Hexo’ 做了优化的 ‘Markdown’ 编辑器，其使用 [Electron] 做框架，修改自 [Moeditor] 支持 Markdown，Latex 等。使用它我们可以为 ‘Hexo’ 下的博客更好的去书写内容。这是HexoEditor的开源项目地址。 快速下载安装&emsp;&emsp;在 ‘Github’ 项目中并没有给出，可安装的 ‘releases’ 版本，如想省去麻烦的安装过程请在下面的地址下载。&emsp;&emsp;下载地址： Windows x64: 1https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe Macx64: 1https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg 使用技巧 按键 方法 说明 Tab tabAdd 添加缩进 Shift - Tab tabSubtract 减少缩进 Ctrl - B toggleBlod 切换粗体 Ctrl - I toggleItalic 切换斜体 Ctrl - D toggleDelete 删除当前行 Ctrl - ` toggleComment 切换注解 Ctrl - L toggleUnOrderedList 切换无序列表 Ctrl - Alt - L toggleOrderedList 切换有序列表 Ctrl - ] toggleHeader 降级标题 Ctrl - [ toggleUnHeader 升级标题 Ctrl - = toggleBlockquote 增加引用 Ctrl - - toggleUnBlockquote 减少引用 Ctrl - U drawLink 添加超级链接 Ctrl - Alt - U drawImageLink 添加图片 Ctrl - T drawTable(row col) 添加表格(行 列) Ctrl - V pasteOriginContent 源内容粘贴 Shift - Ctrl - V pasteContent 智能粘贴 Alt - F formatTables 格式化表格 Ctrl - N 新建md文档 Ctrl - H 新建Hexo文档 Ctrl - O 打开md文件 Ctrl - S 保存文档 Shift - Ctrl - S 另存为 Alt - Ctrl - S 打开设置 Ctrl - W 切换写作模式 Ctrl - P 切换预览模式 Ctrl - R 切换阅读模式 提示: 在 Mac OS下, 请使用 Cmd 来代替 Ctrl .]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Markdown？]]></title>
    <url>%2F2019%2F03%2F30%2F0002-%E4%BB%80%E4%B9%88%E6%98%AFMarkdown%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Markdown的简单介绍&emsp;&emsp;&emsp;&emsp;Markdown 是由 ‘John Gruber’ 和 ‘Aaron Swartz’ 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 &emsp;&emsp;&emsp;&emsp;’Markdown’ 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 ‘Markdown’ 格式的文件。用 ‘Markdown’ 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 ‘Markdown’ 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 &emsp;&emsp;我们可以使用任何文本编辑器来写 ‘Markdown’ 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 ‘Markdown’ 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用技巧]]></title>
    <url>%2F2019%2F03%2F30%2F0001-Hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近开始使用Hexo写自己的个人博客，下面是对在使用过程中的一些技巧的总结。如果想要阅读官方的帮助文档请移步Hexo帮助文档。 写作篇&emsp;&emsp;Hexo使用[markdown]语法的纯文本编辑，文件后缀名.m ,文件默认存放在我们的站点目录下“/source/_post”文件夹下。 创建一篇新文章1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;Hexo有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而我们自定义的其他布局和 post 相同，都将储存到 “source/_posts” 文件夹。可以在命令中指定文章的布局（layout），若不指定[layout]则布局将默认为 post，默认布局可以通过修改 _config.yml 中的 default_layout 参数来指定。 部署&emsp;&emsp;部署前请确保网络连接，并且当前目录在hexo的根目录。 方法一&emsp;&emsp;Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1$ hexo deploy &emsp;&emsp;在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git &emsp;&emsp;还可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: 方法二1hexo d -g &emsp;&emsp;或hexo素质三连 123$ hexo clean$ hexo d$ hexo -g Hexo中添加本地图片和使用网络图片方法一 相对引用&emsp;&emsp;由于首页和主页相对图片位置不一致，网站首页和内页很可能仅有一处能正常加载。1.调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True2.在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹3.最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片： 1![Tip](/images/xx.jpg) 方法二 图床&emsp;&emsp;如SMMS图床无需注册&emsp;&emsp;以下是测试： 1https://i.loli.net/2018/02/09/5a7d6a402e15e.jpg &emsp;&emsp;注：请备份Delete Link,必要时访问此链接删除图片。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
