<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客主页文章展示实用设置]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E5%AE%9E%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[调整主页文章展示间距，最后添加1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 20px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: $grey-dim; background: none; border: none; border-bottom: 2px solid $grey-dim; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125; 修改为12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 5px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: Red; // http://cc.oulu.fi/~thu/jwz/Colours/545454.html background: none; border: none; border-bottom: 2px solid Red; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的三种地址及其转换]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址（以80x86微处理器为例）： 逻辑地址（logical address）：机器语言指令中用来指定一个操作数或者一条指令的地址，每一个逻辑地址由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。 线性地址（linear address 也叫做虚拟地址 virtual address）：是一个 32 位无符号整数，可以用来表达 4GB 的地址，通常用十六进制数表示。 物理地址（physical address）：用于内存芯片内的内存单元寻址，它们从微处理器的地址引脚发送到内存总线上的电信号对应。以上内容来自 《Understanding The Linux Kernel》 内存管理单元（Memory Management Unit, MMU）通过分段单元的把一个逻辑地址转换成线性地址，通过分页单元把线性地址转换成物理地址。 三种内存地址逻辑地址包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在 80X86 著名的分段结构中表现得尤为具体，它促使 MS-DOS 或 Windows 程序员把程序分成若干段。每一个逻辑地址都是有一个段和偏移量组成，偏移量指明了从段开始的地方到时间地址之间的距离。 线性地址（虚拟地址）是一个32位无符号整数，可以用来表示高达4GB的地址，也就是高达4294967296个内存单元。线性地址通常用十六进制数字表示。 物理地址用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。 内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址 分段与分页机制从 80286 开始，Intel 处理器以两种不同的方式执行地址转换，分别为实模式（real mode）和保护模式（protected mode）。下面我们就展开描述，在保护模式下，硬件的分段机制和分页机制 分段机制段选择符和段寄存器逻辑地址有两部分组成：一个段标识符和一个偏移量。短标识符是一个 16 位的字段，成为段选择符；偏移量是一个 32 位长的字段。为了快速找到段选择符，处理器提供了段寄存器用来存放段选择符，分别为 cs，ss，ds，es，fs，gs。其中有三个有专门的用途： cs：代码段寄存器，指向包含程序指令的段 ss：栈段寄存器，指向包含当前程序栈的段 ds：数据段寄存器，指向包含静态数据或者全局数据段其中，cs 含有一个两位的字段，用来指明当前的 CPU 特权等级（CPL），0 代表最高等级、3 代表最低等级。 Linux 只用到了 0 和 3，分别称为 内核态 和 用户态 段描述符每个段由一个 8 字节的段描述符表示，描述了段的基本信息。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）中。通常只会定义一个 GDT，每个进程除了放在 GDT 中的段以外，如还需要创建附加的段，就可以有自己的 LDT。GDT 在主存中的地址和大小存放在 gdtr 控制寄存器中，LDT 的地址和大小则存放在 ldtr 中。段描述符包涵以下关键字段： Base：包含段的首字节的线性地址Type：描述了段的类型特征和它的存取权限DPL：限制对这个段的存取权限，表示访问这个段的要求的最小 CPU 特权等级P：Segment-Present 标志，表明当前段是否在内存中。Linux 总是把这个标志设为 1，从来不会把整个段交换到磁盘上去 分段单元那么逻辑地址是如何转换到线性地址的呢？ 先检查段选择符的TI字段，已决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址） 从段选择符的index字段计算段描述符的地址，index字段的值乘以8，这个结果与gdtr或ldtr寄存器的内容相加 把逻辑地址的偏移量与段描述符base字段的值相加就得到了线性地址 第二个称为分页单元的硬件电路把线性地址转化成一个物理地址。12 分段单元 分页单元逻辑地址 ----&gt; 线性地址 ----&gt; 物理地址 实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间，与分段相比，Linux更喜欢使用分页方式。因为当所有进程使用相同的段寄存器值时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持很有限。在多处理系统中，所有与CPU都共享同一内存；这意味着RAM芯片可以由独立的CPU并发访问。因为在RAM芯片上的读或写操作必须串行的执行。因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间，作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含有一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如：双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。 仲裁器由硬件电路管理，是隐藏的。 快速访问分段机制如果每次都执行上述的过程，可能会比较耗时，因为 GDT 是存储在主存中的，每次都访问主存，可能会比较慢，所以为了提高逻辑地址到线性地址的转换速度，80x86 处理器提供了一组6个不可编程寄存器。每一个不可编程寄存器含有 8 个字节的段描述符，具体的值由相对应的段寄存器中的段描述符确定。每当一个段选择符被装入段寄存器，相对应的段描述符就由主存装入到对应的不可编程寄存器，这样就可以不需要上面三个过程中的前两个，就可以得到线性地址了。 分页机制页、页框和页表分页单元把线性地址转换成物理地址，其中的关键任务是把所请求的访问类型与线性地址的访问权限做对比。 页：为了更高效和更经济的管理内存，线性地址被分为以固定长度为单位的组，成为页。页内部连续的线性地址空间被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和对应的存取权限，而不用指定全部线性地址的存取权限。这里说页，同时指一组线性地址以及这组地址包含的数据 页框：分页单元把所有的 RAM 分成固定长度的页框，每一个页框包含一个页。页框是主存的一部分，因此也是一个存储区域。页和页框相比，前者只是一个数据块，可以存放在页框或者磁盘中。 页表：把线性地址映射到物理地址的数据结构成为页表，页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化 常规的分页从 80386 开始，Intel 处理器的页大小为 4KB。32 位的线性地址被分为 3 个域： Directory（目录）：最高 10 位 Table（页表）：中间 10 位 Offset（偏移量）：最低 12 位线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表成为页目录表，第二种转换表成为页表。 为什么需要两级呢？目的在于减少每个进程页表所需的 RAM 的数量。如果使用简单的一级页表，将需要高达 2^20 个表项来表示每个进程的页表，即时一个进程并不使用所有的地址，二级模式通过职位进程实际使用的那些虚拟内存区请求页表来减少内存容量。每个活动的进程必须有一个页目录，但是却没有必要马上为所有进程的所有页表都分配 RAM，只有在实际需要一个页表时候才给该页表分配 RAM。 页目录项和页表项的结构如下： Present 标志：为 1 则表示页在主存中；如果为 0 则表示不在内存中，如果执行一个地址转换的时候，所需的页表项或者页目录项中的该标志为 0，那么分页单元就把该线性地址存在在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。 包含页框物理地址最高 20 位的字段 Dirty：当对页框进行写操作时就设置这个标志 Read/Write 标志：含有页或者页表的存取权限 User/Supervisor：含有访问页或者页表所需的特权等级 了解了以上结构之后，我们看看如何从线性地址转换到物理地址的： 线性地址中的 Directory 字段决定页目录中的目录项，目录项指向适当的页表 线性地址中的 Table 字段又决定页表的页表项，页表项含有页所在页框的物理地址 线性地址中的 Offset 地段决定了页框内的相对位置，由于 offset 为 12 为，所以一页含有 4096 字节的数据 总结以上描述的为 80x86 微处理器硬件分页机制，不同架构的 64 位处理器分页机制，大体的思路就是将二级模式拓展为三级（ia64）或者四级（x86_64），以达到对更大范围寻址空间的支持。 笔记：16进制线性地址转换16进制的线性地址转化为地址的物理空间大小。如：0x00000000 - 0x08000000的物理空间大小为128MB 换算：0x08000000 === 134217728 (Bytes) 134217728(Bytes) / 1024 = 131072(KB) 131072(KB) / 1024 = 128(MB)]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>嵌入式</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提交搜索引擎收录（Google+Baidu）]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E6%8F%90%E4%BA%A4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%EF%BC%88Google-Baidu%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[递增与减运算符：++与--]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%80%92%E5%A2%9E%E4%B8%8E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%2B%2B%E4%B8%8E--%2F</url>
    <content type="text"><![CDATA[前言紧凑的代码让程序更为整洁，而且通常其生成的机器代码效率更高。 递增与递减运算符递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)： 1. &quot;++&quot;出现在其作用的变量前面---前缀模式(++a) 如：q = 2*++a; • 首先，a递增1； • 然后，2乘以a，并将结果赋给q 2. &quot;++&quot;出现在其作用的变量后面---后缀模式(a++) 如：q = 2*a++; • 首先，2乘以a，并将结果赋给q； • 然后，a递增1 同理可得： &quot;--&quot;出现在其作用的变量前面 ----&gt; 前缀模式(--a) &quot;--&quot;出现在其作用的变量后面 ----&gt; 后缀模式(a--)]]></content>
      <tags>
        <tag>C</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加Gitment评论系统]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言Hexo框架搭建好之后，默认的功能模块有限，因此很多模块需要我们自己去添加，对于我们的博客网站来说，没有评论系统怎么行呢？毕竟我们需要采集良言，及时发现文章的不足并且可以帮助仍有疑问的朋友解答问题。话不多说，我们开始搭建博客的评论系统吧。 Gitment评论系统Gitment简介Gitment 是基于 GitHub Issues 的评论系统，是 imsun 利用 github 上的 issues 做的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown&amp;GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。想了解具体效果，可以点击查看官方Demo Page:Gitment Demo。 注册OAuth Application首先我们先去 OAuth application 进行注册，申请一个 Github OAuth Application。填写参考如下： Application name: 博客名字 Homepage URL: 网站主页地址(这里我填写的是域名或github项目地址/index.html大部分的默认网页都是index.html) Application description: 描述，选填 Authorization callback URL: 填写域名或github项目地址 填写相关信息时注意在 Authorization callback URL 一项填自己的网站url：1https://username.github.io 填写完毕后点击 Register application 若创建成功则将跳转到另外一个界面，此时我们会得到一个 client ID 和一个 client secret，它们将被用于之后的用户登录。 修改 _config.yml我们需要在 Hexo 主题目录下编辑修改 _config.yml 配置文件。不同的主题的配置文件存放路径有所差别，下面以 netx 主题为例说明：1next主题的配置文件路径：&quot;/themes/next/_config.yml&quot; 打开配置文件后，我们搜索关键字“Gitment”将定位到配置位置。默认的配置内容为：1234567891011121314# Gitmentgitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 我们修改成自己的配置内容：123456789101112131415# 添加Gitment评论系统# Gitmentgitment: enable: true # 修改为 true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: 123456 # 填写自己的 github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: abcd123456abcd # 填写获取到的 client_id client_secret: abcd123456efg # 填写获取到的 client_secret proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 获取自己的 Github ID在浏览器中打开下面的地址，”Your github username”需要修改为自己的Github username:1https://api.github.com/users/"Your github username" 验证 在 Hexo 根目录输入：1$ hexo s 浏览器打开地址：1http://localhost:4000/ 浏览自己的一篇博客到最后，如果发现有评论界面则大功告成！如果没有应该时配置信息没写对，请检查自己的配置内容。 最后部署到我们的 Github 上:1$ hexo d -g]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机术语-簇]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD-%E7%B0%87%2F</url>
    <content type="text"><![CDATA[前言 数据存储在硬盘的时候都是以簇为单位，所以无论文件大小是多少，除非正好是簇大小的倍数，否则文件所占用的最后一个簇或多或少都会产生一些剩余的空间，且这些空间又不能给其它文件使用，即使这个文件只有0字节，也不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。 中文名 簇 外文名 CLUST 存储管理 最小单位 属 性 单位名称 本 意 “一群”、“一组” 解 释 一组扇区 微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇” 一个文件通常存放在一个或多个簇里，但至少要单独占据一个“簇”。 也就是说两个文件不能存放在同一个簇中。簇（CLUST）的本意就是“一群”、“一组”，即一组扇区(一个磁道可以分割成若干个大小相等的圆弧，叫扇区)的意思。因为扇区的单位太小，因此把它捆在一起，组成一个更大的单位更方便进行灵活管理。簇的大小通常是可以变化的，是由操作系统在所谓“（高级）格式化”时规定的，因此管理也更加灵活。 通俗地讲文件就好比是一个家庭，数据就是人，即家庭成员；所谓簇就是一些单元套房；扇区是组成这些单元套房的一个个大小相等的房间。一个家庭可能住在一套或多套单元房子里，但一套房子不能同时住进两个家庭的成员。 文件系统是操作系统与驱动器之间的接口，当操作系统请求从硬盘里读取一个文件时，会请求相应的文件系统（FAT 16/FAT32/NTFS）打开文件。扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；如果文件实际大小小于一簇，它也要占一簇的空间。如果文件实际大小大于一簇，根据逻辑推算，那么该文件就要占两个簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。 一个簇只能容纳一个文件占用，即使这个文件只有0字节，也决不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本设置]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Hexo+Github Page+个人域名”搭建个人专属博客]]></title>
    <url>%2F2019%2F03%2F30%2F%E2%80%9CHexo%2BGiuthub_Page-%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E2%80%9D%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言Hexo部分Hexo简介安装git安装nodejs安装HexoGithub部分Github创建个人仓库生成SSH并添加将Hexo部署到Github绑定个人域名域名申请域名解析博客域名升级HttpsGithub 从 2009 年开始支持自定义域名，从 2016 年开始 *.github.io 域名支持 Https，从2018年5月14日 GitHub Pages 上的自定义域名也开始支持 Https。Github 和 Let’s Encrypt 合作对建立在其上的自定义域名站点进行的证书颁发和认证。如果之前域名是做的 CNAME 或者 Alias 的 DNS 记录，则直接支持 Https 访问；如果是 A 记录做的解析，则需要更换 A 记录指向的 IP 地址为新的给定地址。最后在 Github Pages 仓库的设置页选中 “Enforce HTTPS” 选项即可。配置过程非常简单，设置完稍等几分钟再次访问自己的主页将会发现已经升级成功！ 后续学习本文中介绍完基于Hexo及Github page搭建专属的个人博客的详细方法。万事开头难，现在我们仅仅是把平台搭建好了，接下来我们应该趁热打铁继续深入学习探索，请参考我的其他文章：[Hexo基本设置][hexo使用技巧][Hexo的专用编辑器-HexoEditor][什么是Markdown？]]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的专用编辑器-HexoEditor]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E7%9A%84%E4%B8%93%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8-HexoEditor%2F</url>
    <content type="text"><![CDATA[前言‘Hexo’ 是一款基于 ‘Node.js’ 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 ‘GitHub’ 和 ‘Coding’ 上，是搭建博客的首选框架。 由于 ‘Hexo’ 使用[markdown]语法的纯文本编辑，所以在写作的时候我们需要使用一些工具方能达到事半功倍的效果。 HexoEditor简介接下来要介绍给大家的 ‘HexoEditor’ 便是网上有人针对 ‘Hexo’ 做了优化的 ‘Markdown’ 编辑器，其使用 [Electron] 做框架，修改自 [Moeditor] 支持 Markdown，Latex 等。使用它我们可以为 ‘Hexo’ 下的博客更好的去书写内容。这是HexoEditor的开源项目地址。 快速下载安装在 ‘Github’ 项目中并没有给出，可安装的 ‘releases’ 版本，如想省去麻烦的安装过程请在下面的地址下载。下载地址： Windows x64: https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe Macx64: https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg 使用技巧 按键 方法 说明 Tab tabAdd 添加缩进 Shift - Tab tabSubtract 减少缩进 Ctrl - B toggleBlod 切换粗体 Ctrl - I toggleItalic 切换斜体 Ctrl - D toggleDelete 删除当前行 Ctrl - ` toggleComment 切换注解 Ctrl - L toggleUnOrderedList 切换无序列表 Ctrl - Alt - L toggleOrderedList 切换有序列表 Ctrl - ] toggleHeader 降级标题 Ctrl - [ toggleUnHeader 升级标题 Ctrl - = toggleBlockquote 增加引用 Ctrl - - toggleUnBlockquote 减少引用 Ctrl - U drawLink 添加超级链接 Ctrl - Alt - U drawImageLink 添加图片 Ctrl - T drawTable(row col) 添加表格(行 列) Ctrl - V pasteOriginContent 源内容粘贴 Shift - Ctrl - V pasteContent 智能粘贴 Alt - F formatTables 格式化表格 Ctrl - N 新建md文档 Ctrl - H 新建Hexo文档 Ctrl - O 打开md文件 Ctrl - S 保存文档 Shift - Ctrl - S 另存为 Alt - Ctrl - S 打开设置 Ctrl - W 切换写作模式 Ctrl - P 切换预览模式 Ctrl - R 切换阅读模式 提示: 在 Mac OS下, 请使用 Cmd 来代替 Ctrl .]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Markdown？]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%BB%80%E4%B9%88%E6%98%AFMarkdown%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Markdown的简单介绍 Markdown 是由 ‘John Gruber’ 和 ‘Aaron Swartz’ 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 ‘Markdown’ 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 ‘Markdown’ 格式的文件。用 ‘Markdown’ 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 ‘Markdown’ 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 我们可以使用任何文本编辑器来写 ‘Markdown’ 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 ‘Markdown’ 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用技巧]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言最近开始使用Hexo写自己的个人博客，下面是对在使用过程中的一些技巧的总结。如果想要阅读官方的帮助文档请移步Hexo帮助文档。 写作篇Hexo使用[markdown]语法的纯文本编辑，文件后缀名.m ,文件默认存放在我们的站点目录下“/source/_post”文件夹下。 创建一篇新文章1$ hexo new [layout] &lt;title&gt; Hexo有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而我们自定义的其他布局和 post 相同，都将储存到 “source/_posts” 文件夹。可以在命令中指定文章的布局（layout），若不指定[layout]则布局将默认为 post，默认布局可以通过修改 _config.yml 中的 default_layout 参数来指定。 部署部署前请确保网络连接，并且当前目录在hexo的根目录。 方法一Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git 还可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。12345deploy:- type: git repo:- type: heroku repo: 方法二1hexo d -g 或hexo素质三连123$ hexo clean$ hexo d$ hexo -g Hexo中添加本地图片和使用网络图片方法一 相对引用由于首页和主页相对图片位置不一致，网站首页和内页很可能仅有一处能正常加载。1.调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True2.在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹3.最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片：1![Tip](/images/xx.jpg) 方法二 图床如SMMS图床无需注册以下是测试：1https://i.loli.net/2018/02/09/5a7d6a402e15e.jpg 注：请备份Delete Link,必要时访问此链接删除图片。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
