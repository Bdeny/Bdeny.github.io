<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解Makefile及典型的Makefile示例]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%90%86%E8%A7%A3Makefile%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%9A%84Makefile%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考GNU Make Manual Makefile到底是什么&emsp;&emsp;一个正式的软件工程中源文件可能数不胜数，并且源文件按类型、功能、模块等分别放在不同的目录下，在我们使用使用keil, Visual Studio, avr等工具开发程序时点点鼠标就可以编译了，但是对于其中的内部机制是什么？是怎么组织管理程序的？怎么决定编译哪一个文件？我们一概不知，因为IDE帮我们屏蔽了这方面的细节，让我们得以安心的投入到编码中。但是如果真要我们手工处理的话，那么我们每次都在命令行执行例如这样的指令： gcc a.c b.c c.c -o test ，显然是非常影响效率的！而Makefile是我们可以信赖的好伙伴，它定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&emsp;&emsp;综上所述，Makefile 就是一个用来帮助我们编译的工具，和 Windows 下的 IDE 类似，只不过 Makefile 需要我们自己动手编写，一个好的 Makefile 可以极大的提升工作的效率。 Makefile的核心—规则12345678910#######################################target ... : prerequisites ... command...##############################################################################目标 : 依赖1 依赖2 ...[TAB]命令...####################################### target 就是我们编译文件要生成的目标; prerequisites 就是我们编译文件需要的依赖; command 就是用依赖生成目标所需要执行的命令（注意需用tab开始）。 当”目标文件”[不存在], 或某个依赖文件比目标文件[“新”],则: 执行”命令” &emsp;&emsp;比如我们平时使用的 gcc a.c b.c -o test&emsp;&emsp;这里的 test 就是我们要生成的目标， a.c 就是我们生成目标需要的依赖，而 gcc a.c -o test 则是命令。将这行命令用 Makefile 的方式来写就是：12test:a.c b.c gcc a.c b.c -o test 再次强调：Makefile 中的命令必须用 tab 开始，不能是空格。 &emsp;&emsp;Makefile 可以自动推导文件以及文件依赖关系后面的命令，在后面的示例中我们可以看到目标的依赖基本都是 .o 文件而不是 .c 文件，原因正是 Makefile 强大的自动推导功能。&emsp;&emsp;通常 Makefile 中还会有一个名为 clean 的目标，用来清除编译后产生的各种文件。一般情况下 Makefile 会根据依赖和目标的新旧来决定是否编译，但是如果不小心修改了目标而造成目标比依赖新的情况的话，Makefile 会因为目标比依赖新而忽略这个目标下的命令，这个时候显然会造成问题，一个解决的办法就是使用 clean 这样的目标来清除编译后的文件，然后 make 重新编译。&emsp;&emsp;clean 这个目标有点特殊，他是不需要依赖的，因此也叫伪目标。一般使用方式如下：12clean: rm *.o test -f Makefile 使用&emsp;&emsp;make 命令执行时，需要一个 Makefile 文件(文件名为 Makefile 、 makefile 、 *.mk )，以告诉 make 命令需要怎么样的去编译和链接程序。执行时只用在命令行输入 make ， Makefile 就会自动执行第一个目标下的命令。而是否执行命令则取决于依赖，如果没有目标文件或是目标后的依赖文件比目标文件新，Makefile 就会执行其下面的命令： Makefile 中使用 # 注释,只注释 # 后的一行。 Makefile 中引用其他 Makefile，用 include 指令来引用。引用的效果就是原地展开。 Makefile 命令前面加 @ 来静默执行，即执行命令时不打印命令本身。 Makefile 语法Makefile 变量&emsp;&emsp;Makefile 中的变量和 shell 脚本中非常相似，都是直接定义，不需要类型，引用时用 $(var) 。&emsp;&emsp;伪目标（ .PHONY ）：伪目标形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。 Makefile 中的几种变量赋值运算符 运算符 说明 = 延时变量赋值，可以被赋值为变量的值，解析时取这个变量最后的值。 := 即时变量赋值，被赋值为变量时解析为变量在这行语句时的值，即变量如果后面改变这里的值也不改变。 ?= 延时变量赋值, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句。 += 附加, 它是即时变量还是延时变量取决于前面的定义。 关于 = 和 := ，比如 B=$(A)bcd ，那么 B 的值取决于变量 A 最后一次被赋值的值，即使 A 在 B 之后再次被赋值，变量 B 仍然会随着 A 的改变而改变。而 := 则只看之前 A 最后被赋值的值。 &emsp;&emsp;即时变量也叫简单变量，即时变量与延时变量的理解示例：12A := xxx # A的值即刻确定，在定义时即确定B = xxx # B的值使用到时才确定 Makefile 中的自动变量&emsp;&emsp;自动变量是 Makefile 中提前预定义的特殊意义的符号，类似 C 语言中的宏 __LINE__ 等，提前被定义并被赋予了特殊含义。 符号 说明 $@ 目标文件名，比如上文的 test 。 $&lt; 第一个依赖文件名，如果依赖目标是以模式（即“ % “）定义的，那么” $&lt; “将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 $^ 依赖的文件集合，比如上文的 a.c b.c 。 &emsp;&emsp;此外还可以向 Makefile 传参， $# 存放传递参数个数， $1 存放第一个参数的字符串， $2 存放第二个参数的字符串…… Makefile 的环境变量 Makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。 环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。 其他&emsp;&emsp;通配符：比如在当前文件夹下有 1.c 2.c 12.c test.c 1.h 。 通配符 说明 % 若干个任意字符，和 * 很相似，但是 % 一般只用于规则描述中，又叫做规则通配符。 * 若干个任意字符 *.c 匹配 1.c 2.c 12.c test.c 。 ? 1个任意字符 ?.c 匹配 1.c 2.c 。 [] 将 [] 中的字符依次去和外面的结合匹配 [12].c 匹配 1.c 2.c 。 $@ 表示目标 $&lt; 表示第1个依赖文件 $^ 表示所有依赖文件 &emsp;&emsp;Makefile 与 shell 脚本非常相似，shell 脚本中能使用的 Makefile 也能使用，比如 awk 等工具。 Makefile 的函数123456789$(foreach var,list,text)$(filter pattern...,text) # 在text中取出符合patten格式的值$(filter-out pattern...,text) # 在text中取出不符合patten格式的值$(wildcard pattern) # pattern定义了文件名的格式, # wildcard取出其中存在的文件$(patsubst pattern,replacement,$(var)) # 从列表中取出每一个值 # 如果符合pattern # 则替换为replacement Makefile 典型示例&emsp;&emsp;请移步我的GitHub仓库。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是BootLoader？]]></title>
    <url>%2F2019%2F04%2F21%2F%E4%BB%80%E4%B9%88%E6%98%AFBootloader%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoader 可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。&emsp;&emsp;Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。对于嵌入式系统，Bootloader是基于特定硬件平台来实现的。因此，几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。&emsp;&emsp;在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。 操作模式 自启动模式：在这种模式下，bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。 交互模式：在这种模式下，目标机上的bootloader将通过串口或网络等通行手段从开发主机（Host）上下载内核映像等到RAM中。可以被bootloader写到目标机上的固态存储媒质中，或者直接进入系统的引导。也可以通过串口接收用户的命令。 启动过程&emsp;&emsp;Bootloader启动大多数都分为两个阶段。第一阶段主要包含依赖于CPU的体系结构硬件初始化的代码，通常都用汇编语言来实现。这个阶段的任务有： 1. 基本的硬件设备初始化（屏蔽所有的中断、关闭处理器内部指令/数据Cache等）。 2. 为第二阶段准备RAM空间。 3. 如果是从某个固态存储媒质中，则复制Bootloader的第二阶段代码到RAM。 4. 设置堆栈。 5. 跳转到第二阶段的C程序入口点。 &emsp;&emsp;第二阶段通常用C语言完成，以便实现更复杂的功能，也使程序有更好的可读性和可移植性。这个阶段的任务有： 1. 初始化本阶段要使用到的硬件设备。 2. 检测系统内存映射。 3. 将内核映像和根文件系统映像从Flash读到RAM。 4. 为内核设置启动参数。 5. 调用内核。 在第一阶段中为什么要关闭Cache？通常使用Cache以及写缓冲是为了提高系统性能，但由于Cache的使用可能改变访问主存的数量、类型和时间，因此Bootloader通常是不需要的。 常见的BootloaderBootLoader可以是U-Boot\Eboot\vivi等待其他一切方式。BootLoader是所有boot的总称。 ARMboot&emsp;&emsp;ARMboot是一个ARM平台的开源固件项目，它特别基于PPCBoot，一个为PowerPC平台上的系统提供类似功能的姊妹项目。鉴于对PPCBoot的严重依赖性，已经与PPCBoot项目合并，新的项目为U-Boot。&emsp;&emsp;ARMboot发布的最后版本为ARMboot-1.1.0，2002年ARMboot终止了维护。 U-Boot&emsp;&emsp;U-Boot是由开源项目PPCBoot发展起来的，ARMboot并入了PPCBoot，和其他一些arch的Loader合称U-Boot。2002年12月17日第一个版本U-Boot-0.2.0发布，同时PPCBoot和ARMboot停止维护。&emsp;&emsp;U-Boot支持的处理器构架包括PowerPC (MPC5xx，MPC8xx，MPC82xx，MPC7xx，MPC74xx，4xx)， ARM （ARM7，ARM9，StrongARM，Xscale），MIPS (4Kc，5Kc)，x86等等， U-Boot（Universal Bootloader）从名字就可以看出，它是在GPL下资源代码最完整的一个通用Boot Loader。&emsp;&emsp;U-Boot提供两种操作模式：启动加载（Boot loading）模式和下载（Downloading）模式,并具有大型Boot Loader的全部功能。&emsp;&emsp;U-Boot的功能是如此之强大，涵盖了绝大部分处理器构架，提供大量外设驱动，支持多个文件系统，附带调试、脚本、引导等工具，特别支持Linux,为板级移植做了大量的工作。U-Boot1.1.1版本特别包含了对SA1100和44B0芯片的移植，所以44B0移植主要是针对Board 的移植，包括FLASH、内存配置以及串口波特率等等。U-Boot的完整功能性和后续不断的支持，使系统的升级维护变得十分方便。 Eboot&emsp;&emsp;是使用网口的意思，是微软提供的一般是wince下的bootloader，但是经过修改也可以兼容运行在其他OS下，如linux。如果直接说eboot也是bootloader”这样说不够严谨，对于基于norflash的bootloader来说是对的，如果bootloader是从nandflash开始执行就不对了，但我们所说的bootloader=nboot+eboot，其中nboot负责把eboot加载到SDRAM指定的内存处，然后运行eboot，接着eboot会把NK加载到SDRAM中并且执行。 vivi&emsp;&emsp;vivi是韩国mizi 公司开发的bootloader, 适用于ARM9处理器。Vivi有两种工作模式：启动加载模式和下载模式。启动加载模式可以在一段时间后（这个时间可更改）自行启动linux内核，这是vivi的默认模式。在下载模式下，vivi为用户提供一个命令行接口，通过接口可以使用vivi提供的一些命令 Redboot&emsp;&emsp;Redboot是Redhat公司随eCos发布的一个BOOT方案，是一个开源项目。&emsp;&emsp;Redboot支持的处理器构架有ARM，MIPS，MN10300，PowerPC， Renesas SHx，v850，x86等，是一个完善的嵌入式系统Boot Loader。&emsp;&emsp;Redboot是在ECOS的基础上剥离出来的，继承了ECOS的简洁、轻巧、可灵活配置、稳定可靠等品质优点。它可以使用X-modem或Y-modem协议经由串口下载，也可以经由以太网口通过BOOTP/DHCP服务获得IP参数，使用TFTP方式下载程序映像文件，常用于调试支持和系统初始化（Flash下载更新和网络启动）。Redboot可以通过串口和以太网口与GDB进行通信，调试应用程序，甚至能中断被GDB运行的应用程序。Redboot为管理FLASH映像，映像下载，Redboot配置以及其他如串口、以太网口提供了一个交互式命令行接口，自动启动后，REDBOOT用来从TFTP服务器或者从Flash下载映像文件加载系统的引导脚本文件保存在Flash上。&emsp;&emsp;Redboot是标准的嵌入式调试和引导解决方案，支持几乎所有的处理器构架以及大量的外围硬件接口，并且还在不断地完善过程中。 Blob&emsp;&emsp;Blob(Boot Loader Object)是由Jan-Derk Bakker and Erik Mouw发布的，是专门为StrongARM 构架下的LART设计的Boot Loader。&emsp;&emsp;Blob也提供两种工作模式，在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 Blob 切换到下载模式。如果在 10 秒内没有用户按键，则 Blob 继续启动 Linux内核。&emsp;&emsp;Blob功能比较齐全，代码较少，比较适合做修改移植，用来引导Liunx，目前大部分S3C44B0板都用Blob修改移植后来加载uClinux。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件描述符、文件指针和文件偏移量之甄别]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%8B%E7%94%84%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;在 C 程序中,文件由文件指针或者文件描述符表示。 文件描述符&emsp;&emsp;在 linux 系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，也就是说每一个文件描述符都是一个问文件的索引，当然也可以出现多个不同的文件描述符索引同一个文件。Linux标准文件描述符: 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误输出 文件指针&emsp;&emsp;C语言中使用文件指针做为 I/O 的句柄。文件指针指向进程用户区中的一个被称为 FILE 结构的数据结构。 FILE 结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在 Windows 系统上，文件描述符被称作文件句柄）。 文件偏移量&emsp;&emsp;每个打开的文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下.so、.ko、.a、.o文件的区别]]></title>
    <url>%2F2019%2F04%2F16%2FLinux%E4%B8%8B-so%E3%80%81-ko%E3%80%81-a%E3%80%81.o%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&emsp;&emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是linux/unix的哲学核心思想。这句话中的“文件”不仅仅是我们通常所指的文件，在linux和unix中它代表的更为宽泛。目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”。然而有些文件对于在嵌入式Linux中是比较值得注意的，那就是.so、.ko、.a文件，我们可能会在有意或无意间遇到过，若是初次见面它们很容易就把我们迷惑了，下面概要的说明下这几者的区别。 .so文件&emsp;&emsp;&emsp;&emsp;.so(share object)文件是用户层的动态链接库，相当于Windows的.dll文件，用于用户层的动态链接使用，内核态的代码同样不能直接访问。 .ko文件&emsp;&emsp;&emsp;&emsp;.ko(kernel object)文件是内核态的动态链接库，用于内核态的动态链接使用，可以用于内核之间的模块相互调用。用户态的代码不可直接调用内核态的代码，但是可以通过其他方式进行通信。 .a文件&emsp;&emsp;&emsp;&emsp;.a文件是用于静态链接时，使用的静态库。 .o文件&emsp;&emsp;&emsp;&emsp;.o文件是目标文件，编译生成,相当于windows中的.obj文件。.a文件就是由.o文件打包生成的。]]></content>
      <categories>
        <category>嵌入式Linux</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>LInux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是操作系统？]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。&emsp;&emsp;操作系统是管理计算机硬件的软件。硬件必须提供适当机制，以确保计算机系统的正确运行并且防止用户程序干扰系统的正常运行。&emsp;&emsp;操作系统可以采用许多不同的组织方式，因此内部结构也有很大差异。设计新的操作系统的任务是艰巨的。在设计开始之前，明确界定设计系统的目标是非常重要的。这些目标是选择不回算法和策略的基础。&emsp;&emsp;操作系统既庞大又复杂，因此应分块构造。每块都应具有描述明确的系统部分，并且具有严格定义的输入、输出和功能。 有一个重点我们是必须get住的，那就是：操作系统（operating system）是管理计算机硬件的程序。也就是说操作系统是只是一个管理、控制的程序，它为其他应用程序提供基础，并且从当计算机用户和计算机硬件的中介，所以我们平时所作的所有操作都是在操作系统这个程序下进行的。 什么是操作系统&emsp;&emsp;操作系统的存在是因为其提供了合理的方式来解决创建可用计算系统的问题，计算机系统的根本目的是，执行用户程序帮助用户解决实际问题。&emsp;&emsp;操作系统是一直运行在计算机上的程序（通常称为内核（kernel））。除了内核外还有其他两类程序：系统程序（system program）和应用程序。前者是与系统运行息息相关的程序（其保证着系统的正常运作），但不是内核的一部分，后者是与系统运行无关的其他应用程序（可以理解为用户程序）。 操作系统的功能&emsp;&emsp;计算机操作系统可粗分了四个组件：硬件、操作系统、应用程序和用户。 硬件（hardware）为我们的系统提供基本的计算资源； 应用程序规定了用户为解决计算问题而使用硬件资源的方式； 而操作系统决定应用程序使用资源的方式和权限。 至此，计算机系统也可分为硬件、软件和数据，当计算机系统运行时，操作系统提供正确的手段来让这些资源得到合理的利用。 正如刚才强调的，至此，我们可以更形象的将操作系统理解为：操作系统类似于政府，其本身不能实现任何有用的功能，而是为其他程序的执行提供一个合理安全的环境。 用户视角&emsp;&emsp;计算机的用户视角因使用界面的不同而不同。&emsp;&emsp;大多数的计算机用户的都是普通用户，即PC又显示器、键盘、鼠标和主机。这样的计算机是为了让单个用户单独使用资源，目的是优化用户进行的工作（或娱乐）。因此在对于这类群体，操作系统的设计的主要目的是为了用户的使用便利，而次要的是性能，不在乎资源的共享和利用。当然其中也包括我们程序员这一群体。&emsp;&emsp;接着就是服务器了，对于这个视角的用户面对的是与大型机或小型机相连的终端前。这类系统的设计目标是优化资源的利用效率，确保所有的CPU时间、内存和I/O都能得到有效的使用，并且确保没有用户使用操作限制以外的资源。&emsp;&emsp;与我们日常工作接触的是这样一种情况，我们处于工作站内，这类工作站与其他工作站和服务器相连。这时我们作为用户不仅可以使用专用资源，而且可以使用网络和服务器的共享资源，如：文件，计算和打印服务等。这类的操作系统的设计便是上述两种情况的折中方案，即考虑资源利用率与便利性。 系统视角&emsp;&emsp;从计算机的是视角来看，操作系统是与硬件紧密相连的程序。因此，可将操作系统看作资源分配器。操作系统管理着（如：CPU时间、内存空间、文件存储空间、I/O设备等）这些资源，当面对许多甚至冲突的资源请求时，操作系统应该考虑如何为各个程序和用户分配资源，以便计算机能有效且公平地运行。 说到资源请求，此时操作系统是一个控制程序，它特别注重I/O设备的运行和控制，其管理着用户程序的执行，以防止计算机资源的错误或不当使用。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）]]></title>
    <url>%2F2019%2F04%2F07%2FArduino%E6%8E%A7%E5%88%B6ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的控制需要有精确到微秒级PWM；然而Linux系统很繁忙，最多只能达到毫秒级别的控制，所以对于安装了基于ARM架构的Debian的树莓派达不到我们要求的精确控制。由此自然联想到了使用单片机进行辅助控制，而其中使用Arduino最为简单，因此最终选择Arduino作为项目的辅助控制外设模块。 项目简介&emsp;&emsp;本文实现了对五线四相八拍步进电机（28BYJ8）的较为精确的控制，同时加入了EEPROM记录的功能，在运行过程中能记录步进电机目前的位置，在意外掉电重启后能定位自身所处角度并恢复到设定的位置。 硬件模块&emsp;&emsp;步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲：当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。我们可以通过控制脉冲个来控制角位移量，从而达到准确定位的目的；同时亦可通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。 &emsp;&emsp;步进电机28BYJ48型四相八拍电机，电压为DC5V—DC12V。当对步进电机施加一系列连续不断的控制脉冲时，它可以连续不断地转动。每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的通电方式有单（单相绕组通电）四拍（A-B-C-D-A…），双（双相绕组通电）四拍（AB-BC-CD-DA-AB-…），八拍（A-AB-B-BC-C-CD-D-DA-A…）12uchar code CCW[8]=&#123;0x08,0x0c,0x04,0x06,0x02,0x03,0x01,0x09&#125;; //逆时钟旋转相序表uchar code CW[8]=&#123;0x09,0x01,0x03,0x02,0x06,0x04,0x0c,0x08&#125;; //正时钟旋转相序表 &emsp;&emsp;五线四相八拍步进电机（28BYJ8）： &emsp;&emsp;ULN2003驱动模块： &emsp;&emsp;全局概览： 项目代码&emsp;&emsp;详细代码及更多内容请参考我在GitHub仓库中的项目。]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题]]></title>
    <url>%2F2019%2F04%2F06%2FPython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3TensorFlow%E4%B8%AD%E7%9A%84OpenCV%E8%A7%86%E9%A2%91%E6%B5%81%E8%AF%BB%E5%8F%96%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的 read() 函数时发现其数据处理与数据产生的速度跟不上而导致延迟非常高，甚至内存溢出，因此开始思考解决措施。1retval, image = cv.VideoCapture.read([, image]) &emsp;&emsp;这是因为OpenCV读取视频流时，数据处理程序需要消耗的CPU时间过于长（不同硬件配置情况不可一概而论），而VideoCapture的read是按帧队列读取且先进先出，最后导致视频帧数据产生的速度与读取、处理速度不平衡，所以出现了上面所说的问题。由此联想到我们可以试图将需要读取视频数据和处理视频数据的过程分开处理，从而解决延迟问题。 思路分析&emsp;&emsp;我们可以使用多进程或多线程将读取视频数据和处理视频数据的过程分开处理，但是由于实时视频处理属于CPU密集型任务，多线程的优势发挥不出来，因此我们选择多进程方式。 所用到的库&emsp;&emsp;实现多进程所用到的库：1234import osimport cv2import gcfrom multiprocessing import Process, Manager &emsp;&emsp;两个子进程：12write()read() 在两个子进程中传递参数 multiprocessing中有Quaue、SimpleQuaue等进程间传参类，以及Manager统领全局。 使用Manager我们可以在进程键传递字典、列表灯Python原生数据类型 Quaue时严格的数据结构队列类型 在读取进程中得到最新的视频帧数据 首先 VideoCapture 是队列，先进先出。因此我们需要将其转换为压栈存储视频帧数据，才能达到后进先出而获取最新的视频帧数据，因此不能使用Quaue来传递参数。 为了达到压栈的效果，我们可以使用Python的列表，其append与pop操作可以达到模拟压栈的效果。因此，我们可以使用 multiprocessing.Manager.list 进行进程间传参类型最为理想不过。 清理传参栈&emsp;&emsp;由于压栈频率肯定是要比出栈频率高的，时间一长就会在栈中积累大量无法出栈的视频帧，会导致程序崩溃，因此我们需要考虑传参栈自动清理的问题，我们需要一个自动清理的机制： 我们可以设定传参栈的容量，每当达到这个容量时就直接把栈清空，再利用gc库手动发起一次python垃圾回收，这样就不会导致严重的内存溢出和程序崩溃。 实现代码&emsp;&emsp;综上所述，实际上这个程序就是把VideoCapture的队列读取改成了栈读取。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170# -*- coding: UTF-8 -*-# Import packagesimport osimport cv2import numpy as npimport tensorflow as tfimport sysimport gcfrom multiprocessing import Process, Manager# Import utilitesfrom utils import label_map_utilfrom utils import visualization_utils as vis_util# 向共享缓冲栈中写入数据:def write(stack, cam, top: int) -&gt; None: """ :param cam: 摄像头参数 :param stack: Manager.list对象 :param top: 缓冲栈容量 :return: None """ print('Process to write: %s' % os.getpid()) video = cv2.VideoCapture(cam) # 可以通过该地址查看属性设置的帮助官方文档： # https://docs.opencv.org/master/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d ret = video.set(3,640) ret = video.set(4,480) # 利用 'cv.VideoCapture.get(propId)' 查询指定属性的值。查询VideoCapture实例使用的后端不支持的属性时返回值0 。 # 5 -- 查看当前帧速率 retval = video.get(5) print (cam) print(retval) while(video.isOpened()): ret, img = video.read() if ret: stack.append(img) # 每到一定容量清空一次缓冲栈 # 利用gc库，手动清理内存垃圾，防止内存溢出 if len(stack) &gt;= top: del stack[:] gc.collect() # Press 'q' to quit if cv2.waitKey(1) == ord('q'): break # Clean up video.release() cv2.destroyAllWindows()# 在缓冲栈中读取数据:def read(stack) -&gt; None: print('Process to read: %s' % os.getpid()) # Name of the directory containing the object detection module we're using MODEL_NAME = 'inference_graph' # Grab path to current working directory CWD_PATH = os.getcwd() # Path to frozen detection graph .pb file, which contains the model that is used # for object detection. PATH_TO_CKPT = os.path.join(CWD_PATH,MODEL_NAME,'frozen_inference_graph.pb') # Path to label map file PATH_TO_LABELS = os.path.join(CWD_PATH,'training','labelmap.pbtxt') # Number of classes the object detector can identify NUM_CLASSES = 56 ## Load the label map. # Label maps map indices to category names, so that when our convolution # network predicts `5`, we know that this corresponds to `king`. # Here we use internal utility functions, but anything that returns a # dictionary mapping integers to appropriate string labels would be fine label_map = label_map_util.load_labelmap(PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) # Load the Tensorflow model into memory. detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') sess = tf.Session(graph=detection_graph) # Define input and output tensors (i.e. data) for the object detection classifier # Input tensor is the image image_tensor = detection_graph.get_tensor_by_name('image_tensor:0') # Output tensors are the detection boxes, scores, and classes # Each box represents a part of the image where a particular object was detected detection_boxes = detection_graph.get_tensor_by_name('detection_boxes:0') # Each score represents level of confidence for each of the objects. # The score is shown on the result image, together with the class label. detection_scores = detection_graph.get_tensor_by_name('detection_scores:0') detection_classes = detection_graph.get_tensor_by_name('detection_classes:0') # Number of objects detected num_detections = detection_graph.get_tensor_by_name('num_detections:0') while(True): if len(stack) != 0: # Acquire frame and expand frame dimensions to have shape: [1, None, None, 3] # i.e. a single-column array, where each item in the column has the pixel RGB value frame = stack.pop() frame_expanded = np.expand_dims(frame, axis=0) # Perform the actual detection by running the model with the image as input (boxes, scores, classes, num) = sess.run( [detection_boxes, detection_scores, detection_classes, num_detections], feed_dict=&#123;image_tensor: frame_expanded&#125;) # Draw the results of the detection (aka 'visulaize the results') # visualize boxes and labels on image array image,tablename = vis_util.my_visualize_boxes_and_labels_on_image_array( frame, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8, min_score_thresh=0.60) # All the results have been drawn on the frame, so it's time to display it. cv2.imshow('Object detector', frame) # 在控制台上打印识别结果 print (tablename) # Press 'q' to quit if cv2.waitKey(1) == ord('q'): breakif __name__ == '__main__': print(tf.__version__) # This is needed since the notebook is stored in the object_detection folder. sys.path.append("..") # Initialize webcam feed url = 'http://192.168.0.125:8081/' # 父进程创建缓冲栈，并传给各个子进程： q = Manager().list() pw = Process(target=write, args=(q, url, 50)) pr = Process(target=read, args=(q,)) # 启动子进程 pw.start() pr.start() # 等待子进程结束 pw.join() pr.join()]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt串口读取连贯数据]]></title>
    <url>%2F2019%2F04%2F05%2FQt%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%8F%96%E8%BF%9E%E8%B4%AF%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Qt的“信号与槽”机制极大的便利了内部事件的处理，但是在接收串口数据时我们利用到Qt的这一机制，却发现接收到的数据往往是不连贯的，这是由于当有数据到来时便立即触发读取操作，串口数据发送亦然，借此我们的程序能够及时处理串口中的数据。然而由于串口传输速率以及延迟问题，此时如果没有对接收到的串口数据做缓冲处理，最终导致我们接收到的数据呈现出来的将是断断续续的状态。因此下面的笔记为Qt中加了缓冲区的串口读取操作。 串口缓冲区读取操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 创建静态全局变量，用以串口读取缓冲区 */static QByreArry s_serialDataBuf;/*！ * \rief Qt串口数据读取 * \param 无输入参数 * \return 无返回值 * \attention 仅作参考 * \author Yobe Zhou*/void MainWindow::readSerialData()&#123; QString readData; /* 读取串口数据，当串口有数据到来时马上读取 */ const QByreArry bufferData = m_serial-&gt;readAll(); /* 将读取到数据追加到缓冲区 */ s_serialDataBuf.append(bufferData); /* 追加数据直到缓冲区有至少一条目标语句 */ if (s_serialBuffer.contains('B')) &amp;&amp; (s_serialDataBuf.contains('\n')) &#123; QString tempString; QList&lt;QByteArry&gt; lineList; int listCount = 0; tempString = s_serialDataBuf; /* 根据字头标识分割各条语句 */ lineList = s_serialDataBuf.split('B'); /* 清空缓冲区用以下一轮接收 */ s_serialDataBuf.clear(); /* 确定有多少目标语句 */ listCount = lineList.count(); /* 处理分割后的每条语句 */ for (int i = 0; i &lt; listCount; i++) &#123; readData = lineList.at(i); /* 当出现语句不完整（断句） */ if (!(readData.contains('\n'))) &#123; /* 当前处理语句为待处理语句的最后一句（有效断句） */ if (i == listCount - 1) &#123; /* 为断句补充标识 */ s_serialDataBUf.append('B'); /* 保存断句（存入清空后的缓冲区），承接下一轮接收 */ s_serialDataBuf.append(readData); continue; &#125; /* 不是有效断句，直接跳过 */ else &#123; continue; &#125; &#125; /* 语句中包含标识字符1 */ if (readData.contains("Target character2")) &#123; /* code */ &#125; /* 语句中包含标识字符2 */ else if (readData.contains("Target character")) &#123; /* code */ &#125; /*....*/ else &#123; /* code */ &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准库函数与运算符的区别]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。下面来看他们的区别。 标准库函数与运算符的区别一、操作对象有所不同&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。 &emsp;&emsp;对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。 &emsp;&emsp;运算符是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。 库函数是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。 二、在用法上也有所不同&emsp;&emsp;函数malloc的原型如下：1void * malloc(size_t size); &emsp;&emsp;用malloc 申请一块长度为length 的整数类型的内存，程序如下：1int *p = (int *) malloc(sizeof(int) * length); &emsp;&emsp;我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 malloc返回值的类型是void ，所以在调用malloc时要显示地进行类型转换，将void 转换成所需要的指针类型。 mallo函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。 &emsp;&emsp;函数free的原型如下：1void free( void * memblock ); 为什么free 函数不象malloc 函数那样复杂呢？&emsp;&emsp;这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。 new/delete的使用要点&emsp;&emsp;运算符new使用起来要比函数malloc简单得多，例如12int *p1 = (int *)malloc(sizeof(int) * length); int *p2 = new int[length]; &emsp;&emsp;这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。 &emsp;&emsp;如果new创建对象数组，那么只能使用对象的无参构造函数。例如：1Obj *objects = new Obj[100]; // 创建100 个动态对象 &emsp;&emsp;不能写成1Obj *objects = new Obj[100](1);// 创建100 个动态对象的同时赋初值1 &emsp;&emsp;在用delete 释放对象数组时，留意不要丢了符号‘[ ]’。例如12delete []objects; // 正确的用法 delete objects; // 错误的用法 &emsp;&emsp;后者相当于delete objects[0]，漏掉了另外99个对象。 两者区别 new自动计算需要分配的空间，而malloc需要手工计算字节数 new是类型安全的，而malloc不是，比如： 12int* p = new float[2]; // 编译时指出错误 int* p = malloc(2*sizeof(float)); // 编译时无法指出错误 new operator 由两步构成，分别是 operator new 和 construct（构造） operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力 new将调用constructor（构造函数），而malloc不能；delete将调用destructor（析构函数），而free不能。 malloc/free要库文件支持，new/delete不要。 本质区别&emsp;&emsp;malloc/free是c/C++语言的标准库函数，new/delete是C++的运算符。&emsp;&emsp;对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。 123456789101112131415161718192021222324class Obj &#123; public : Obj( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; ~ Obj( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; void Initialize( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; void Destroy( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; &#125;; void UseMallocFree( ) &#123; Obj * a = (Obj * ) malloc( sizeof ( Obj ) ); // allocate memory a -&gt; Initialize(); // initialization // … a -&gt; Destroy(); // deconstruction free(a); // release memory &#125; void UseNewDelete( void ) &#123; Obj * a = new Obj; // … delete a; &#125; &emsp;&emsp;类Obj的函数Initialize实现了构造函数的功能，函数Destroy实现了析构函数的功能。函数UseMallocFree中，由于 malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成“构造”与“析构”。（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。&emsp;&emsp;所以我们不要用 malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言 malloc/free和new/delete是等价的。 两者的联系&emsp;&emsp;既然new/delete的功能完全覆盖了malloc /free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用 free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete，malloc/free必须配对使用。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客主页文章展示实用设置]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E5%AE%9E%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[调整主页文章展示间距，最后添加1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 20px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: $grey-dim; background: none; border: none; border-bottom: 2px solid $grey-dim; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125; 修改为12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 5px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: Red; // http://cc.oulu.fi/~thu/jwz/Colours/545454.html background: none; border: none; border-bottom: 2px solid Red; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的三种地址及其转换]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址（以80x86微处理器为例）： 逻辑地址（logical address）：机器语言指令中用来指定一个操作数或者一条指令的地址，每一个逻辑地址由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。 线性地址（linear address 也叫做虚拟地址 virtual address）：是一个 32 位无符号整数，可以用来表达 4GB 的地址，通常用十六进制数表示。 物理地址（physical address）：用于内存芯片内的内存单元寻址，它们从微处理器的地址引脚发送到内存总线上的电信号对应。以上内容来自 《Understanding The Linux Kernel》 内存管理单元（Memory Management Unit, MMU）通过分段单元的把一个逻辑地址转换成线性地址，通过分页单元把线性地址转换成物理地址。 三种内存地址逻辑地址&emsp;&emsp;包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在 80X86 著名的分段结构中表现得尤为具体，它促使 MS-DOS 或 Windows 程序员把程序分成若干段。每一个逻辑地址都是有一个段和偏移量组成，偏移量指明了从段开始的地方到时间地址之间的距离。 线性地址（虚拟地址）&emsp;&emsp;是一个32位无符号整数，可以用来表示高达4GB的地址，也就是高达4294967296个内存单元。线性地址通常用十六进制数字表示。 物理地址&emsp;&emsp;用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。 &emsp;&emsp;内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址 分段与分页机制&emsp;&emsp;从 80286 开始，Intel 处理器以两种不同的方式执行地址转换，分别为实模式（real mode）和保护模式（protected mode）。下面我们就展开描述，在保护模式下，硬件的分段机制和分页机制 分段机制&emsp;&emsp;段选择符和段寄存器&emsp;&emsp;逻辑地址有两部分组成：一个段标识符和一个偏移量。短标识符是一个 16 位的字段，成为段选择符；偏移量是一个 32 位长的字段。&emsp;&emsp;为了快速找到段选择符，处理器提供了段寄存器用来存放段选择符，分别为 cs，ss，ds，es，fs，gs。&emsp;&emsp;其中有三个有专门的用途： cs：代码段寄存器，指向包含程序指令的段 ss：栈段寄存器，指向包含当前程序栈的段 ds：数据段寄存器，指向包含静态数据或者全局数据段&emsp;&emsp;其中，cs 含有一个两位的字段，用来指明当前的 CPU 特权等级（CPL），0 代表最高等级、3 代表最低等级。 Linux 只用到了 0 和 3，分别称为 内核态 和 用户态 段描述符&emsp;&emsp;每个段由一个 8 字节的段描述符表示，描述了段的基本信息。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）中。&emsp;&emsp;通常只会定义一个 GDT，每个进程除了放在 GDT 中的段以外，如还需要创建附加的段，就可以有自己的 LDT。GDT 在主存中的地址和大小存放在 gdtr 控制寄存器中，LDT 的地址和大小则存放在 ldtr 中。&emsp;&emsp;段描述符包涵以下关键字段： |Base| 包含段的首字节的线性地址|Type| 描述了段的类型特征和它的存取权限|DPL| 限制对这个段的存取权限，表示访问这个段的要求的最小 CPU 特权等级|P| Segment-Present 标志，表明当前段是否在内存中。Linux 总是把这个标志设为 1，从来不会把整个段交换到磁盘上去 分段单元&emsp;&emsp;那么逻辑地址是如何转换到线性地址的呢？ 先检查段选择符的TI字段，已决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址） 从段选择符的index字段计算段描述符的地址，index字段的值乘以8，这个结果与gdtr或ldtr寄存器的内容相加 把逻辑地址的偏移量与段描述符base字段的值相加就得到了线性地址 &emsp;&emsp;第二个称为分页单元的硬件电路把线性地址转化成一个物理地址。12 分段单元 分页单元逻辑地址 ----&gt; 线性地址 ----&gt; 物理地址 &emsp;&emsp;实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间，与分段相比，Linux更喜欢使用分页方式。因为当所有进程使用相同的段寄存器值时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持很有限。在多处理系统中，所有与CPU都共享同一内存；这意味着RAM芯片可以由独立的CPU并发访问。因为在RAM芯片上的读或写操作必须串行的执行。因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间，作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含有一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。 在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如：双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。 &emsp;&emsp;仲裁器由硬件电路管理，是隐藏的。 快速访问分段机制&emsp;&emsp;如果每次都执行上述的过程，可能会比较耗时，因为 GDT 是存储在主存中的，每次都访问主存，可能会比较慢，所以为了提高逻辑地址到线性地址的转换速度，80x86 处理器提供了一组6个不可编程寄存器。每一个不可编程寄存器含有 8 个字节的段描述符，具体的值由相对应的段寄存器中的段描述符确定。每当一个段选择符被装入段寄存器，相对应的段描述符就由主存装入到对应的不可编程寄存器，这样就可以不需要上面三个过程中的前两个，就可以得到线性地址了。 分页机制页、页框和页表&emsp;&emsp;分页单元把线性地址转换成物理地址，其中的关键任务是把所请求的访问类型与线性地址的访问权限做对比。 页：为了更高效和更经济的管理内存，线性地址被分为以固定长度为单位的组，成为页。页内部连续的线性地址空间被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和对应的存取权限，而不用指定全部线性地址的存取权限。这里说页，同时指一组线性地址以及这组地址包含的数据 页框：分页单元把所有的 RAM 分成固定长度的页框，每一个页框包含一个页。页框是主存的一部分，因此也是一个存储区域。页和页框相比，前者只是一个数据块，可以存放在页框或者磁盘中。 页表：把线性地址映射到物理地址的数据结构成为页表，页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化 常规的分页&emsp;&emsp;从 80386 开始，Intel 处理器的页大小为 4KB。&emsp;&emsp;32 位的线性地址被分为 3 个域： Directory（目录）：最高 10 位 Table（页表）：中间 10 位 Offset（偏移量）：最低 12 位&emsp;&emsp;线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表成为页目录表，第二种转换表成为页表。 &emsp;&emsp;为什么需要两级呢？目的在于减少每个进程页表所需的 RAM 的数量。如果使用简单的一级页表，将需要高达 2^20 个表项来表示每个进程的页表，即时一个进程并不使用所有的地址，二级模式通过职位进程实际使用的那些虚拟内存区请求页表来减少内存容量。每个活动的进程必须有一个页目录，但是却没有必要马上为所有进程的所有页表都分配 RAM，只有在实际需要一个页表时候才给该页表分配 RAM。 &emsp;&emsp;页目录项和页表项的结构如下： Present 标志：为 1 则表示页在主存中；如果为 0 则表示不在内存中，如果执行一个地址转换的时候，所需的页表项或者页目录项中的该标志为 0，那么分页单元就把该线性地址存在在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。 包含页框物理地址最高 20 位的字段 Dirty：当对页框进行写操作时就设置这个标志 Read/Write 标志：含有页或者页表的存取权限 User/Supervisor：含有访问页或者页表所需的特权等级 &emsp;&emsp;了解了以上结构之后，我们看看如何从线性地址转换到物理地址的： 线性地址中的 Directory 字段决定页目录中的目录项，目录项指向适当的页表 线性地址中的 Table 字段又决定页表的页表项，页表项含有页所在页框的物理地址 线性地址中的 Offset 地段决定了页框内的相对位置，由于 offset 为 12 为，所以一页含有 4096 字节的数据 总结&emsp;&emsp;以上描述的为 80x86 微处理器硬件分页机制，不同架构的 64 位处理器分页机制，大体的思路就是将二级模式拓展为三级（ia64）或者四级（x86_64），以达到对更大范围寻址空间的支持。 笔记：16进制线性地址转换&emsp;&emsp;16进制的线性地址转化为地址的物理空间大小。&emsp;&emsp;如：0x00000000 - 0x08000000的物理空间大小为128MB 换算：0x08000000 === 134217728 (Bytes) 134217728(Bytes) / 1024 = 131072(KB) 131072(KB) / 1024 = 128(MB)]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>操作系统</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提交搜索引擎收录（Google+Baidu）]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E6%8F%90%E4%BA%A4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%EF%BC%88Google-Baidu%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[递增与减运算符：++与--]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%80%92%E5%A2%9E%E4%B8%8E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%2B%2B%E4%B8%8E--%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;紧凑的代码让程序更为整洁，而且通常其生成的机器代码效率更高。 递增与递减运算符&emsp;&emsp;递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)： 1. &quot;++&quot;出现在其作用的变量前面---前缀模式(++a) 如：q = 2*++a; • 首先，a递增1； • 然后，2乘以a，并将结果赋给q 2. &quot;++&quot;出现在其作用的变量后面---后缀模式(a++) 如：q = 2*a++; • 首先，2乘以a，并将结果赋给q； • 然后，a递增1 &emsp;&emsp;同理可得： &quot;--&quot;出现在其作用的变量前面 ----&gt; 前缀模式(--a) &quot;--&quot;出现在其作用的变量后面 ----&gt; 后缀模式(a--)]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加Gitment评论系统]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;Hexo框架搭建好之后，默认的功能模块有限，因此很多模块需要我们自己去添加，对于我们的博客网站来说，没有评论系统怎么行呢？毕竟我们需要采集良言，及时发现文章的不足并且可以帮助仍有疑问的朋友解答问题。话不多说，我们开始搭建博客的评论系统吧。 Gitment评论系统&emsp;&emsp;我们首先了解一下国内的几个第三方评论系统，如“多说”，“畅言”，“友言”，“新浪云跟贴”： 多说，曾经较火的评论系统，网上介绍文章比较多，但已关闭，无法再用了。 畅言，sohu旗下的，但是需要个人博客备案后才能使用，但github pages个人博客感觉备案比较难。 友言，jiaThis旗下的，由于时http请求，github pages现在都是https了， 在https站点无法调用http请求，故也无法使用。 网易云跟贴，曾被当作“多说”的替代品，可惜官方通报说也将在2017.08.01关闭了。Gitment，一款由国内大神imsun开发的基于github issues的评论系统, 具体介绍请看项目主页 Gitment简介&emsp;&emsp;&emsp;&emsp;Gitment 是基于 GitHub Issues 的评论系统，是 imsun 利用 github 上的 issues 做的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown&amp;GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。想了解具体效果，可以点击查看官方Demo Page:Gitment Demo。 注册OAuth Application&emsp;&emsp;首先我们先去 OAuth application 进行注册，申请一个 Github OAuth Application。填写参考如下： Application name: 博客名字 Homepage URL: 网站主页地址(这里我填写的是域名或github项目地址/index.html大部分的默认网页都是index.html) Application description: 描述，选填 Authorization callback URL: 填写域名或github项目地址 &emsp;&emsp;填写相关信息时注意在 Authorization callback URL 一项填自己的网站url：1https://username.github.io &emsp;&emsp;填写完毕后点击 Register application 若创建成功则将跳转到另外一个界面，此时我们会得到一个 client ID 和一个 client secret，它们将被用于之后的用户登录。 修改 _config.yml&emsp;&emsp;我们需要在 Hexo 主题目录下编辑修改 _config.yml 配置文件。不同的主题的配置文件存放路径有所差别，下面以 netx 主题为例说明：1next主题的配置文件路径：&quot;/themes/next/_config.yml&quot; &emsp;&emsp;打开配置文件后，我们搜索关键字“Gitment”将定位到配置位置。默认的配置内容为：1234567891011121314# Gitmentgitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled &emsp;&emsp;我们修改成自己的配置内容：123456789101112131415# 添加Gitment评论系统# Gitmentgitment: enable: true # 修改为 true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: 123456 # 填写自己的 github ID github_repo: xxx.github.io # 存储评论内容的仓库名 client_id: abcd123456abcd # 填写获取到的 client_id client_secret: abcd123456efg # 填写获取到的 client_secret proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 获取自己的 Github ID&emsp;&emsp;在浏览器中打开下面的地址，”Your github username”需要修改为自己的Github username:1https://api.github.com/users/"Your github username" 验证&emsp;&emsp;在 Hexo 根目录输入：1$ hexo s &emsp;&emsp;浏览器打开地址：1http://localhost:4000/ &emsp;&emsp;浏览自己的一篇博客到最后，如果发现有评论界面则大功告成！如果没有应该时配置信息没写对，请检查自己的配置内容。 &emsp;&emsp;但是此时出现了错误：1Error:Not Found &emsp;&emsp;经过检查后发现是 owner 或 repo 配置错误 将 github_user 直接填写自己的Github用户名即可。 &emsp;&emsp;然而此时仍有可能出现如下的问题： &emsp;&emsp;或英文提示：”Error: Comments Not Initialized”。原因有如下两点： 在该页面的Gitment评论区登陆GitHub账号 之前OAuth Application callback填写有误&emsp;&emsp;若当点击评论区的“使用Github登陆”跳转出现报错，则可以确定是之前“OAuth Application callback”填写有误，我们需要返回到自己的Github设置上去修改过来：1Github头像下拉菜单 --&gt; Settings --&gt; 左边Developer settings下的OAuth Application --&gt; Register a new application，进入到填写相关信息页面。 12Authorization callback URL 一定要写自己Github Pages的URL.如：https://Yobe.github.io &emsp;&emsp;检查无误可正常使用后，即可部署到我们的 Github 上:1$ hexo d -g]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机术语-簇]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD-%E7%B0%87%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;数据存储在硬盘的时候都是以簇为单位，所以无论文件大小是多少，除非正好是簇大小的倍数，否则文件所占用的最后一个簇或多或少都会产生一些剩余的空间，且这些空间又不能给其它文件使用，即使这个文件只有0字节，也不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。 中文名 簇 外文名 CLUST 存储管理 最小单位 属 性 单位名称 本 意 “一群”、“一组” 解 释 一组扇区 &emsp;&emsp;微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇”&emsp;&emsp;一个文件通常存放在一个或多个簇里，但至少要单独占据一个“簇”。 也就是说两个文件不能存放在同一个簇中。簇（CLUST）的本意就是“一群”、“一组”，即一组扇区(一个磁道可以分割成若干个大小相等的圆弧，叫扇区)的意思。因为扇区的单位太小，因此把它捆在一起，组成一个更大的单位更方便进行灵活管理。簇的大小通常是可以变化的，是由操作系统在所谓“（高级）格式化”时规定的，因此管理也更加灵活。&emsp;&emsp;通俗地讲文件就好比是一个家庭，数据就是人，即家庭成员；所谓簇就是一些单元套房；扇区是组成这些单元套房的一个个大小相等的房间。一个家庭可能住在一套或多套单元房子里，但一套房子不能同时住进两个家庭的成员。 文件系统是操作系统与驱动器之间的接口，当操作系统请求从硬盘里读取一个文件时，会请求相应的文件系统（FAT 16/FAT32/NTFS）打开文件。扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。&emsp;&emsp;为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；如果文件实际大小小于一簇，它也要占一簇的空间。如果文件实际大小大于一簇，根据逻辑推算，那么该文件就要占两个簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。&emsp;&emsp;一个簇只能容纳一个文件占用，即使这个文件只有0字节，也决不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本设置]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Hexo+Github Page+个人域名”搭建个人专属博客]]></title>
    <url>%2F2019%2F03%2F30%2F%E2%80%9CHexo%2BGithub_Page%2B%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E2%80%9D%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言使用 Hexo+Github我们快速的搭建自己的个人博客，整个过程下来我们几乎不需要什么金钱成本（在个人服务器上部署可选），所付出的仅仅是自己对于其的时间精力上的管理成本。而 Hexo 基于MakrDown 语法编辑页面，在书写方面我们将得到极大的便利。最后绑定自己的个人域名我们的博客访问过程将更加便利。 本文的操作环境为： Windows 10 64bit Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，我们可以非常方便快速地利用靓丽的主题生成自定义的静态网页。 Hexo的优缺点分析 优点 免费 - GitHub 快速 - Node运行环境、前端个人站点首选 简洁 - MarkDown 轻量 - 全部静态文件 支持导入WordPress等博客 不足 更换电脑不变 - 需重新安装环境 静态博客 - 不便于后期维护 多媒体管理不方便 Hexok工作原理hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。我们不需要将 Hexo 部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，也就是说我们可以几乎没有任何成本地搭建一个自己的个人博客。简而言之：hexo是个静态页面生成、上传的工具。 Hexo 环境搭建我们可以在服务器上或在自己的本地电脑上安装部署 Hexo，安装 Hexo 的过程非常简单，只需几分钟即可完成！ 安装前提在安装前，我们必须检查电脑中是否已安装下列应用程序，如果是第一次安装请先去对应的官网下载安装包： Node.js Git 安装Node.jsNode.js的过程非常简单按照提示安装即可，打开cmd命令行，成功界面如下： 安装gitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。我们用 git 来管理自己的hexo博客文章，并上传到GitHub。git的过程非常简单按照提示安装即可，安装成功后我们在电脑上任何位置鼠标右键能够出现如下两个选择： 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 安装Hexo前面 Node.js 和 git 安装好后，现在我们就可以安装hexo了，我们先找到一个合适的位置（以后的博客文章都存放于此处再上传至服务器），然后创建一个文件夹如“blog” ，最后在命令行模式下定位当前目录到这个文件夹下（或者在这个文件夹下直接右键 “git bash Here” 打开）（或者在文件下的路径处输入 “cmd” 并回车）。gotocmd 1$ npm install -g hexo-cli 初始化自己的 blog 文件夹（需要耐心等待） 1$ hexo init 初始化完成后将会看到如下内容，即说明初始化成功： 1INFO Start blogging with Hexo! 最后安装所需的组件： 1$ npm install 万事具备！我们来开始首次体验 Hexo吧！输入下面的命令，将最后得到 Hexo 本地运行的地址复制到浏览器即可预览 demo： 1$ hexo g &amp;&amp; hexo s 假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p [端口号]”来改变端口号。在 Hexo 保持在本地运行的状态时 “hexo s”，我们对 Hexo 的任何更改都会立即被应用，只需刷新网页即可预览。 Github部分如果没有自己的 Github 账户，就先去 注册 自己的 Github 账户吧。注册完成并登录后，在 GitHub.com 中看到一个New repository，我们点击它以新建仓库。 接下来我们需要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。这里我是已经建过了所以会报错： 在Github中创建的与自己用户名相同的仓库，会被识别为 Github page 的展示默认主页（唯一的），而其他仓库则被是为普通项目。 修改配置使与 Github 仓库关联打开“blog”根目录下的”_config.yml”。需要修改的地方有：网站名，介绍，关键字（这部分自己取），url 即是“http://用户名.github.io“。 12345678910111213141516171819202122# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: YobeZhou # 网站名，默认为 Hexosubtitle:description: # 网站介绍keywords: # 网站关键字# author: John Doeauthor: 周岳标language: zh-Hans # 设置语言为汉语timezone:avatar: /images/touxiang.jpg # 头像# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: http://yoursite.comurl: YobeZhou.github.io # 你的网址，也为个人域名root: /permalink: :year/:month/:day/:title/permalink_defaults: 但这些都不是必要的，必不可少的是将hexo与我们的Github P仓库关联起来。下面我们打开 Github 获取仓库地址, 点击头像 -&gt; Your profile 点击查看对应的仓库（即为之前新建的 Github page 专用仓库），选择点击右上角的“Use ssh”之后再点击“Clone or download”，这样就复制好自己的仓库地址了：紧接着我们回到刚刚编辑的”_config.yml”文件中，搜索定位“deploy”所在位置，我获取到的仓库地址为：“git@github.com:YobeZhou/YobeZhou.github.io.git” ，这要填写在下面的“repo: ”中，请参考我的配置： 12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:YobeZhou/YobeZhou.github.io.git branch: master# branch: [branch] #published. branch: master# message: [message] 至此,我们把hexo与我们的github仓库配置信息关联起来了，接下来我们要将这个配置实现起来，也就是hexo能登陆到我们的github Page上，并将更改的内容提交到对应的仓库中，然后我们访问的时候就可以看到提交的内容（博客）。 对语法格式要求严格，修改时请务必注意缩进对齐和空格个数。 配置GitHub SSH做完这最后一步，我们就可以将自己编写的文章上传到我们的github仓库中去了。 设置Git账户本机主机第一次git时，我们需要设置git的user name和user email首先打开”Git Bash Here”，输入以下内容： 12git config --global user.name &quot;xxxxxxx&quot;git conglfig --global user.email &quot;“xxxxxxxxx@xx.com&quot; 这里“xxx”替换成自己的GitHub用户名，邮箱替换成自己的GitHub邮箱。 生成SSH Key以下所有的操作都是在”Git Bash Here”中进行。输入ssh-keygen -t rsa”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\YourUserName.ssh）。 1ssh-keygen -t rsa 生成SSH Key后输入以下命令来检查SSH配置文件是否已经生成: 12cd ~/.sshdir 过程如下图所示，由于我这里之前已经生成过SSH Key所以会提示覆盖警告。 出现上面内容就说明成功生成”id_rsa”和”id_rsa.pub”两个文件，”id_rsa.pub”为公钥，”id_rsa”为私钥，它们都是隐藏文件。 添加SSH Key到GitHub上直接使用cat命令查看 “id_rsa.pub” 文件的内容，然后复制显示出来的所有内容备用： 最后我们将公钥id_rsa.pub添加到GitHub上就可以了，首先登陆GitHub进入设置界面，进入”Settings”，如图所示： 在”Setting”页面中，选择”SSH and GPG keys”选项：粘贴刚刚复制的SSH Key即可： 最后，输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 到此为止，所有的配置都已经完成，万事具备只欠东风，现在我们可以将自己的文章上传到自己的GitHub Page并通过外网随时随地访问了。 生成并部署！我们先回到之前新建的blog目录下，在文件下的路径处输入 cmd 并回车。我们先新建一篇博客，在cmd执行命令：hexo new post “博客名”。这时候在文件夹_posts目录下将会看到已经创建的文件。在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 拓展安装完成后，使用编辑器编好文章，就可以使用命令：hexo d -g，生成以及部署了： 12生成命令： hexo g部署命令： hexo d 或者一键生成部署命令： 1$ hexo d -g &emsp;&emsp;显示出 “INFO Deploy done: git” 表示成功发布到github上！现在在浏览器上输入 “用户名.github.io” 即可访问自己的博客（你可以把这个链接发布给小伙伴啦） 绑定个人域名待续。。。 域名申请待续。。。 域名解析待续。。。 博客域名升级Https&emsp;&emsp;Github 从 2009 年开始支持自定义域名，从 2016 年开始 *.github.io 域名支持 Https，从2018年5月1日 GitHub Pages 上的自定义域名也开始支持 Https。&emsp;&emsp;Github 和 Let’s Encrypt 合作对建立在其上的自定义域名站点进行的证书颁发和认证。如果之前域名是做的 CNAME 或者 Alias 的 DNS 记录，则直接支持 Https 访问；如果是 A 记录做的解析，则需要更换 A 记录指向的 IP 地址为新的给定地址。最后在 Github Pages 仓库的设置页选中 “Enforce HTTPS” 选项即可。&emsp;&emsp;配置过程非常简单，设置完稍等几分钟再次访问自己的主页将会发现已经升级成功！ 后续学习&emsp;&emsp;本文中介绍完基于Hexo及Github page搭建专属的个人博客的详细方法。万事开头难，现在我们仅仅是把平台搭建好了，接下来我们应该趁热打铁继续深入学习探索，请参考我的其他文章：&emsp;&emsp;&emsp;&emsp;Hexo基本设置&emsp;&emsp;&emsp;&emsp;hexo使用技巧&emsp;&emsp;&emsp;&emsp;Hexo的专用编辑器-HexoEditor&emsp;&emsp;&emsp;&emsp;什么是Markdown？]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的专用编辑器-HexoEditor]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E7%9A%84%E4%B8%93%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8-HexoEditor%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&emsp;&emsp;’Hexo’ 是一款基于 ‘Node.js’ 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 ‘GitHub’ 和 ‘Coding’ 上，是搭建博客的首选框架。 由于 ‘Hexo’ 使用[markdown]语法的纯文本编辑，所以在写作的时候我们需要使用一些工具方能达到事半功倍的效果。 HexoEditor简介&emsp;&emsp;接下来要介绍给大家的 ‘HexoEditor’ 便是网上有人针对 ‘Hexo’ 做了优化的 ‘Markdown’ 编辑器，其使用 [Electron] 做框架，修改自 [Moeditor] 支持 Markdown，Latex 等。使用它我们可以为 ‘Hexo’ 下的博客更好的去书写内容。这是HexoEditor的开源项目地址。 快速下载安装&emsp;&emsp;在 ‘Github’ 项目中并没有给出，可安装的 ‘releases’ 版本，如想省去麻烦的安装过程请在下面的地址下载。&emsp;&emsp;下载地址： Windows x64:1https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe Macx64:1https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg 使用技巧 按键 方法 说明 Tab tabAdd 添加缩进 Shift - Tab tabSubtract 减少缩进 Ctrl - B toggleBlod 切换粗体 Ctrl - I toggleItalic 切换斜体 Ctrl - D toggleDelete 删除当前行 Ctrl - ` toggleComment 切换注解 Ctrl - L toggleUnOrderedList 切换无序列表 Ctrl - Alt - L toggleOrderedList 切换有序列表 Ctrl - ] toggleHeader 降级标题 Ctrl - [ toggleUnHeader 升级标题 Ctrl - = toggleBlockquote 增加引用 Ctrl - - toggleUnBlockquote 减少引用 Ctrl - U drawLink 添加超级链接 Ctrl - Alt - U drawImageLink 添加图片 Ctrl - T drawTable(row col) 添加表格(行 列) Ctrl - V pasteOriginContent 源内容粘贴 Shift - Ctrl - V pasteContent 智能粘贴 Alt - F formatTables 格式化表格 Ctrl - N 新建md文档 Ctrl - H 新建Hexo文档 Ctrl - O 打开md文件 Ctrl - S 保存文档 Shift - Ctrl - S 另存为 Alt - Ctrl - S 打开设置 Ctrl - W 切换写作模式 Ctrl - P 切换预览模式 Ctrl - R 切换阅读模式 提示: 在 Mac OS下, 请使用 Cmd 来代替 Ctrl .]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Markdown？]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%BB%80%E4%B9%88%E6%98%AFMarkdown%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Markdown的简单介绍&emsp;&emsp;&emsp;&emsp;Markdown 是由 ‘John Gruber’ 和 ‘Aaron Swartz’ 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 &emsp;&emsp;&emsp;&emsp;’Markdown’ 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 ‘Markdown’ 格式的文件。用 ‘Markdown’ 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 ‘Markdown’ 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 &emsp;&emsp;我们可以使用任何文本编辑器来写 ‘Markdown’ 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 ‘Markdown’ 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用技巧]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近开始使用Hexo写自己的个人博客，下面是对在使用过程中的一些技巧的总结。如果想要阅读官方的帮助文档请移步Hexo帮助文档。 写作篇&emsp;&emsp;Hexo使用[markdown]语法的纯文本编辑，文件后缀名.m ,文件默认存放在我们的站点目录下“/source/_post”文件夹下。 创建一篇新文章1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;Hexo有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而我们自定义的其他布局和 post 相同，都将储存到 “source/_posts” 文件夹。可以在命令中指定文章的布局（layout），若不指定[layout]则布局将默认为 post，默认布局可以通过修改 _config.yml 中的 default_layout 参数来指定。 部署&emsp;&emsp;部署前请确保网络连接，并且当前目录在hexo的根目录。 方法一&emsp;&emsp;Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy &emsp;&emsp;在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git &emsp;&emsp;还可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。12345deploy:- type: git repo:- type: heroku repo: 方法二1hexo d -g &emsp;&emsp;或hexo素质三连123$ hexo clean$ hexo d$ hexo -g Hexo中添加本地图片和使用网络图片方法一 相对引用&emsp;&emsp;由于首页和主页相对图片位置不一致，网站首页和内页很可能仅有一处能正常加载。1.调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True2.在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹3.最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片：1![Tip](/images/xx.jpg) 方法二 图床&emsp;&emsp;如SMMS图床无需注册&emsp;&emsp;以下是测试：1https://i.loli.net/2018/02/09/5a7d6a402e15e.jpg &emsp;&emsp;注：请备份Delete Link,必要时访问此链接删除图片。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
