<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题]]></title>
    <url>%2F2019%2F04%2F06%2FPython%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3TensorFlow%E4%B8%AD%E7%9A%84OpenCV%E8%A7%86%E9%A2%91%E6%B5%81%E8%AF%BB%E5%8F%96%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的 read() 函数时发现其数据处理与数据产生的速度跟不上而导致延迟非常高，甚至内存溢出，因此开始思考解决措施。1retval, image = cv.VideoCapture.read([, image]) 这是因为OpenCV读取视频流时，数据处理程序需要消耗的CPU时间过于长（不同硬件配置情况不可一概而论），而VideoCapture的read是按帧队列读取，先进先出，所以出现了上面所说的问题。由此联想到我们需要将读取视频数据和处理视频数据的过程分开处理，从而试图消除延迟。 思路分析我们可以使用多进程或多线程将读取视频数据和处理视频数据的过程分开处理，但是由于实时视频处理术语CPU密集型任务，多线程的优势发挥不出来，因此我们选择多进程方式。 所用到的库实现多进程所用到的库：1234import osimport cv2import gcfrom multiprocessing import Process, Manager 两个子进程：12write()read() 在两个子进程中传递参数 multiprocessing中有Quaue、SimpleQuaue等进程间传参类，以及Manager统领全局。 使用Manager我们可以在进程键传递字典、列表灯Python原生数据类型 Quaue时严格的数据结构队列类型 在读取进程中得到最新的视频帧数据 首先’VideoCapture’是队列，先进先出。因此我们需要将其转换为压栈存储视频帧数据，才能达到后进先出而获取最新的视频帧数据，因此不能使用Quaue来传递参数。 为了达到压栈的效果，我们可以使用Python的列表，其append与pop操作可以达到模拟压栈的效果。因此，我们可以使用multiprocessing.Manager.list进行进程间传参类型。 清理传参栈由于压栈频率肯定是要比出栈频率高的，时间一长就会在栈中积累大量无法出栈的视频帧，会导致程序崩溃，因此我们需要考虑传参栈自动清理的问题，我们需要一个自动清理的机制： 我们可以设定传参栈的容量，每当达到这个容量时就直接把栈清空，再利用gc库手动发起一次python垃圾回收。这样就不会导致严重的内存溢出和程序崩溃。 实现代码综上所述，实际上这个程序就是把VideoCapture的队列读取改成了栈读取。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170# -*- coding: UTF-8 -*-# Import packagesimport osimport cv2import numpy as npimport tensorflow as tfimport sysimport gcfrom multiprocessing import Process, Manager# Import utilitesfrom utils import label_map_utilfrom utils import visualization_utils as vis_util# 向共享缓冲栈中写入数据:def write(stack, cam, top: int) -&gt; None: """ :param cam: 摄像头参数 :param stack: Manager.list对象 :param top: 缓冲栈容量 :return: None """ print('Process to write: %s' % os.getpid()) video = cv2.VideoCapture(cam) # 可以通过该地址查看属性设置的帮助官方文档： # https://docs.opencv.org/master/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d ret = video.set(3,640) ret = video.set(4,480) # 利用 'cv.VideoCapture.get(propId)' 查询指定属性的值。查询VideoCapture实例使用的后端不支持的属性时返回值0 。 # 5 -- 查看当前帧速率 retval = video.get(5) print (cam) print(retval) while(video.isOpened()): ret, img = video.read() if ret: stack.append(img) # 每到一定容量清空一次缓冲栈 # 利用gc库，手动清理内存垃圾，防止内存溢出 if len(stack) &gt;= top: del stack[:] gc.collect() # Press 'q' to quit if cv2.waitKey(1) == ord('q'): break # Clean up video.release() cv2.destroyAllWindows()# 在缓冲栈中读取数据:def read(stack) -&gt; None: print('Process to read: %s' % os.getpid()) # Name of the directory containing the object detection module we're using MODEL_NAME = 'inference_graph' # Grab path to current working directory CWD_PATH = os.getcwd() # Path to frozen detection graph .pb file, which contains the model that is used # for object detection. PATH_TO_CKPT = os.path.join(CWD_PATH,MODEL_NAME,'frozen_inference_graph.pb') # Path to label map file PATH_TO_LABELS = os.path.join(CWD_PATH,'training','labelmap.pbtxt') # Number of classes the object detector can identify NUM_CLASSES = 56 ## Load the label map. # Label maps map indices to category names, so that when our convolution # network predicts `5`, we know that this corresponds to `king`. # Here we use internal utility functions, but anything that returns a # dictionary mapping integers to appropriate string labels would be fine label_map = label_map_util.load_labelmap(PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) # Load the Tensorflow model into memory. detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') sess = tf.Session(graph=detection_graph) # Define input and output tensors (i.e. data) for the object detection classifier # Input tensor is the image image_tensor = detection_graph.get_tensor_by_name('image_tensor:0') # Output tensors are the detection boxes, scores, and classes # Each box represents a part of the image where a particular object was detected detection_boxes = detection_graph.get_tensor_by_name('detection_boxes:0') # Each score represents level of confidence for each of the objects. # The score is shown on the result image, together with the class label. detection_scores = detection_graph.get_tensor_by_name('detection_scores:0') detection_classes = detection_graph.get_tensor_by_name('detection_classes:0') # Number of objects detected num_detections = detection_graph.get_tensor_by_name('num_detections:0') while(True): if len(stack) != 0: # Acquire frame and expand frame dimensions to have shape: [1, None, None, 3] # i.e. a single-column array, where each item in the column has the pixel RGB value frame = stack.pop() frame_expanded = np.expand_dims(frame, axis=0) # Perform the actual detection by running the model with the image as input (boxes, scores, classes, num) = sess.run( [detection_boxes, detection_scores, detection_classes, num_detections], feed_dict=&#123;image_tensor: frame_expanded&#125;) # Draw the results of the detection (aka 'visulaize the results') # visualize boxes and labels on image array image,tablename = vis_util.my_visualize_boxes_and_labels_on_image_array( frame, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8, min_score_thresh=0.60) # All the results have been drawn on the frame, so it's time to display it. cv2.imshow('Object detector', frame) # 在控制台上打印识别结果 print (tablename) # Press 'q' to quit if cv2.waitKey(1) == ord('q'): breakif __name__ == '__main__': print(tf.__version__) # This is needed since the notebook is stored in the object_detection folder. sys.path.append("..") # Initialize webcam feed url = 'http://192.168.0.125:8081/' # 父进程创建缓冲栈，并传给各个子进程： q = Manager().list() pw = Process(target=write, args=(q, url, 50)) pr = Process(target=read, args=(q,)) # 启动子进程 pw.start() pr.start() # 等待子进程结束 pw.join() pr.join()]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt串口读取连贯数据]]></title>
    <url>%2F2019%2F04%2F05%2FQt%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%8F%96%E8%BF%9E%E8%B4%AF%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言Qt的“信号与槽”机制极大的便利了内部事件的处理，但是在接收串口数据时我们利用到Qt的这一机制，却发现接收到的数据往往是不连贯的，这是由于当有数据到来时便立即触发读取操作，串口数据发送亦然，借此我们的程序能够及时处理串口中的数据。然而由于串口传输速率以及延迟问题，此时如果没有对接收到的串口数据做缓冲处理，最终导致我们接收到的数据呈现出来的将是断断续续的状态。因此下面的笔记为Qt中加了缓冲区的串口读取操作。 串口缓冲区读取操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* 创建静态全局变量，用以串口读取缓冲区 */static QByreArry s_serialDataBuf;/*！ * \rief Qt串口数据读取 * \param 无输入参数 * \return 无返回值 * \attention 仅作参考 * \author Yobe Zhou*/void MainWindow::readSerialData()&#123; QString readData; /* 读取串口数据，当串口有数据到来时马上读取 */ const QByreArry bufferData = m_serial-&gt;readAll(); /* 将读取到数据追加到缓冲区 */ s_serialDataBuf.append(bufferData); /* 追加数据直到缓冲区有至少一条目标语句 */ if (s_serialBuffer.contains('B')) &amp;&amp; (s_serialDataBuf.contains('\n')) &#123; QString tempString; QList&lt;QByteArry&gt; lineList; int listCount = 0; tempString = s_serialDataBuf; /* 根据字头标识分割各条语句 */ lineList = s_serialDataBuf.split('B'); /* 清空缓冲区用以下一轮接收 */ s_serialDataBuf.clear(); /* 确定有多少目标语句 */ listCount = lineList.count(); /* 处理分割后的每条语句 */ for (int i = 0; i &lt; listCount; i++) &#123; readData = lineList.at(i); /* 当出现语句不完整（断句） */ if (!(readData.contains('\n'))) &#123; /* 当前处理语句为待处理语句的最后一句（有效断句） */ if (i == listCount - 1) &#123; /* 为断句补充标识 */ s_serialDataBUf.append('B'); /* 保存断句（存入清空后的缓冲区），承接下一轮接收 */ s_serialDataBuf.append(readData); continue; &#125; /* 不是有效断句，直接跳过 */ else &#123; continue; &#125; &#125; /* 语句中包含标识字符1 */ if (readData.contains("Target character2")) &#123; /* code */ &#125; /* 语句中包含标识字符2 */ else if (readData.contains("Target character")) &#123; /* code */ &#125; /*....*/ else &#123; /* code */ &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准库函数与运算符的区别]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。下面来看他们的区别。 标准库函数与运算符的区别一、操作对象有所不同malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。 对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。 运算符是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。 库函数是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。 二、在用法上也有所不同函数malloc的原型如下：void * malloc(size_t size);用malloc 申请一块长度为length 的整数类型的内存，程序如下：1int *p = (int *) malloc(sizeof(int) * length); 我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 malloc返回值的类型是void ，所以在调用malloc时要显示地进行类型转换，将void 转换成所需要的指针类型。 mallo函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。 函数free的原型如下：1void free( void * memblock ); 为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。 new/delete的使用要点运算符new使用起来要比函数malloc简单得多，例如12int *p1 = (int *)malloc(sizeof(int) * length); int *p2 = new int[length]; 这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。 如果new创建对象数组，那么只能使用对象的无参构造函数。例如：1Obj *objects = new Obj[100]; // 创建100 个动态对象 不能写成1Obj *objects = new Obj[100](1);// 创建100 个动态对象的同时赋初值1 在用delete 释放对象数组时，留意不要丢了符号‘[ ]’。例如12delete []objects; // 正确的用法 delete objects; // 错误的用法 后者相当于delete objects[0]，漏掉了另外99个对象。 两者区别 new自动计算需要分配的空间，而malloc需要手工计算字节数 new是类型安全的，而malloc不是，比如： 12int* p = new float[2]; // 编译时指出错误 int* p = malloc(2*sizeof(float)); // 编译时无法指出错误 new operator 由两步构成，分别是 operator new 和 construct（构造） operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力 new将调用constructor（构造函数），而malloc不能；delete将调用destructor（析构函数），而free不能。 malloc/free要库文件支持，new/delete不要。 本质区别malloc/free是c/C++语言的标准库函数，new/delete是C++的运算符。对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。 123456789101112131415161718192021222324class Obj &#123; public : Obj( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; ~ Obj( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; void Initialize( ) &#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125; void Destroy( ) &#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125; &#125;; void UseMallocFree( ) &#123; Obj * a = (Obj * ) malloc( sizeof ( Obj ) ); // allocate memory a -&gt; Initialize(); // initialization // … a -&gt; Destroy(); // deconstruction free(a); // release memory &#125; void UseNewDelete( void ) &#123; Obj * a = new Obj; // … delete a; &#125; 类Obj的函数Initialize实现了构造函数的功能，函数Destroy实现了析构函数的功能。函数UseMallocFree中，由于 malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成“构造”与“析构”。（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。所以我们不要用 malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言 malloc/free和new/delete是等价的。 两者的联系既然new/delete的功能完全覆盖了malloc /free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用 free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete，malloc/free必须配对使用。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客主页文章展示实用设置]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E5%AE%9E%E7%94%A8%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[调整主页文章展示间距，最后添加1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 20px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: $grey-dim; background: none; border: none; border-bottom: 2px solid $grey-dim; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125; 修改为12.post-tags &#123; text-align: right; 1234567891011121314151617181920.post-button &#123; margin-top: 5px; text-align: right; a &#123; padding: 0; font-size: $font-size-base; color: Red; // http://cc.oulu.fi/~thu/jwz/Colours/545454.html background: none; border: none; border-bottom: 2px solid Red; transition-property: border; +mobile() &#123; font-size: $font-size-small; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125; &amp;:hover &#123; border-bottom-color: $black-deep; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存的三种地址及其转换]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址（以80x86微处理器为例）： 逻辑地址（logical address）：机器语言指令中用来指定一个操作数或者一条指令的地址，每一个逻辑地址由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。 线性地址（linear address 也叫做虚拟地址 virtual address）：是一个 32 位无符号整数，可以用来表达 4GB 的地址，通常用十六进制数表示。 物理地址（physical address）：用于内存芯片内的内存单元寻址，它们从微处理器的地址引脚发送到内存总线上的电信号对应。以上内容来自 《Understanding The Linux Kernel》 内存管理单元（Memory Management Unit, MMU）通过分段单元的把一个逻辑地址转换成线性地址，通过分页单元把线性地址转换成物理地址。 三种内存地址逻辑地址包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在 80X86 著名的分段结构中表现得尤为具体，它促使 MS-DOS 或 Windows 程序员把程序分成若干段。每一个逻辑地址都是有一个段和偏移量组成，偏移量指明了从段开始的地方到时间地址之间的距离。 线性地址（虚拟地址）是一个32位无符号整数，可以用来表示高达4GB的地址，也就是高达4294967296个内存单元。线性地址通常用十六进制数字表示。 物理地址用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。 内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址 分段与分页机制从 80286 开始，Intel 处理器以两种不同的方式执行地址转换，分别为实模式（real mode）和保护模式（protected mode）。下面我们就展开描述，在保护模式下，硬件的分段机制和分页机制 分段机制段选择符和段寄存器逻辑地址有两部分组成：一个段标识符和一个偏移量。短标识符是一个 16 位的字段，成为段选择符；偏移量是一个 32 位长的字段。为了快速找到段选择符，处理器提供了段寄存器用来存放段选择符，分别为 cs，ss，ds，es，fs，gs。其中有三个有专门的用途： cs：代码段寄存器，指向包含程序指令的段 ss：栈段寄存器，指向包含当前程序栈的段 ds：数据段寄存器，指向包含静态数据或者全局数据段其中，cs 含有一个两位的字段，用来指明当前的 CPU 特权等级（CPL），0 代表最高等级、3 代表最低等级。 Linux 只用到了 0 和 3，分别称为 内核态 和 用户态 段描述符每个段由一个 8 字节的段描述符表示，描述了段的基本信息。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）中。通常只会定义一个 GDT，每个进程除了放在 GDT 中的段以外，如还需要创建附加的段，就可以有自己的 LDT。GDT 在主存中的地址和大小存放在 gdtr 控制寄存器中，LDT 的地址和大小则存放在 ldtr 中。段描述符包涵以下关键字段： Base：包含段的首字节的线性地址Type：描述了段的类型特征和它的存取权限DPL：限制对这个段的存取权限，表示访问这个段的要求的最小 CPU 特权等级P：Segment-Present 标志，表明当前段是否在内存中。Linux 总是把这个标志设为 1，从来不会把整个段交换到磁盘上去 分段单元那么逻辑地址是如何转换到线性地址的呢？ 先检查段选择符的TI字段，已决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址） 从段选择符的index字段计算段描述符的地址，index字段的值乘以8，这个结果与gdtr或ldtr寄存器的内容相加 把逻辑地址的偏移量与段描述符base字段的值相加就得到了线性地址 第二个称为分页单元的硬件电路把线性地址转化成一个物理地址。12 分段单元 分页单元逻辑地址 ----&gt; 线性地址 ----&gt; 物理地址 实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间，与分段相比，Linux更喜欢使用分页方式。因为当所有进程使用相同的段寄存器值时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持很有限。在多处理系统中，所有与CPU都共享同一内存；这意味着RAM芯片可以由独立的CPU并发访问。因为在RAM芯片上的读或写操作必须串行的执行。因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间，作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含有一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如：双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。 仲裁器由硬件电路管理，是隐藏的。 快速访问分段机制如果每次都执行上述的过程，可能会比较耗时，因为 GDT 是存储在主存中的，每次都访问主存，可能会比较慢，所以为了提高逻辑地址到线性地址的转换速度，80x86 处理器提供了一组6个不可编程寄存器。每一个不可编程寄存器含有 8 个字节的段描述符，具体的值由相对应的段寄存器中的段描述符确定。每当一个段选择符被装入段寄存器，相对应的段描述符就由主存装入到对应的不可编程寄存器，这样就可以不需要上面三个过程中的前两个，就可以得到线性地址了。 分页机制页、页框和页表分页单元把线性地址转换成物理地址，其中的关键任务是把所请求的访问类型与线性地址的访问权限做对比。 页：为了更高效和更经济的管理内存，线性地址被分为以固定长度为单位的组，成为页。页内部连续的线性地址空间被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和对应的存取权限，而不用指定全部线性地址的存取权限。这里说页，同时指一组线性地址以及这组地址包含的数据 页框：分页单元把所有的 RAM 分成固定长度的页框，每一个页框包含一个页。页框是主存的一部分，因此也是一个存储区域。页和页框相比，前者只是一个数据块，可以存放在页框或者磁盘中。 页表：把线性地址映射到物理地址的数据结构成为页表，页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化 常规的分页从 80386 开始，Intel 处理器的页大小为 4KB。32 位的线性地址被分为 3 个域： Directory（目录）：最高 10 位 Table（页表）：中间 10 位 Offset（偏移量）：最低 12 位线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表成为页目录表，第二种转换表成为页表。 为什么需要两级呢？目的在于减少每个进程页表所需的 RAM 的数量。如果使用简单的一级页表，将需要高达 2^20 个表项来表示每个进程的页表，即时一个进程并不使用所有的地址，二级模式通过职位进程实际使用的那些虚拟内存区请求页表来减少内存容量。每个活动的进程必须有一个页目录，但是却没有必要马上为所有进程的所有页表都分配 RAM，只有在实际需要一个页表时候才给该页表分配 RAM。 页目录项和页表项的结构如下： Present 标志：为 1 则表示页在主存中；如果为 0 则表示不在内存中，如果执行一个地址转换的时候，所需的页表项或者页目录项中的该标志为 0，那么分页单元就把该线性地址存在在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。 包含页框物理地址最高 20 位的字段 Dirty：当对页框进行写操作时就设置这个标志 Read/Write 标志：含有页或者页表的存取权限 User/Supervisor：含有访问页或者页表所需的特权等级 了解了以上结构之后，我们看看如何从线性地址转换到物理地址的： 线性地址中的 Directory 字段决定页目录中的目录项，目录项指向适当的页表 线性地址中的 Table 字段又决定页表的页表项，页表项含有页所在页框的物理地址 线性地址中的 Offset 地段决定了页框内的相对位置，由于 offset 为 12 为，所以一页含有 4096 字节的数据 总结以上描述的为 80x86 微处理器硬件分页机制，不同架构的 64 位处理器分页机制，大体的思路就是将二级模式拓展为三级（ia64）或者四级（x86_64），以达到对更大范围寻址空间的支持。 笔记：16进制线性地址转换16进制的线性地址转化为地址的物理空间大小。如：0x00000000 - 0x08000000的物理空间大小为128MB 换算：0x08000000 === 134217728 (Bytes) 134217728(Bytes) / 1024 = 131072(KB) 131072(KB) / 1024 = 128(MB)]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>嵌入式</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提交搜索引擎收录（Google+Baidu）]]></title>
    <url>%2F2019%2F03%2F31%2FHexo%E6%8F%90%E4%BA%A4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%EF%BC%88Google-Baidu%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[递增与减运算符：++与--]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%80%92%E5%A2%9E%E4%B8%8E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A%2B%2B%E4%B8%8E--%2F</url>
    <content type="text"><![CDATA[前言紧凑的代码让程序更为整洁，而且通常其生成的机器代码效率更高。 递增与递减运算符递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)： 1. &quot;++&quot;出现在其作用的变量前面---前缀模式(++a) 如：q = 2*++a; • 首先，a递增1； • 然后，2乘以a，并将结果赋给q 2. &quot;++&quot;出现在其作用的变量后面---后缀模式(a++) 如：q = 2*a++; • 首先，2乘以a，并将结果赋给q； • 然后，a递增1 同理可得： &quot;--&quot;出现在其作用的变量前面 ----&gt; 前缀模式(--a) &quot;--&quot;出现在其作用的变量后面 ----&gt; 后缀模式(a--)]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客next主题添加Gitment评论系统]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言Hexo框架搭建好之后，默认的功能模块有限，因此很多模块需要我们自己去添加，对于我们的博客网站来说，没有评论系统怎么行呢？毕竟我们需要采集良言，及时发现文章的不足并且可以帮助仍有疑问的朋友解答问题。话不多说，我们开始搭建博客的评论系统吧。 Gitment评论系统我们首先了解一下国内的几个第三方评论系统，如“多说”，“畅言”，“友言”，“新浪云跟贴”： 多说，曾经较火的评论系统，网上介绍文章比较多，但已关闭，无法再用了。 畅言，sohu旗下的，但是需要个人博客备案后才能使用，但github pages个人博客感觉备案比较难。 友言，jiaThis旗下的，由于时http请求，github pages现在都是https了， 在https站点无法调用http请求，故也无法使用。 网易云跟贴，曾被当作“多说”的替代品，可惜官方通报说也将在2017.08.01关闭了。Gitment，一款由国内大神imsun开发的基于github issues的评论系统, 具体介绍请看项目主页 Gitment简介Gitment 是基于 GitHub Issues 的评论系统，是 imsun 利用 github 上的 issues 做的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown&amp;GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。想了解具体效果，可以点击查看官方Demo Page:Gitment Demo。 注册OAuth Application首先我们先去 OAuth application 进行注册，申请一个 Github OAuth Application。填写参考如下： Application name: 博客名字 Homepage URL: 网站主页地址(这里我填写的是域名或github项目地址/index.html大部分的默认网页都是index.html) Application description: 描述，选填 Authorization callback URL: 填写域名或github项目地址 填写相关信息时注意在 Authorization callback URL 一项填自己的网站url：1https://username.github.io 填写完毕后点击 Register application 若创建成功则将跳转到另外一个界面，此时我们会得到一个 client ID 和一个 client secret，它们将被用于之后的用户登录。 修改 _config.yml我们需要在 Hexo 主题目录下编辑修改 _config.yml 配置文件。不同的主题的配置文件存放路径有所差别，下面以 netx 主题为例说明：1next主题的配置文件路径：&quot;/themes/next/_config.yml&quot; 打开配置文件后，我们搜索关键字“Gitment”将定位到配置位置。默认的配置内容为：1234567891011121314# Gitmentgitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 我们修改成自己的配置内容：123456789101112131415# 添加Gitment评论系统# Gitmentgitment: enable: true # 修改为 true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: 123456 # 填写自己的 github ID github_repo: xxx.github.io # 存储评论内容的仓库名 client_id: abcd123456abcd # 填写获取到的 client_id client_secret: abcd123456efg # 填写获取到的 client_secret proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 获取自己的 Github ID在浏览器中打开下面的地址，”Your github username”需要修改为自己的Github username:1https://api.github.com/users/"Your github username" 验证 在 Hexo 根目录输入：1$ hexo s 浏览器打开地址：1http://localhost:4000/ 浏览自己的一篇博客到最后，如果发现有评论界面则大功告成！如果没有应该时配置信息没写对，请检查自己的配置内容。 但是此时出现了错误：1Error:Not Found 经过检查后发现是 owner 或 repo 配置错误 将 github_user 直接填写自己的Github用户名即可。 然而此时仍有可能出现如下的问题：或英文提示：”Error: Comments Not Initialized”。原因有如下两点： 在该页面的Gitment评论区登陆GitHub账号 之前OAuth Application callback填写有误若当点击评论区的“使用Github登陆”跳转出现报错，则可以确定是之前“OAuth Application callback”填写有误，我们需要返回到自己的Github设置上去修改过来：1Github头像下拉菜单 --&gt; Settings --&gt; 左边Developer settings下的OAuth Application --&gt; Register a new application，进入到填写相关信息页面。 12Authorization callback URL 一定要写自己Github Pages的URL.如：https://Yobe.github.io 检查无误可正常使用后，即可部署到我们的 Github 上:1$ hexo d -g]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机术语-簇]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD-%E7%B0%87%2F</url>
    <content type="text"><![CDATA[前言 数据存储在硬盘的时候都是以簇为单位，所以无论文件大小是多少，除非正好是簇大小的倍数，否则文件所占用的最后一个簇或多或少都会产生一些剩余的空间，且这些空间又不能给其它文件使用，即使这个文件只有0字节，也不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。 中文名 簇 外文名 CLUST 存储管理 最小单位 属 性 单位名称 本 意 “一群”、“一组” 解 释 一组扇区 微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇” 一个文件通常存放在一个或多个簇里，但至少要单独占据一个“簇”。 也就是说两个文件不能存放在同一个簇中。簇（CLUST）的本意就是“一群”、“一组”，即一组扇区(一个磁道可以分割成若干个大小相等的圆弧，叫扇区)的意思。因为扇区的单位太小，因此把它捆在一起，组成一个更大的单位更方便进行灵活管理。簇的大小通常是可以变化的，是由操作系统在所谓“（高级）格式化”时规定的，因此管理也更加灵活。 通俗地讲文件就好比是一个家庭，数据就是人，即家庭成员；所谓簇就是一些单元套房；扇区是组成这些单元套房的一个个大小相等的房间。一个家庭可能住在一套或多套单元房子里，但一套房子不能同时住进两个家庭的成员。 文件系统是操作系统与驱动器之间的接口，当操作系统请求从硬盘里读取一个文件时，会请求相应的文件系统（FAT 16/FAT32/NTFS）打开文件。扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；如果文件实际大小小于一簇，它也要占一簇的空间。如果文件实际大小大于一簇，根据逻辑推算，那么该文件就要占两个簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。 一个簇只能容纳一个文件占用，即使这个文件只有0字节，也决不允许两个文件或两个以上的文件共用一个簇，不然会造成数据混乱。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基本设置]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Hexo+Github Page+个人域名”搭建个人专属博客]]></title>
    <url>%2F2019%2F03%2F30%2F%E2%80%9CHexo%2BGithub_Page%2B%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E2%80%9D%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言使用 Hexo+Github我们快速的搭建自己的个人博客，整个过程下来我们几乎不需要什么金钱成本（在个人服务器上部署可选），所付出的仅仅是自己对于其的时间精力上的管理成本。而 Hexo 基于MakrDown 语法编辑页面，在书写方面我们将得到极大的便利。最后绑定自己的个人域名我们的博客访问过程将更加便利。 本文的操作环境为： Windows 10 64bit。 Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，我们可以非常方便快速地利用靓丽的主题生成自定义的静态网页。 Hexo的优缺点分析 优点 免费 - GitHub 快速 - Node运行环境、前端个人站点首选 简洁 - MarkDown 轻量 - 全部静态文件 支持导入WordPress等博客 不足 更换电脑不变 - 需重新安装环境 静态博客 - 不便于后期维护 多媒体管理不方便 Hexok工作原理hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。我们不需要将 Hexo 部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，也就是说我们可以几乎没有任何成本地搭建一个自己的个人博客。简而言之：hexo是个静态页面生成、上传的工具。 Hexo 环境搭建我们可以在服务器上或在自己的本地电脑上安装部署 Hexo，安装 Hexo 的过程非常简单，只需几分钟即可完成！ 安装前提在安装前，我们必须检查电脑中是否已安装下列应用程序，如果是第一次安装请先去对应的官网下载安装包： Node.js Git 安装Node.jsNode.js的过程非常简单按照提示安装即可，打开cmd命令行，成功界面如下： 安装gitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。我们用 git 来管理自己的hexo博客文章，并上传到GitHub。git的过程非常简单按照提示安装即可，安装成功后我们在电脑上任何位置鼠标右键能够出现如下两个选择： 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 安装Hexo前面 Node.js 和 git 安装好后，现在我们就可以安装hexo了，你可以先创建一个文件夹 blog ，然后在命令行模式下定位当前目录到这个文件夹下（或者在这个文件夹下直接右键git bash打开）（或者在文件下的路径处输入 cmd 并回车）。1$ npm install -g hexo-cli 初始化自己的 blog 文件夹（需要耐心等待）1$ hexo init 初始化完成后将会看到如下内容，即说明初始化成功：1INFO Start blogging with Hexo! 最后安装所需的组件：1$ npm install 万事具备！我们来开始首次体验 Hexo吧！输入下面的命令，将最后得到 Hexo 本地运行的地址复制到浏览器即可预览 demo：1$ hexo g &amp;&amp; hexo s 假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p [端口号]”来改变端口号。在 Hexo 保持在本地运行的状态时 “hexo s”，我们对 Hexo 的任何更改都会立即被应用，只需刷新网页即可预览。 Github部分如果没有自己的 Github 账户，就先去注册)自己的 Github 账户吧。注册完登录后，在GitHub.com中看到一个New repository，我们点击它以新建仓库。 接下来我们需要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。这里我是已经建过了： 在Github中创建的与自己用户名相同的仓库，会被识别为 Github page 的展示默认主页（唯一的），而其他仓库则被是为普通项目。 修改配置使与 Github 仓库关联打开“blog”根目录下的”_config.yml”。需要修改的地方有：网站名，介绍，关键字（这部分自己取），url 即是“http://用户名.github.io“。12345678910111213141516171819202122# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: YobeZhou # 网站名，默认为 Hexosubtitle:description: # 网站介绍keywords: # 网站关键字# author: John Doeauthor: 周岳标language: zh-Hans # 设置语言为汉语timezone:avatar: /images/touxiang.jpg # 头像# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# url: http://yoursite.comurl: YobeZhou.github.io # 你的网址，也为个人域名root: /permalink: :year/:month/:day/:title/permalink_defaults: 现在我们打开 Github 获取仓库地址, 点击头像 -&gt; Your profile 点击查看对应的仓库（即为之前新建的 Github page 专用仓库），之后点击“Clone or download”，复制仓库地址 紧接着我们回到刚刚编辑的”_config.yml”文件中，搜索定位“deploy”所在位置，我获取到的仓库地址为：“https://github.com/YobeZhou/YobeZhou.github.io.git” ，这要填写在下面的“repo: ”中，请参考配置：12345678# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:YobeZhou/YobeZhou.github.io.git branch: master# branch: [branch] #published. branch: master# message: [message] 对语法格式要求严格，修改时请务必注意缩进和空格。 最后生成部署即可！12生成命令： hexo g部署命令： hexo d 或者一键生成部署命令：1$ hexo d -g 第一次提交会弹出输入框要求你输入用户名、密码登录： 显示出 “INFO Deploy done: git” 表示成功发布到github上！现在在浏览器上输入 “用户名.github.io” 即可访问自己的博客（你可以把这个链接发布给小伙伴啦） 绑定个人域名域名申请域名解析博客域名升级HttpsGithub 从 2009 年开始支持自定义域名，从 2016 年开始 *.github.io 域名支持 Https，从2018年5月1日 GitHub Pages 上的自定义域名也开始支持 Https。Github 和 Let’s Encrypt 合作对建立在其上的自定义域名站点进行的证书颁发和认证。如果之前域名是做的 CNAME 或者 Alias 的 DNS 记录，则直接支持 Https 访问；如果是 A 记录做的解析，则需要更换 A 记录指向的 IP 地址为新的给定地址。最后在 Github Pages 仓库的设置页选中 “Enforce HTTPS” 选项即可。配置过程非常简单，设置完稍等几分钟再次访问自己的主页将会发现已经升级成功！ 后续学习本文中介绍完基于Hexo及Github page搭建专属的个人博客的详细方法。万事开头难，现在我们仅仅是把平台搭建好了，接下来我们应该趁热打铁继续深入学习探索，请参考我的其他文章：Hexo基本设置hexo使用技巧Hexo的专用编辑器-HexoEditor什么是Markdown？]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的专用编辑器-HexoEditor]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E7%9A%84%E4%B8%93%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8-HexoEditor%2F</url>
    <content type="text"><![CDATA[前言‘Hexo’ 是一款基于 ‘Node.js’ 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 ‘GitHub’ 和 ‘Coding’ 上，是搭建博客的首选框架。 由于 ‘Hexo’ 使用[markdown]语法的纯文本编辑，所以在写作的时候我们需要使用一些工具方能达到事半功倍的效果。 HexoEditor简介接下来要介绍给大家的 ‘HexoEditor’ 便是网上有人针对 ‘Hexo’ 做了优化的 ‘Markdown’ 编辑器，其使用 [Electron] 做框架，修改自 [Moeditor] 支持 Markdown，Latex 等。使用它我们可以为 ‘Hexo’ 下的博客更好的去书写内容。这是HexoEditor的开源项目地址。 快速下载安装在 ‘Github’ 项目中并没有给出，可安装的 ‘releases’ 版本，如想省去麻烦的安装过程请在下面的地址下载。下载地址： Windows x64: https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe Macx64: https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg 使用技巧 按键 方法 说明 Tab tabAdd 添加缩进 Shift - Tab tabSubtract 减少缩进 Ctrl - B toggleBlod 切换粗体 Ctrl - I toggleItalic 切换斜体 Ctrl - D toggleDelete 删除当前行 Ctrl - ` toggleComment 切换注解 Ctrl - L toggleUnOrderedList 切换无序列表 Ctrl - Alt - L toggleOrderedList 切换有序列表 Ctrl - ] toggleHeader 降级标题 Ctrl - [ toggleUnHeader 升级标题 Ctrl - = toggleBlockquote 增加引用 Ctrl - - toggleUnBlockquote 减少引用 Ctrl - U drawLink 添加超级链接 Ctrl - Alt - U drawImageLink 添加图片 Ctrl - T drawTable(row col) 添加表格(行 列) Ctrl - V pasteOriginContent 源内容粘贴 Shift - Ctrl - V pasteContent 智能粘贴 Alt - F formatTables 格式化表格 Ctrl - N 新建md文档 Ctrl - H 新建Hexo文档 Ctrl - O 打开md文件 Ctrl - S 保存文档 Shift - Ctrl - S 另存为 Alt - Ctrl - S 打开设置 Ctrl - W 切换写作模式 Ctrl - P 切换预览模式 Ctrl - R 切换阅读模式 提示: 在 Mac OS下, 请使用 Cmd 来代替 Ctrl .]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Markdown？]]></title>
    <url>%2F2019%2F03%2F30%2F%E4%BB%80%E4%B9%88%E6%98%AFMarkdown%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Markdown的简单介绍Markdown 是由 ‘John Gruber’ 和 ‘Aaron Swartz’ 共同创建的一种轻量级纯文本格式语法。Markdown 可以让用户“以易读、易写的纯文本格式来进行写作，然后可以将其转换为有效格式的 XHTML（或 HTML）“。Markdown 语法只包含一些非常容易记住的符号。其学习曲线平缓；你可以在炒蘑菇的同时一点点学习 Markdown 语法（大约 10 分钟）。通过使用尽可能简单的语法，错误率达到了最小化。除了拥有友好的语法，它还具有直接输出干净、有效的（X）HTML 文件的强大功能。如果你看过我的 HTML 文件，你就会知道这个功能是多么的重要。 ‘Markdown’ 格式语法的主要目标是实现最大的可读性。用户能够以纯文本的形式发布一份 ‘Markdown’ 格式的文件。用 ‘Markdown’ 进行文本写作的一个优点是易于在计算机、智能手机和个人之间共享。几乎所有的内容管理系统都支持 ‘Markdown’ 。它作为一种网络写作格式流行起来，其产生一些被许多服务采用的变种，比如 GitHub 和 Stack Exchange 。 我们可以使用任何文本编辑器来写 ‘Markdown’ 文件。但我建议使用一个专门为这种语法设计的编辑器。这篇文章中所讨论的软件允许你使用 ‘Markdown’ 语法来写各种格式的专业文档，包括博客文章、演示文稿、报告、电子邮件以及幻灯片等。另外，所有的应用都是在开源许可证下发布的，在 Linux、OS X 和 Windows 操作系统下均可用。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用技巧]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言最近开始使用Hexo写自己的个人博客，下面是对在使用过程中的一些技巧的总结。如果想要阅读官方的帮助文档请移步Hexo帮助文档。 写作篇Hexo使用[markdown]语法的纯文本编辑，文件后缀名.m ,文件默认存放在我们的站点目录下“/source/_post”文件夹下。 创建一篇新文章1$ hexo new [layout] &lt;title&gt; Hexo有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而我们自定义的其他布局和 post 相同，都将储存到 “source/_posts” 文件夹。可以在命令中指定文章的布局（layout），若不指定[layout]则布局将默认为 post，默认布局可以通过修改 _config.yml 中的 default_layout 参数来指定。 部署部署前请确保网络连接，并且当前目录在hexo的根目录。 方法一Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git 还可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。12345deploy:- type: git repo:- type: heroku repo: 方法二1hexo d -g 或hexo素质三连123$ hexo clean$ hexo d$ hexo -g Hexo中添加本地图片和使用网络图片方法一 相对引用由于首页和主页相对图片位置不一致，网站首页和内页很可能仅有一处能正常加载。1.调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True2.在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹3.最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片：1![Tip](/images/xx.jpg) 方法二 图床如SMMS图床无需注册以下是测试：1https://i.loli.net/2018/02/09/5a7d6a402e15e.jpg 注：请备份Delete Link,必要时访问此链接删除图片。]]></content>
      <categories>
        <category>Hexo相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
