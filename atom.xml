<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YobeZhou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="YobeZhou.github.io/"/>
  <updated>2019-08-29T06:14:48.365Z</updated>
  <id>YobeZhou.github.io/</id>
  
  <author>
    <name>YobeZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux搬砖三剑客之shell</title>
    <link href="YobeZhou.github.io/2019/08/29/0033-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bshell/"/>
    <id>YobeZhou.github.io/2019/08/29/0033-Linux搬砖三剑客之shell/</id>
    <published>2019-08-29T03:22:02.000Z</published>
    <updated>2019-08-29T06:14:48.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/shell/shell-logo.jpg" alt="linux-shell"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;这里讨论的shell，基于Bourne shell（默认shell）</p><h1 id="shell的特殊变量"><a href="#shell的特殊变量" class="headerlink" title="shell的特殊变量"></a>shell的特殊变量</h1><table><thead><tr><th align="center">特殊变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">$0</td><td align="center">当前脚本的文件名。</td></tr><tr><td align="center">$n</td><td align="center">这些变量对应于调用脚本的参数。这里n是对应于参数位置的正十进制数（第一个参数是$ 1，第二个参数是$ 2，依此类推）。</td></tr><tr><td align="center">$#</td><td align="center">提供给脚本的参数数量。</td></tr><tr><td align="center">$*</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ *相当于$ 1 $ 2。</td></tr><tr><td align="center">$@</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ @相当于$ 1 $ 2。</td></tr><tr><td align="center">$?</td><td align="center">执行最后一个命令的退出状态。退出状态是每个命令完成后返回的数值。通常，大多数命令如果成功则返回退出状态0，如果不成功则返回1。</td></tr><tr><td align="center">$$</td><td align="center">当前shell的进程号。对于shell脚本，这是它们执行的进程ID。</td></tr><tr><td align="center">$!</td><td align="center">最后一个后台命令的进程号。</td></tr></tbody></table><blockquote><p>$ *和$ @两者的行为相同，除非它们用双引号括起来，“”。这两个参数都指定命令行参数。但是，“$ *”特殊参数将整个列表作为一个参数，其间带有空格，“$ @”特殊参数获取整个列表并将其分隔为单独的参数。</p></blockquote><h1 id="shell的运算符"><a href="#shell的运算符" class="headerlink" title="shell的运算符"></a>shell的运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">（加法）在运算符的任一侧添加值</td><td align="center"><code>expr $a + $b</code> 将给出30</td></tr><tr><td align="center">-</td><td align="center">（减法）从左手操作数中减去右手操作数</td><td align="center"><code>expr $a - $b</code> 将给-10</td></tr><tr><td align="center">*</td><td align="center">（乘法）将运算符两侧的值相乘</td><td align="center"><code>expr $a \* $b</code> 将给出200</td></tr><tr><td align="center">/</td><td align="center">（除法）用左手操作数除左手操作数</td><td align="center"><code>expr $b / $a</code> 将给出2</td></tr><tr><td align="center">%</td><td align="center">（取模）用左手操作数除左手操作数并返回余数</td><td align="center"><code>expr $b ％ $a</code> 将给出0</td></tr><tr><td align="center">=</td><td align="center">（赋值）在左操作数中指定右操作数</td><td align="center">a = $b 会将b的值赋给a</td></tr><tr><td align="center">==</td><td align="center">（等于）比较两个数字，如果两个数字相同则返回true。</td><td align="center">[ $a == $b ] 会返回false。</td></tr><tr><td align="center">!=</td><td align="center">（不等于）比较两个数字，如果两个数字不同则返回true。</td><td align="center">[ $a != $b ] 会返回true。</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a -eq $b ] is not true.</td></tr><tr><td align="center">-ne</td><td align="center">检查两个操作数的值是否相等; 如果值不相等，则条件成立。</td><td align="center">[ $a -ne $b ] is true.</td></tr><tr><td align="center">-gt</td><td align="center">检查左操作数的值是否大于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -gt $b ] is not true.</td></tr><tr><td align="center">-lt</td><td align="center">检查左操作数的值是否小于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -lt $b ] is true.</td></tr><tr><td align="center">-ge</td><td align="center">检查左操作数的值是否大于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -ge $b ] is not true.</td></tr><tr><td align="center">-le</td><td align="center">检查左操作数的值是否小于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">$a -le $b ] is true.</td></tr></tbody></table><blockquote><p>所有条件表达式应放在方括号内并且周围有空格是非常重要的。例如，[ $a &lt;= $b ]是正确的，而[$a&lt;=$b]是不正确的。</p></blockquote><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">这是合乎逻辑的否定。这将真实条件反转为假，反之亦然。</td><td align="center">[ ! false ] is true.</td></tr><tr><td align="center">-o</td><td align="center">这是合乎逻辑的OR。如果其中一个操作数为true，则条件成立。</td><td align="center">[ $a -lt 20 -o $b -gt 100 ] is true.</td></tr><tr><td align="center">-a</td><td align="center">这是合乎逻辑的和。如果两个操作数都为真，则条件变为true，否则为false。</td><td align="center">[ $a -lt 20 -a $b -gt 100 ] is false.</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>&emsp;&emsp;示例中,假设变量a为“abc”，而变量b为“efg”。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a = $b ] is not true.</td></tr><tr><td align="center">!=</td><td align="center">检查两个操作数的值是否相等; 如果值不相等则条件变为真。</td><td align="center">[ $a != $b ] is true.</td></tr><tr><td align="center">-z</td><td align="center">检查给定的字符串操作数大小是否为零; 如果长度为零，则返回true。</td><td align="center">[ -z $a ] is not true.</td></tr><tr><td align="center">-n</td><td align="center">检查给定的字符串操作数大小是否为非零; 如果它是非零长度，则返回true。</td><td align="center">[ -n $a ] is not false.</td></tr><tr><td align="center">str</td><td align="center">检查str是否不是空字符串; 如果它是空的，则返回false。</td><td align="center">[ $a ] is not false.</td></tr></tbody></table><h2 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h2><p>&emsp;&emsp;这些运算符可用于测试与Unix文件相关的各种属性。<br>&emsp;&emsp;示例中，假设变量文件包含现有文件名“test”，其大小为100字节，并具有读取，写入和执行权限。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="center">检查文件是否是块特殊文件; 如果是，则条件成立。</td><td align="center">[ -b $file ] is false</td></tr><tr><td align="center">-c file</td><td align="center">检查文件是否是字符特殊文件; 如果是，则条件成立。</td><td align="center">[ -c $file ] is false.</td></tr><tr><td align="center">-d file</td><td align="center">检查文件是否是目录; 如果是，则条件成立。</td><td align="center">[ -d $file ] is not true.</td></tr><tr><td align="center">-f file</td><td align="center">检查文件是普通文件而不是目录或特殊文件; 如果是，则条件成立。</td><td align="center">[ -f $file ] is true.</td></tr><tr><td align="center">-g file</td><td align="center">检查文件是否设置了组ID（SGID）位; 如果是，则条件成立。</td><td align="center">[ -g $file ] is false.</td></tr><tr><td align="center">-k file</td><td align="center">检查文件是否设置了粘滞位; 如果是，则条件成立。</td><td align="center">[ -k $file ] is false.</td></tr><tr><td align="center">-p file</td><td align="center">检查文件是否是命名管道; 如果是，则条件成立。</td><td align="center">[ -p $file ] is false.</td></tr><tr><td align="center">-t file</td><td align="center">检查文件描述符是否打开并与终端关联; 如果是，则条件成立。</td><td align="center">[ -t $file ] is false.</td></tr><tr><td align="center">-u file</td><td align="center">检查文件是否设置了其用户ID（SUID）位; 如果是，则条件成立。</td><td align="center">[ -u $file ] is false.</td></tr><tr><td align="center">-r file</td><td align="center">检查文件是否可读; 如果是，则条件成立。</td><td align="center">[ -r $file ] is true.</td></tr><tr><td align="center">-w file</td><td align="center">检查文件是否可写; 如果是，则条件成立。</td><td align="center">[ -w $file ] is true.</td></tr><tr><td align="center">-x file</td><td align="center">检查文件是否可执行; 如果是，则条件成立。</td><td align="center">[ -x $file ] is true.</td></tr><tr><td align="center">-s file</td><td align="center">检查文件的大小是否大于0; 如果是，则条件成立。</td><td align="center">[ -s $file ] is true.</td></tr><tr><td align="center">-e file</td><td align="center">检查文件是否存在; 即使file是目录但存在，也是如此。</td><td align="center">[ -e $file ] is true.</td></tr></tbody></table><h1 id="shell修炼秘籍"><a href="#shell修炼秘籍" class="headerlink" title="shell修炼秘籍"></a>shell修炼秘籍</h1><h2 id="shell命令图谱"><a href="#shell命令图谱" class="headerlink" title="shell命令图谱"></a>shell命令图谱</h2><p><img src="/images/shell/Linux-shell-commands.png" alt="Linux-shell-commands"></p><h1 id="shell的种类"><a href="#shell的种类" class="headerlink" title="shell的种类"></a>shell的种类</h1><p><img src="/images/shell/shells.svg" alt="shells"></p><p>&emsp;&emsp;shell是一个用户终端，是内核与用户之间的翻译官。内核解释shell翻译过来的用户命令从而指挥CPU和其他计算机硬件如何执行特定任务。<br>每次用户登录时，都会启动shell。shell的类型取决于用户的选择，在大多数情况下默认设置为bash。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>&emsp;&emsp;Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell，它是用户帐户最常见的默认shell。</p><h2 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h2><p>&emsp;&emsp;C Shell被创造的Bill Joy在加州大学伯克利分校。他的主要目的是使用类似C语言的语法创建一个shell。因此，它包括控制结构和表达式语法之类的功能。<br>&emsp;&emsp;其他功能包括历史记录和编辑机制，别名，目录堆栈，代字符表示法，cdpath，作业控制和路径哈希等等。</p><h2 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h2><p>&emsp;&emsp;将tcsh被开发成为与C shell兼容。t in tcsh来自TENEX，这是一个操作系统。<br>&emsp;&emsp;tcsh与csh命令行编辑和其他功能等扩展非常接近。Mac OS X以前是tcsh默认配置，但在版本10.3中切换为bash。</p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>&emsp;&emsp;Z shell是专为交互式使用而设计的。<br>&emsp;&emsp;Z shell的一些功能包括拼写检查，在单个缓冲区中编辑多行命令，改进的变量和数组处理，自定义，可编程命令行完成和可主题提示。</p><h2 id="还有很多甚至更多"><a href="#还有很多甚至更多" class="headerlink" title="还有很多甚至更多"></a>还有很多甚至更多</h2><p>&emsp;&emsp;还有很多shell可供选择！当我们了解有关终端和shell的更多信息时，可能希望升级到另一个shell。但是一般而言，bash已经很好地满足我们的需求了。</p><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 90%;}</style><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 65%;}table th:nth-of-type(3){width: 25%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/shell/shell-logo.jpg&quot; alt=&quot;linux-shell&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="shell" scheme="YobeZhou.github.io/categories/shell/"/>
    
    
      <category term="shell" scheme="YobeZhou.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之vi&amp;vim</title>
    <link href="YobeZhou.github.io/2019/08/28/0032-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bvi&amp;vim/"/>
    <id>YobeZhou.github.io/2019/08/28/0032-Linux搬砖三剑客之vi&amp;vim/</id>
    <published>2019-08-28T03:40:30.000Z</published>
    <updated>2019-08-29T07:53:26.990Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vi&vim/vi&vimlog.png" alt="vi&amp;vimlog"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不可不知的两大编辑器：</p><ul><li>编辑器之神——Vim</li><li>神之编辑器——Emacs</li></ul><p>&emsp;&emsp;有趣的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a>。</p><p>&emsp;&emsp;vim与神的编辑器emacs的争论从来没有停止过。两种编辑器的设计哲学完全不同，风格迥异。vim的特点是Composability（组合性），Emacs的特点是Extensibility（可扩展性）。vim使用键序列输入，Emacs则经常使用组合键（同时按）输入，所以Emacs有个绰号Esc + Meta + Alt + Ctrl + Shift。正因为各种显著的差异各种争论在所难免，对此我们应该端正自己的心态：提高自己的格局，少一些争论。</p><h1 id="磨刀不误砍柴工"><a href="#磨刀不误砍柴工" class="headerlink" title="磨刀不误砍柴工"></a>磨刀不误砍柴工</h1><p>&emsp;&emsp;不做无谓的争论，工欲善其事必先利其器，我们只管选择一种自己顺手的工具（我选择vi&amp;vim）来学习，不断深入学习，提高自己的同时，不断与工具磨合，早日达到人剑合一的境界，笑看江湖。<br><img src="/images/vi&vim/huaji.jpg" alt="huaji"></p><h2 id="进入vim的姿势"><a href="#进入vim的姿势" class="headerlink" title="进入vim的姿势"></a>进入vim的姿势</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">vim filename</td><td align="center">打开或新建文件，并将光标置于第一行首</td></tr><tr><td align="center">vim +num filename</td><td align="center">打开文件，并将光标置于第n行首</td></tr><tr><td align="center">vim + filename</td><td align="center">打开文件，并将光标置于最后一行首</td></tr><tr><td align="center">vim +/pattern filename</td><td align="center">打开文件，并将光标置于第一个与pattern匹配的串处</td></tr><tr><td align="center">vim -r filename</td><td align="center">在上次正用vim编辑时发生系统崩溃，恢复filename</td></tr><tr><td align="center">vim filenae1…filenamen</td><td align="center">打开多个文件，依次编辑</td></tr></tbody></table><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">列出所有选项设置情况</td></tr><tr><td align="center">term</td><td align="center">设置终端类型</td></tr><tr><td align="center">ignorance</td><td align="center">在搜索中忽略大小写</td></tr><tr><td align="center">list</td><td align="center">显示制表位（Ctrl+1）和行尾标志（$）显示行号</td></tr><tr><td align="center">number</td><td align="center">显示由面向行的命令修改过的数目</td></tr><tr><td align="center">report</td><td align="center">显示简短的警告信息</td></tr><tr><td align="center">terse</td><td align="center">在转到别的文件时若没保存当前文件则显示NO write信息</td></tr><tr><td align="center">nomagic</td><td align="center">允许在搜索模式中，使用前面不带“V的特殊字符</td></tr><tr><td align="center">nowrapscan</td><td align="center">禁止vi在搜索到达文件两端时，又从另一端开始</td></tr><tr><td align="center">mesg</td><td align="center">允许vi显示其他用户用write写到自己终端上的信息</td></tr><tr><td align="center">:set number</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonumber</td><td align="center">不显示行号</td></tr><tr><td align="center">set ruler</td><td align="center">显示标尺</td></tr><tr><td align="center">set noruler</td><td align="center">不显示标尺</td></tr><tr><td align="center">:set hlsearch</td><td align="center">高亮显示查找到的单词</td></tr><tr><td align="center">:set nohlsearch</td><td align="center">关闭高亮显示</td></tr><tr><td align="center">:syntax on</td><td align="center">语法高亮显示行号</td></tr><tr><td align="center">:set tabstop=8</td><td align="center">设置tab大小，8为最常用最普遍的设置4.4个空格，8.正常的制表符，12:一个制表符4个空格，16.两个制表符</td></tr><tr><td align="center">:set autoindent</td><td align="center">自动缩进</td></tr><tr><td align="center">:set cindent</td><td align="center">C语言格式里面的自动缩进</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">k</td><td align="center">向上移动</td></tr><tr><td align="center">j</td><td align="center">向下移动</td></tr><tr><td align="center">h</td><td align="center">向左移动</td></tr><tr><td align="center">l</td><td align="center">向右移动</td></tr><tr><td align="center">k nk</td><td align="center">向上移动n行</td></tr><tr><td align="center">j nk</td><td align="center">向下移动n行</td></tr><tr><td align="center">h nh</td><td align="center">向左移动n行</td></tr><tr><td align="center">l nl</td><td align="center">向右移动n行</td></tr><tr><td align="center">Spach</td><td align="center">光标右移一个字符</td></tr><tr><td align="center">Backspace</td><td align="center">光标左移一个字符</td></tr><tr><td align="center">Enter</td><td align="center">光标下移一行</td></tr><tr><td align="center">w/W</td><td align="center">光标右移一个字至字首</td></tr><tr><td align="center">b/B</td><td align="center">光标左移一个字至字首</td></tr><tr><td align="center">e/e</td><td align="center">光标右移一个字至字尾</td></tr><tr><td align="center">)</td><td align="center">光标移至句尾</td></tr><tr><td align="center">(</td><td align="center">光标移至句首</td></tr><tr><td align="center">}</td><td align="center">光标移至段落开头</td></tr><tr><td align="center">{</td><td align="center">光标移至段落结尾</td></tr><tr><td align="center">n$</td><td align="center">光标移至第n行尾</td></tr><tr><td align="center">H</td><td align="center">光标移至屏幕顶行</td></tr><tr><td align="center">M</td><td align="center">光标移至屏幕中间行</td></tr><tr><td align="center">L</td><td align="center">光标移至屏幕最后行</td></tr><tr><td align="center">0</td><td align="center">（注意是数字零）光标移至当前行首</td></tr><tr><td align="center">^</td><td align="center">移动光标到行首第一个非空字符上去</td></tr><tr><td align="center">$</td><td align="center">光标移至当前行尾</td></tr><tr><td align="center">gg</td><td align="center">移到第一行</td></tr><tr><td align="center">G</td><td align="center">移到最后一行</td></tr><tr><td align="center">f</td><td align="center">移动光标到当前行的字符a上</td></tr><tr><td align="center">F</td><td align="center">与f相反</td></tr><tr><td align="center">%</td><td align="center">移动到与制匹配的括号上去（），}，Ⅱ，&lt;&gt;等</td></tr><tr><td align="center">nG</td><td align="center">移动到第n行上</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr></tbody></table><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+u</td><td align="center">向文件首翻半屏</td></tr><tr><td align="center">Ctrl+d</td><td align="center">向文件尾翻半屏</td></tr><tr><td align="center">Ctrl+f</td><td align="center">向文件尾翻一屏</td></tr><tr><td align="center">Ctrl+b</td><td align="center">向文件首翻一屏</td></tr><tr><td align="center">nz</td><td align="center">将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</td></tr></tbody></table><h2 id="插入文本类"><a href="#插入文本类" class="headerlink" title="插入文本类"></a>插入文本类</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">在光标前</td></tr><tr><td align="center">I</td><td align="center">在当前行首</td></tr><tr><td align="center">a</td><td align="center">光标后</td></tr><tr><td align="center">A</td><td align="center">在当前行尾</td></tr><tr><td align="center">o</td><td align="center">在当前行之下新开一行</td></tr><tr><td align="center">O</td><td align="center">在当前行之上新开一行</td></tr><tr><td align="center">r</td><td align="center">替换当前字符</td></tr><tr><td align="center">R</td><td align="center">替换当前字符及其后的字符，直至按ESC键</td></tr><tr><td align="center">s</td><td align="center">从当前光标位置处开始，以输入的文本替代指定数目的字符</td></tr><tr><td align="center">S</td><td align="center">删除指定数目的行，并以所输入文本代替之</td></tr><tr><td align="center">ncw/nCW</td><td align="center">修改指定数目的字</td></tr><tr><td align="center">nCC</td><td align="center">修改指定数目的行</td></tr></tbody></table><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x/X</td><td align="center">删除一个字符，x删除光标后的，而X删除光标前的</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词（删除光标位置到下一个单词开始的位置）</td></tr><tr><td align="center">dnw</td><td align="center">删除n个单词</td></tr><tr><td align="center">dne</td><td align="center">也可，只是删除到单词尾</td></tr><tr><td align="center">do</td><td align="center">删至行首</td></tr><tr><td align="center">d$</td><td align="center">删至行尾</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">ndd</td><td align="center">删除当前行及其后n-1行</td></tr><tr><td align="center">dnl</td><td align="center">向右删除n个字母</td></tr><tr><td align="center">dnh</td><td align="center">向左删除n个字母</td></tr><tr><td align="center">dnj</td><td align="center">向下删除n行，当前行+其上n行</td></tr><tr><td align="center">dnk</td><td align="center">向上删除n行，当期行+其下n行</td></tr><tr><td align="center">cnw[word]</td><td align="center">将n个word改变为word</td></tr><tr><td align="center">C$</td><td align="center">改变到行尾</td></tr><tr><td align="center">cc</td><td align="center">改变整行</td></tr><tr><td align="center">shift+j</td><td align="center">删除行尾的换行符，下一行接上来了</td></tr></tbody></table><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">粘贴用x或d删除的文本</td></tr><tr><td align="center">ynw</td><td align="center">复制n个单词</td></tr><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">ynl</td><td align="center">复制n个字符</td></tr><tr><td align="center">y$</td><td align="center">复制当前光标至行尾处</td></tr><tr><td align="center">nyy</td><td align="center">拷贝n行</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>|u          |撤销前一次的操作<br>|shif+u(U)  |撤销对该行的所有操作</p><h2 id="搜索及替换"><a href="#搜索及替换" class="headerlink" title="搜索及替换"></a>搜索及替换</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">/pattern</td><td align="center">从光标开始处向文件尾搜索pattern</td></tr><tr><td align="center">?pattern</td><td align="center">从光标开始处向文件首搜索pattern</td></tr><tr><td align="center">n</td><td align="center">在同一方向重复上一次搜索命令</td></tr><tr><td align="center">N</td><td align="center">在反方向上重复上一次搜索命令</td></tr><tr><td align="center">cw newword</td><td align="center">替换为newword</td></tr><tr><td align="center">n</td><td align="center">继续查找</td></tr><tr><td align="center">.</td><td align="center">执行替换</td></tr><tr><td align="center">:s/p1/p2/g</td><td align="center">将当前行中所有p1均用p2替代，g表示执行用c表示需要确认</td></tr><tr><td align="center">:n1,n2 s/p1/p2/g</td><td align="center">将第n1至n2行中所有p1均用p2替代</td></tr><tr><td align="center">:g/p1/s//p2/g</td><td align="center">将文件中所有p1均用p2替换</td></tr><tr><td align="center">:1,$ s/string1/string2/g</td><td align="center">在全文中将string1替换为string2</td></tr></tbody></table><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">,[a-z]</td><td align="center">在文中做标记，标记号可为a-z的26个字母</td></tr><tr><td align="center">`a</td><td align="center">移动到标记a处</td></tr></tbody></table><h2 id="visual模式"><a href="#visual模式" class="headerlink" title="visual模式"></a>visual模式</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">v</td><td align="center">进入visual模式</td></tr><tr><td align="center">V</td><td align="center">进入行的visual模式</td></tr><tr><td align="center">ctrl+V</td><td align="center">进如块操作模式用o和O改变选择的边的大小</td></tr><tr><td align="center">在所有行插入相同的内容如include&lt;</td><td align="center">将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按1（shit+），后插入要插入的文本，按IESC]完成</td></tr></tbody></table><h2 id="行方式命令"><a href="#行方式命令" class="headerlink" title="行方式命令"></a>行方式命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:n1,n2 co n3</td><td align="center">将n1行到n2行之间的内容拷贝到第n3行下</td></tr><tr><td align="center">:n1,n2 m n3</td><td align="center">将n1行到n2行之间的内容移至到第n3行下</td></tr><tr><td align="center">:n1,n2 d</td><td align="center">将n1行到n2行之间的内容删除</td></tr><tr><td align="center">:n1,n2 wlcommand</td><td align="center">将文件中n1行至n2行的内容作为command的输入并执行之</td></tr></tbody></table><blockquote><p>若不指定n1，n2，则表示将整个文件内容作为command的输入 |</p></blockquote><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">q[a-z]</td><td align="center">开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏</td></tr><tr><td align="center">reg</td><td align="center">显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]</td></tr></tbody></table><h2 id="操作窗口"><a href="#操作窗口" class="headerlink" title="操作窗口"></a>操作窗口</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:split</td><td align="center">分割一个窗口</td></tr><tr><td align="center">:split file.c</td><td align="center">为另一个文件fle.c分隔窗口</td></tr><tr><td align="center">:nsplit file.c</td><td align="center">为另一个文件file.c分隔窗口，并指定其行数</td></tr><tr><td align="center">ctrl + W</td><td align="center">在窗口中切换</td></tr><tr><td align="center">:close</td><td align="center">关闭当前窗口</td></tr></tbody></table><h2 id="文件及其他"><a href="#文件及其他" class="headerlink" title="文件及其他"></a>文件及其他</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:q退出vi</td><td align="center"></td></tr><tr><td align="center">:q!</td><td align="center">不保存文件并退出vi/vim</td></tr><tr><td align="center">:e filename</td><td align="center">打开文件filename进行编辑</td></tr><tr><td align="center">:e!</td><td align="center">放弃修改文件内容，重新载入该文件编辑</td></tr><tr><td align="center">:W</td><td align="center">保存当前文件</td></tr><tr><td align="center">:wq</td><td align="center">存盘后再退出</td></tr><tr><td align="center">:ZZ</td><td align="center">保存当前文档并退出vi/vim</td></tr><tr><td align="center">:!command</td><td align="center">执行shell命令command</td></tr><tr><td align="center">:r!command</td><td align="center">将命令command的输出结果放到当前行</td></tr><tr><td align="center">:n1,n2 write temp.c</td><td align="center"></td></tr><tr><td align="center">:read file.c</td><td align="center">将文件file.c的内容插入到当前光标所在的下面</td></tr></tbody></table><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><h2 id="寓教于乐"><a href="#寓教于乐" class="headerlink" title="寓教于乐"></a>寓教于乐</h2><p>&emsp;&emsp;<a href="https://vim-adventures.com/" target="_blank" rel="noopener">非常有趣的VIM学习小游戏。</a></p><h2 id="修炼秘籍-1"><a href="#修炼秘籍-1" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h2><h2 id="vim命令图解（中文版）"><a href="#vim命令图解（中文版）" class="headerlink" title="vim命令图解（中文版）"></a>vim命令图解（中文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-cn.png" alt="vim命令图解cn"></p><h2 id="vim命令图解（英文版）"><a href="#vim命令图解（英文版）" class="headerlink" title="vim命令图解（英文版）"></a>vim命令图解（英文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-en.png" alt="vim命令图解en"></p><h2 id="vim命令图解大全"><a href="#vim命令图解大全" class="headerlink" title="vim命令图解大全"></a>vim命令图解大全</h2><p>&emsp;&emsp;此图内容比较繁多，窃以为入门学习上面两个图足矣。<br><img src="/images/vi&vim/vim_cheat_sheet_for_programmers_screen.png" alt="vim命令图解大全"></p><p>&emsp;&emsp;当然，如果对此资源感兴趣，可前往<a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="noopener">此处获取</a>更全面的资源。</p><h2 id="其他未分类资源"><a href="#其他未分类资源" class="headerlink" title="其他未分类资源"></a>其他未分类资源</h2><p><img src="/images/vi&vim/preview.webp" alt="vim-preview"></p><p><img src="/images/vi&vim/vim-movement-commands-cheatsheet.png" alt="vim-movement-commands-cheatsheet"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>&emsp;&emsp;<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a></p><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vi&amp;vim/vi&amp;vimlog.png&quot; alt=&quot;vi&amp;amp;vimlog&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不可
      
    
    </summary>
    
      <category term="tools" scheme="YobeZhou.github.io/categories/tools/"/>
    
    
      <category term="tools" scheme="YobeZhou.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之git</title>
    <link href="YobeZhou.github.io/2019/08/21/0031-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BGit/"/>
    <id>YobeZhou.github.io/2019/08/21/0031-Linux搬砖三剑客之Git/</id>
    <published>2019-08-21T11:49:00.000Z</published>
    <updated>2019-08-29T07:53:42.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git/gswg-git-solid-choice.png" alt="gswg-git-solid-choice"></p><h1 id="git指令速查表"><a href="#git指令速查表" class="headerlink" title="git指令速查表"></a>git指令速查表</h1><p><img src="/images/git/git-cheat-sheet-large01-cn.png" alt="git指令速查表"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="复制一个已创建的仓库"><a href="#复制一个已创建的仓库" class="headerlink" title="复制一个已创建的仓库"></a>复制一个已创建的仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span></span><br></pre></td></tr></table></figure><h3 id="创建一个新的本地仓库"><a href="#创建一个新的本地仓库" class="headerlink" title="创建一个新的本地仓库"></a>创建一个新的本地仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><h3 id="显示工作路径下全部已修改的文件"><a href="#显示工作路径下全部已修改的文件" class="headerlink" title="显示工作路径下全部已修改的文件"></a>显示工作路径下全部已修改的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><h3 id="显示与上次提交版本文件的不同"><a href="#显示与上次提交版本文件的不同" class="headerlink" title="显示与上次提交版本文件的不同"></a>显示与上次提交版本文件的不同</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><h3 id="把当前所有修改添加到下次提交中"><a href="#把当前所有修改添加到下次提交中" class="headerlink" title="把当前所有修改添加到下次提交中"></a>把当前所有修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><h3 id="指定某个文件的修改添加到下次提交中"><a href="#指定某个文件的修改添加到下次提交中" class="headerlink" title="指定某个文件的修改添加到下次提交中"></a>指定某个文件的修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="提交本地的所有修改"><a href="#提交本地的所有修改" class="headerlink" title="提交本地的所有修改"></a>提交本地的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><h3 id="提交之前已标记的变化"><a href="#提交之前已标记的变化" class="headerlink" title="提交之前已标记的变化"></a>提交之前已标记的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br></pre></td></tr></table></figure><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><h3 id="从最新提交开始显示所有的提交记录"><a href="#从最新提交开始显示所有的提交记录" class="headerlink" title="从最新提交开始显示所有的提交记录"></a>从最新提交开始显示所有的提交记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><h3 id="显示指定文件的所有修改"><a href="#显示指定文件的所有修改" class="headerlink" title="显示指定文件的所有修改"></a>显示指定文件的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="谁，在什么时间，修改了文件的什么内容？"><a href="#谁，在什么时间，修改了文件的什么内容？" class="headerlink" title="谁，在什么时间，修改了文件的什么内容？"></a>谁，在什么时间，修改了文件的什么内容？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><h3 id="显示所有分支"><a href="#显示所有分支" class="headerlink" title="显示所有分支"></a>显示所有分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -av</span></span><br></pre></td></tr></table></figure><h3 id="切换当前分支"><a href="#切换当前分支" class="headerlink" title="切换当前分支"></a>切换当前分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于当前分支，创建新分支"><a href="#基于当前分支，创建新分支" class="headerlink" title="基于当前分支，创建新分支"></a>基于当前分支，创建新分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;new-branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于远端分支，创建新的可追溯的分支"><a href="#基于远端分支，创建新的可追溯的分支" class="headerlink" title="基于远端分支，创建新的可追溯的分支"></a>基于远端分支，创建新的可追溯的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="给当前的提交打标签"><a href="#给当前的提交打标签" class="headerlink" title="给当前的提交打标签"></a>给当前的提交打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h2><h3 id="列出当前配置的远端"><a href="#列出当前配置的远端" class="headerlink" title="列出当前配置的远端"></a>列出当前配置的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><h3 id="显示远端信息"><a href="#显示远端信息" class="headerlink" title="显示远端信息"></a>显示远端信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加新的远端"><a href="#添加新的远端" class="headerlink" title="添加新的远端"></a>添加新的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载远端的所有改动到本地，不会自动合并到当前"><a href="#下载远端的所有改动到本地，不会自动合并到当前" class="headerlink" title="下载远端的所有改动到本地，不会自动合并到当前"></a>下载远端的所有改动到本地，不会自动合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将本地版本发布到远端"><a href="#将本地版本发布到远端" class="headerlink" title="将本地版本发布到远端"></a>将本地版本发布到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除远端分支"><a href="#删除远端分支" class="headerlink" title="删除远端分支"></a>删除远端分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签"></a>发布标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><h2 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h2><h3 id="将分支合并到当前"><a href="#将分支合并到当前" class="headerlink" title="将分支合并到当前"></a>将分支合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将当前版本充值到分支中"><a href="#将当前版本充值到分支中" class="headerlink" title="将当前版本充值到分支中"></a>将当前版本充值到分支中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebse &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请勿重置已发布的提交！</p></blockquote><h3 id="退出重置"><a href="#退出重置" class="headerlink" title="退出重置"></a>退出重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突后继续重置"><a href="#解决冲突后继续重置" class="headerlink" title="解决冲突后继续重置"></a>解决冲突后继续重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><h3 id="使用配置好的合并工具去解决冲突"><a href="#使用配置好的合并工具去解决冲突" class="headerlink" title="使用配置好的合并工具去解决冲突"></a>使用配置好的合并工具去解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure><h3 id="在编辑器中手动解决冲去后，标记文件未已解决冲突"><a href="#在编辑器中手动解决冲去后，标记文件未已解决冲突" class="headerlink" title="在编辑器中手动解决冲去后，标记文件未已解决冲突"></a>在编辑器中手动解决冲去后，标记文件未已解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;resolved-file&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;resolved-file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="放弃工作目录下的所有修改"><a href="#放弃工作目录下的所有修改" class="headerlink" title="放弃工作目录下的所有修改"></a>放弃工作目录下的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD</span></span><br></pre></td></tr></table></figure><h3 id="放弃某个文件的所有本地修改"><a href="#放弃某个文件的所有本地修改" class="headerlink" title="放弃某个文件的所有本地修改"></a>放弃某个文件的所有本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过创建一个截然不同的新的提交重置一个提交"><a href="#通过创建一个截然不同的新的提交重置一个提交" class="headerlink" title="通过创建一个截然不同的新的提交重置一个提交"></a>通过创建一个截然不同的新的提交重置一个提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"><a href="#将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"></a>将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"><a href="#将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"></a>将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"><a href="#将HEAD重置到上一次提交的版本，并保留未提交的本地修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"></a>将HEAD重置到上一次提交的版本，并保留未提交的本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h1 id="git信条"><a href="#git信条" class="headerlink" title="git信条"></a>git信条</h1><p><img src="/images/git/git-cheat-sheet-large02-cn.png" alt="git信条"></p><h2 id="提交要对应修改"><a href="#提交要对应修改" class="headerlink" title="提交要对应修改"></a>提交要对应修改</h2><p>&emsp;&emsp;一次提交应该对应一个相关的改动，例如，两个不同的错误应该对应两次不同的提交、使它更容易让其他开发人员明白这个改动，如果这次改动存在问题，也可以方便的回滚到改动之前的状态，通过需存区标记功能。Git可以轻松打造非常精确的提交。</p><h2 id="经常性地提交修改"><a href="#经常性地提交修改" class="headerlink" title="经常性地提交修改"></a>经常性地提交修改</h2><p>&emsp;&emsp;经常的提交改动可以更方便为它作注释。从而更容易确保提交的注释和改动的一致性，通过频繁快速的提交来与其他的开发人员共享这些改动。那样就会避免或减少代码整合时带来的冲突、反之，非常庞大的提交将会增大整合时出现冲突的风险。</p><h2 id="不提交不完整地改动"><a href="#不提交不完整地改动" class="headerlink" title="不提交不完整地改动"></a>不提交不完整地改动</h2><p>&emsp;&emsp;对于一个很大的功能模块来说.完成后再提交并不意味若必须整体完成后才可以，而是要把它正确分割成小的完整的逻辑模块进行经常性的提变，一定不要提交一些不完整的改动。仅仅是因为下班。<br>&emsp;&emsp;同祥，如果只是为了得到一个干净的工作区城也不需要立即提交，可以通过Git的&lt;<stash>&gt;命令把这些改动移到另外的分支。</stash></p><h2 id="提交前进行代码测试"><a href="#提交前进行代码测试" class="headerlink" title="提交前进行代码测试"></a>提交前进行代码测试</h2><p>&emsp;&emsp;不要提交还没有经过完整测试的改动。只有经过测试，并确定无误的改动才能提交。把改动发送给开发团队其他成员前，必须确定所有修改已经完整测试过。这样才算是真正的完成。</p><h2 id="高质量地提交注释"><a href="#高质量地提交注释" class="headerlink" title="高质量地提交注释"></a>高质量地提交注释</h2><p>&emsp;&emsp;提交注释的开头需要一个少于50个字的简短说明.在一个空白的分割行之后要写出一个详细的提交细节.比如回答如下的两个问题；</p><ul><li>出于什么理由需要这个修改？</li><li>基于当前版本.具体改动了什么？</li></ul><p>&emsp;&emsp;为了和自动生成的注释保持一致（例如：git merge），一定要使用现在时态祈使句（比如使用change 而不要使用changed和changes）.</p><h2 id="版本控制不是备份"><a href="#版本控制不是备份" class="headerlink" title="版本控制不是备份"></a>版本控制不是备份</h2><p>&emsp;&emsp;版本控制系统具有一个很强大的附带功能，那就是服务器端的备份功能，但是不要把VCS当成一个备份系统。一定要注意.只需要提交那些有意义的改动而不要仅仅作为文件存储系统来使用。</p><h2 id="使用分支功能"><a href="#使用分支功能" class="headerlink" title="使用分支功能"></a>使用分支功能</h2><p>&emsp;&emsp;自始至终Git的核心就是提供一个快速，简单和灵活的分支功能，分支是一个非常优秀的工具，用来帮助开发人员解决在日常团队开发中存在的代码冲突的问题。因此分支功能应该广泛的运用在不同的开发流程中，比如：开发新的功能、修错等等。</p><h2 id="合理的工作流程"><a href="#合理的工作流程" class="headerlink" title="合理的工作流程"></a>合理的工作流程</h2><p>&emsp;&emsp;Git可以支持很多不同流程；长期分支.特性分支，合并或是重置，git-flow等等选择哪一种流程要取决于如下一些因素；什么项目，什么样的开发，部署模式和（可能是量重要的）开发团队人员的个人习惯.不管怎样。选择什么样的流程都要得到所用开发人员的认同并且一直遭循它</p><h2 id="使用帮助文档"><a href="#使用帮助文档" class="headerlink" title="使用帮助文档"></a>使用帮助文档</h2><p>&emsp;&emsp;显示给定git指令的帮助文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><p><a href="http://www.git-tower.com/learn" target="_blank" rel="noopener">http://www.git-tower.com/learn</a><br><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/</a><br><a href="http://www.git-scm.org/" target="_blank" rel="noopener">http://www.git-scm.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/git/gswg-git-solid-choice.png&quot; alt=&quot;gswg-git-solid-choice&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;git指令速查表&quot;&gt;&lt;a href=&quot;#git指令速查表&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="tools" scheme="YobeZhou.github.io/categories/tools/"/>
    
    
      <category term="git" scheme="YobeZhou.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android系统的编译</title>
    <link href="YobeZhou.github.io/2019/08/16/0030-Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E8%AF%91/"/>
    <id>YobeZhou.github.io/2019/08/16/0030-Android系统的编译/</id>
    <published>2019-08-16T01:16:12.000Z</published>
    <updated>2019-09-04T01:36:20.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_m_marshmallow.jpg" alt="android_m_marshmallow"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="noopener">http://source.android.com/source/initializing.html</a></p><h1 id="Android模块编译流程"><a href="#Android模块编译流程" class="headerlink" title="Android模块编译流程"></a>Android模块编译流程</h1><p>&emsp;&emsp;在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易。</p><h2 id="第一步使build-envsetup-sh生效"><a href="#第一步使build-envsetup-sh生效" class="headerlink" title="第一步使build/envsetup.sh生效"></a>第一步使build/envsetup.sh生效</h2><p>&emsp;&emsp;命令“source build/envsetup.sh”引入了 build/envsetup.sh脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> . build/envsetup.sh</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> source build/envsetup.sh</span><br></pre></td></tr></table></figure><blockquote><p>envsetup.sh脚本文件里包含vendorsetup.sh 、lunch、 m mm mmm的定义</p></blockquote><h2 id="第二步选择编译类型"><a href="#第二步选择编译类型" class="headerlink" title="第二步选择编译类型"></a>第二步选择编译类型</h2><p>&emsp;&emsp;lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。编译类型会影响最终系统中包含的模块。<br>&emsp;&emsp;如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，此时可以通过输入编号或者名称进行选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lunch full</span><br><span class="line"># 或者</span><br><span class="line">$ lunch &lt;选择一个特定的编译类型&gt;</span><br></pre></td></tr></table></figure><h2 id="最后一步make"><a href="#最后一步make" class="headerlink" title="最后一步make"></a>最后一步make</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make -j8</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里，make的选择有多种，具体内容分到下小节讨论。</p><blockquote><p>make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。</p></blockquote><h2 id="最最后一步清理编译结果"><a href="#最最后一步清理编译结果" class="headerlink" title="最最后一步清理编译结果"></a>最最后一步清理编译结果</h2><h3 id="清理所有编译结果"><a href="#清理所有编译结果" class="headerlink" title="清理所有编译结果"></a>清理所有编译结果</h3><p>&emsp;&emsp;执行清理，相当于：rm -rf out/。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make clean</span><br></pre></td></tr></table></figure><h3 id="清理一个指定模块的编译结果。"><a href="#清理一个指定模块的编译结果。" class="headerlink" title="清理一个指定模块的编译结果。"></a>清理一个指定模块的编译结果。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make clean-&lt;local_target&gt;</span><br></pre></td></tr></table></figure><h1 id="关于make的更多选项"><a href="#关于make的更多选项" class="headerlink" title="关于make的更多选项"></a>关于make的更多选项</h1><p>&emsp;&emsp;以下编译的编译选项可加上 “-j &lt;线程数&gt;”来启动多线程编译，加快编译的速度。</p><h2 id="编译当前选定产品的OTA全量包"><a href="#编译当前选定产品的OTA全量包" class="headerlink" title="编译当前选定产品的OTA全量包"></a>编译当前选定产品的OTA全量包</h2><p>&emsp;&emsp;也叫整包编译(all partitions)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make otapackage</span><br></pre></td></tr></table></figure><h2 id="编译所有内容"><a href="#编译所有内容" class="headerlink" title="编译所有内容"></a>编译所有内容</h2><p>&emsp;&emsp;编译所有内容，不管当前产品的定义中是否会包含。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make all</span><br></pre></td></tr></table></figure><h2 id="编译boot-img"><a href="#编译boot-img" class="headerlink" title="编译boot.img"></a>编译boot.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make bootimage</span><br></pre></td></tr></table></figure><h2 id="编译uboot-bin"><a href="#编译uboot-bin" class="headerlink" title="编译uboot.bin"></a>编译uboot.bin</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./mk &lt;uboot对应的版本&gt;  --systemroot</span><br></pre></td></tr></table></figure><h2 id="编译-recovery-img-ramdisk-recovery-img"><a href="#编译-recovery-img-ramdisk-recovery-img" class="headerlink" title="编译 recovery.img(ramdisk-recovery.img)"></a>编译 recovery.img(ramdisk-recovery.img)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make recoveryimage</span><br></pre></td></tr></table></figure><h2 id="编译vendor-img"><a href="#编译vendor-img" class="headerlink" title="编译vendor.img"></a>编译vendor.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make vendorimage</span><br></pre></td></tr></table></figure><h2 id="编译system-img"><a href="#编译system-img" class="headerlink" title="编译system.img"></a>编译system.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make systemimage</span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img"><a href="#编译-userdata-img" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make odm_image</span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img-1"><a href="#编译-userdata-img-1" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make userdataimage</span><br></pre></td></tr></table></figure><h2 id="编译ramdisk-img"><a href="#编译ramdisk-img" class="headerlink" title="编译ramdisk.img"></a>编译ramdisk.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make ramdisk</span><br></pre></td></tr></table></figure><h2 id="编译logo-img"><a href="#编译logo-img" class="headerlink" title="编译logo.img"></a>编译logo.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make logoimage</span><br></pre></td></tr></table></figure><h2 id="快速重建系统镜像"><a href="#快速重建系统镜像" class="headerlink" title="快速重建系统镜像"></a>快速重建系统镜像</h2><p>&emsp;&emsp;从已经编译出的包快速重建系统镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make snod</span><br></pre></td></tr></table></figure><h2 id="编译-dtb"><a href="#编译-dtb" class="headerlink" title="编译 dtb"></a>编译 dtb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make dtbimage</span><br></pre></td></tr></table></figure><h2 id="编译出-Android-的-SDK"><a href="#编译出-Android-的-SDK" class="headerlink" title="编译出 Android 的 SDK"></a>编译出 Android 的 SDK</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make sdk</span><br></pre></td></tr></table></figure><h2 id="编译所有-JNI-framework"><a href="#编译所有-JNI-framework" class="headerlink" title="编译所有 JNI framework"></a>编译所有 JNI framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make libandroid_runtime</span><br></pre></td></tr></table></figure><h2 id="编译所有-Java-framework"><a href="#编译所有-Java-framework" class="headerlink" title="编译所有 Java framework"></a>编译所有 Java framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make framework</span><br></pre></td></tr></table></figure><h2 id="编译系统服务和相关内容"><a href="#编译系统服务和相关内容" class="headerlink" title="编译系统服务和相关内容"></a>编译系统服务和相关内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make services</span><br></pre></td></tr></table></figure><h2 id="编译指定模块"><a href="#编译指定模块" class="headerlink" title="编译指定模块"></a>编译指定模块</h2><p>&emsp;&emsp;编译一个指定的模块，local_target 为模块的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make &lt;local_target&gt;</span><br></pre></td></tr></table></figure><h2 id="获取所有产品的编译配置信息"><a href="#获取所有产品的编译配置信息" class="headerlink" title="获取所有产品的编译配置信息"></a>获取所有产品的编译配置信息</h2><p>&emsp;&emsp;显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make dump-products</span><br></pre></td></tr></table></figure><h2 id="编译指定产品"><a href="#编译指定产品" class="headerlink" title="编译指定产品"></a>编译指定产品</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make PRODUCT-xxx-yyy</span><br></pre></td></tr></table></figure><h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><p>&emsp;&emsp;显示帮助信息，显示主要的make目标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make help</span><br></pre></td></tr></table></figure><h2 id="其他编译选项"><a href="#其他编译选项" class="headerlink" title="其他编译选项"></a>其他编译选项</h2><h3 id="m编译"><a href="#m编译" class="headerlink" title="m编译"></a>m编译</h3><p>m：编译整个安卓系统。（makes from the of the tree）</p><h3 id="mm编译"><a href="#mm编译" class="headerlink" title="mm编译"></a>mm编译</h3><p>mm：编译当前目录下的模块，当前目录下需要有Android.mk这个makefile文件，否则就往上找最近的Android.mk文件。（builds all of the moudles in the current directory）<br>mma：当前目录新增或删除文件后，可以用mma重新编译。</p><h3 id="mmm编译"><a href="#mmm编译" class="headerlink" title="mmm编译"></a>mmm编译</h3><p>mmm：编译指定路径下的模块，指定的路径下面需要有Android.mk这个makefile文件。（builds all of the moudles in the supplies directory）<br>mmma：指定目录下新增或删除文件后，可以用mmma重新编译。 // 未全编译的情况下，可以使用该命令单编译模块</p><h4 id="mmm命令的编译过程"><a href="#mmm命令的编译过程" class="headerlink" title="mmm命令的编译过程"></a>mmm命令的编译过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── build/core/main.mk（是Android编译系统的入口文件）</span><br><span class="line">    ├── build/core/config.mk（会定好编译类型和目标文件）</span><br><span class="line">        ├── build/core/definitions.mk（定义在编译过程中用到的宏）</span><br><span class="line">        ├── ONE_SHOT_MAKEFILE-&gt;build/core/package.mk（编译Apk库文件）</span><br><span class="line">            ├── build/core/java_library.mk（编译Java库文件）</span><br><span class="line">            ├── build/core/static_java_library.mk（编译Java静态库文件）</span><br><span class="line">            ├── build/core/shared_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/dynamic_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/binary.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/base_rules.mk （ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">                ├── build/core/static_library.mk（编译.a静态库文件）</span><br><span class="line">                ├── build/core/executable.mk（编译可执行文件）</span><br><span class="line">                ├── build/core/prebuilt.mk（编译已经预编译好的第三方库文件）</span><br><span class="line">            ├── build/core/Makfile（有system.img、boot.img、recovery.img等镜像文件生成规则）</span><br></pre></td></tr></table></figure><blockquote><p>环境变量ONE_SHOT_MAKEFILE中存放要编译模块的Android.mk的文件路径，如果环境变量值为空，表示执行的是m或者make命令，会对Android源代码中的所有模块进行编译。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_m_marshmallow.jpg&quot; alt=&quot;android_m_marshmallow&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Android" scheme="YobeZhou.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="YobeZhou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的分区和映像</title>
    <link href="YobeZhou.github.io/2019/08/15/0029-Android%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%98%A0%E5%83%8F/"/>
    <id>YobeZhou.github.io/2019/08/15/0029-Android的分区和映像/</id>
    <published>2019-08-15T01:18:03.000Z</published>
    <updated>2019-08-15T12:58:42.791Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/andioid_happy.jpg" alt="android"></p><h1 id="Android分区"><a href="#Android分区" class="headerlink" title="Android分区"></a>Android分区</h1><p>&emsp;&emsp;Android 设备包含若干个分区，这些分区在启动过程中发挥不同的作用。</p><ul><li>boot：boot 分区包含通过 mkbootimg 组合在一起的内核映像和 RAM 磁盘。为了直接刷写内核而不刷写新的 boot 分区，可以使用虚拟分区：</li></ul><ul><li>kernel：kernel 虚拟分区仅覆盖内核（zImage、zImage-dtb、Image.gz-dtb），方法是写入新的映像来覆盖旧的映像。为此，它会确定 eMMC 中现有内核映像的起始位置并将新内核映像复制到该位置。请记住，新内核映像可能会大于现有内核映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。如果提供的开发内核不兼容，则可能需要使用相关的内核模块更新 dtb 分区（如果存在）、vendor 分区或 system 分区。</li><li>ramdisk：ramdisk 虚拟分区通过将新映像写入旧磁盘来仅覆盖 RAM 磁盘。为此，它会确定 eMMC 中现有 ramdisk.img 的起始位置并将新 RAM 磁盘映像复制到该位置。请记住，新 RAM 磁盘映像可能会大于现有 RAM 磁盘映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。</li></ul><ul><li>system：system 分区主要包含 Android 框架。</li><li>recovery：recovery 分区用于存储在 OTA 过程中启动的恢复映像。如果设备支持 A/B 更新，则恢复映像可以是启动映像中包含的 RAM 磁盘，而不是单独的映像。</li><li>cache：cache 分区用于存储临时数据，如果设备使用 A/B 更新，则可以不要此分区。cache 分区不需要可从引导加载程序写入，而只需要可清空。大小取决于设备类型和 userdata 分区的可用空间。目前，50MB 至 100MB 应该没问题。</li><li>misc：misc 分区供恢复映像使用，存储空间不能小于 4KB。</li><li>userdata：userdata 分区包含用户安装的应用和数据，包括自定义数据。</li><li>metadata：如果设备被加密，则需要使用 metadata 分区，该分区的存储空间不能小于 16MB。</li><li>vendor：vendor 分区包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，则可以省略此分区。</li><li>radio：radio 分区包含无线装置映像。只有包含无线装置且在专用分区中包含无线装置专用软件的设备才需要此分区。</li><li>tos：tos 分区用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用。</li></ul><blockquote><p>摘自：<a href="https://source.android.google.cn/devices/bootloader/partitions-images" target="_blank" rel="noopener">source.android.google</a></p></blockquote><p>&emsp;&emsp;<em>注：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。</em></p><h1 id="通用的Android系统分区"><a href="#通用的Android系统分区" class="headerlink" title="通用的Android系统分区"></a>通用的Android系统分区</h1><p>&emsp;&emsp;安卓手机和平板一般包括以下分区：</p><ul><li>/u-boot   –&gt; 启动分区</li><li>/misc     –&gt; 升级存储的一些升级信息</li><li>/logo     –&gt; 开机画面</li><li>/recovery –&gt; 升级模块</li><li>/boot     –&gt; 内核分区</li><li>/system   –&gt; 系统分区</li><li>/data     –&gt; 用户数据分区</li></ul><p><img src="/images/Android/Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%8C%BA.jpg" alt="Android系统的分区"></p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p>&emsp;&emsp;此分区包含了一些系统设置和系统功能启用禁用的相关设置。这些设置包括CID(运营商或区域识别码）、USB设置和一些硬件设置等等。这是一个很重要的分区，如果此分区损坏或者部分数据丢失，手机的一些特定功能可能不能正常工作。</p><h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><p>&emsp;&emsp;在正常分区或内核分区被破坏，不能正常启动时，可以进入此分区进行恢复，他相当与一个简易的OS或blos，可以认为是一个boot分区的替代品，通过他可以让我们在这一分区进行备份维护和恢复，我们通常说的刷机便指的是此分区。<br><img src="/images/Android/android_recovery.jpg" alt="android_recovery"><br>&emsp;&emsp;进入此分区方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、通过 adb reboot recovery</span><br><span class="line">2、通过组合键，电源键+音量键</span><br></pre></td></tr></table></figure><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>&emsp;&emsp;此分区可以保证设备正常启动，它包含了kernel（内核）、ramdisk（虚拟内存盘：通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，可以极大的提高在其上进行的文件访问的速度)，如果没有此分区，设备通常不能正常启动。只有必要的时候，才去通过Recovery软件擦除（format）这个分区，一旦擦除，设备只有再重新安装一个新的boot分区，可以通过安装一个包含boot分区的ROM来实现，否则无法启动安卓系统。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>&emsp;&emsp;此分区用来存放除kernel和ramdisk以外的系统相关配置，他包括了用户界面、手机预装的软件等。擦除这个分区将会删除整个系统，但不会导致不能启动。可以通过进入Recovery程序或者bootloader程序中，安装一个新ROM(安卓系统)。</p><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>&emsp;&emsp;此分区包含了用户的数据信息，如：联系人、短信、设置、用户安装的程序的，擦除此分区，相当于手机恢复出厂设置，可以在Recovery模式中选择“data/factory reset ”擦除此分区。</p><p>&emsp;&emsp;此分区下的一些常见目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data/[packagename]/files 文件缓存目录,一般存小的文件缓存，如果是图片，不建议放这里，一般放到外置卡;</span><br><span class="line">/data/data/[packagename]/cache目录，存放一些其他缓存;</span><br><span class="line">/data/data/[packagename]/databases，存放数据库;</span><br><span class="line">/data/data/[packagename]/lib，应用的so目录;</span><br><span class="line">/data/data/[packagename]/shared_prefs 应用的SharedPreferences保存;</span><br></pre></td></tr></table></figure><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>&emsp;&emsp;此分区是安卓系统缓存区，他保存系统最常访问的数据和应用程序。擦除这个分区，不会影响个人数据，只是删除了这个分区中已经保存的缓存内容，缓存内容会在后续手机使用过程中重新自动生成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/andioid_happy.jpg&quot; alt=&quot;android&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android分区&quot;&gt;&lt;a href=&quot;#Android分区&quot; class=&quot;headerlink&quot; title=&quot;Android
      
    
    </summary>
    
      <category term="Android" scheme="YobeZhou.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="YobeZhou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android之源起</title>
    <link href="YobeZhou.github.io/2019/08/14/0028-Android%E4%B9%8B%E6%BA%90%E8%B5%B7/"/>
    <id>YobeZhou.github.io/2019/08/14/0028-Android之源起/</id>
    <published>2019-08-14T03:38:25.000Z</published>
    <updated>2019-08-15T01:21:34.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_in_google.jpg" alt="android_in_google"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android（读音：英：[‘ændrɔɪd]，美：[ˈænˌdrɔɪd]），常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。</p><h1 id="Android的成立"><a href="#Android的成立" class="headerlink" title="Android的成立"></a>Android的成立</h1><p>&emsp;&emsp;2003年10月，有“Android之父”之称的安迪·鲁宾（Andy Rubin）、利奇·米纳尔（Rich Miner）、尼克·席尔斯（Nick Sears）、克里斯·怀特（Chris White）在美国加利福尼亚州帕罗奥图共同成立了Android科技公司（Android Inc.），鲁宾把Android项目描述为“有极大的潜能以开发更智能的移动设备，以更了解其用家的位置及偏好。”该公司早期的方向是为数字相机开发先进的操作系统，此亦是2004年4月该公司向投资者介绍的基础。尽管Android科技公司的创始人和员工过去都具有各自的科技成就，但是Android科技公司的经营只显露出它在智能手机软件的方面，该公司随后认为相机市场不足以实现其目标，并且在5个月之后努力把Android转移到一款可跟Symbian及微软Windows Mobile互相媲美的手机操作系统。</p><p>Android的后续发展：</p><ul><li>2005年7月11日Android Inc.被美国科技企业Google收购。</li><li>2007年11月，Google与84家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良Android，随后，Google以Apache免费开放源代码许可证的授权方式，发布了Android的源代码，开放源代码加速了Android普及，让生产商推出搭载Android的智能手机，Android后来更逐渐拓展到平板电脑及其他领域上。</li><li>2010年末数据显示，Andrioid超越称霸逾十年的诺基亚Symbian系统，成为全球第一大智能手机操作系统。</li><li>2013年6月最高曾有5.38亿台活跃的安卓设备；2013年6月最高曾有10亿台活跃的安卓设备</li><li>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</li><li>2018年8月6日，Android 9宣布发行。</li></ul><h1 id="Android命名由来"><a href="#Android命名由来" class="headerlink" title="Android命名由来"></a>Android命名由来</h1><p>&emsp;&emsp;Android一词最早出现于法国作家维利耶·德·利尔－阿达姆·利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃（L’Ève future）》中。他把外表像人的机器人取名为Android。</p><h1 id="Android标志"><a href="#Android标志" class="headerlink" title="Android标志"></a>Android标志</h1><p>&emsp;&emsp;Android是一个全身绿色的机器人，半圆形的头部，有两支天线和空白的点作为眼睛。它的头部与身体之间有空白的区域，相似于一枚有平底的鸡蛋，两侧各有两个圆角矩形，作为它的双臂。Android的标志是由Ascender公司设计，颜色采用了PMS 376C和RGB中十六进制的#A4C639来绘制，这是Android操作系统的品牌象征。当中的文字使用了Ascender公司专门制作的称之为“Google Droid”的字体有时候，它会以纯文字的标志展示。</p><h2 id="Android机器人"><a href="#Android机器人" class="headerlink" title="Android机器人"></a>Android机器人</h2><p><img src="/images/Android/Android_Robot.png" alt="Android_Robot"></p><h2 id="Android字标"><a href="#Android字标" class="headerlink" title="Android字标"></a>Android字标</h2><p><img src="/images/Android/android_logo_no_2x.png" alt="android_logo"></p><h1 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h1><p>&emsp;&emsp;Android系统架构包含以下组件：<br><img src="/images/Android/ape_fwk_all.png" alt="ape_fwk_all"></p><ul><li>应用框架。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息，因此如果作为硬件开发者，需要非常了解其中的 API。</li><li>Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。</li><li>系统服务。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。 应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。</li><li>硬件抽象层 (HAL)。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。</li><li>Linux 内核。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含几个特殊的补充功能，例如：Low Memory Killer（一种内存管理系统，可更主动地保留内存）、唤醒锁定（一种 PowerManager 系统服务）、Binder IPC 驱动程序以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。</li></ul><h1 id="Android堆栈"><a href="#Android堆栈" class="headerlink" title="Android堆栈"></a>Android堆栈</h1><p>&emsp;&emsp;Android 是一个针对多种不同设备类型打造的开放源代码软件堆栈。Android 的主要目的是为运营商、OEM 和开发者打造一个开放的软件平台，使他们能够将创新理念变为现实，并推出能够卓有成效地改善用户移动体验的真实产品。<br>&emsp;&emsp;Android 平台的设计可确保不存在一个集中瓶颈，即没有任何行业参与者可一手限制或控制其他参与者的创新。这样，我们不但可以打造功能完善的高品质消费类产品，而且可以完全开放源代码，供第三方自由定制和移植。<br><img src="/images/Android/Android%E5%A0%86%E6%A0%88.png" alt="Android 堆栈"></p><h1 id="Android更新时间表"><a href="#Android更新时间表" class="headerlink" title="Android更新时间表"></a>Android更新时间表</h1><table><thead><tr><th align="center">名称</th><th align="center">版本号</th><th align="center">发行日期</th><th align="center">API等级</th><th align="center">安全性更新状态</th></tr></thead><tbody><tr><td align="center">Android 1.0</td><td align="center">1.0</td><td align="center">2008年9月23日</td><td align="center">1</td><td align="center">不支持</td></tr><tr><td align="center">Android Petit Four</td><td align="center">1.1</td><td align="center">2009年2月9日</td><td align="center">2</td><td align="center">不支持</td></tr><tr><td align="center">Android Cupcake</td><td align="center">1.5</td><td align="center">2009年4月27日</td><td align="center">3</td><td align="center">不支持</td></tr><tr><td align="center">Android Donut</td><td align="center">1.6</td><td align="center">2009年9月15日</td><td align="center">4</td><td align="center">不支持</td></tr><tr><td align="center">Android Eclair</td><td align="center">2.0 – 2.1</td><td align="center">2009年10月26日</td><td align="center">5 – 7</td><td align="center">不支持</td></tr><tr><td align="center">Android Froyo</td><td align="center">2.2 – 2.2.3</td><td align="center">2010年5月20日</td><td align="center">8</td><td align="center">不支持</td></tr><tr><td align="center">Android Gingerbread</td><td align="center">2.3 – 2.3.7</td><td align="center">2010年12月6日</td><td align="center">9 – 10</td><td align="center">不支持</td></tr><tr><td align="center">Android Honeycomb</td><td align="center">3.0 – 3.2.6</td><td align="center">2011年2月22日</td><td align="center">11 – 13</td><td align="center">不支持</td></tr><tr><td align="center">Android Ice Cream Sandwich</td><td align="center">4.0 – 4.0.4</td><td align="center">2011年10月18日</td><td align="center">14 – 15</td><td align="center">不支持</td></tr><tr><td align="center">Android Jelly Bean</td><td align="center">4.1 – 4.3.1</td><td align="center">2012年7月9日</td><td align="center">16 – 18</td><td align="center">不支持</td></tr><tr><td align="center">Android KitKat</td><td align="center">4.4 – 4.4.4</td><td align="center">2013年10月31日</td><td align="center">19 – 20</td><td align="center">不支持</td></tr><tr><td align="center">Android Lollipop</td><td align="center">5.0 – 5.1.1</td><td align="center">2014年11月12日</td><td align="center">21 – 22</td><td align="center">不支持</td></tr><tr><td align="center">Android Marshmallow</td><td align="center">6.0 – 6.0.1</td><td align="center">2015年10月5日</td><td align="center">23</td><td align="center">支持</td></tr><tr><td align="center">Android Nougat</td><td align="center">7.0 – 7.1.2</td><td align="center">2016年8月22日</td><td align="center">24 – 25</td><td align="center">支持</td></tr><tr><td align="center">Android Oreo</td><td align="center">8.0 – 8.1</td><td align="center">2017年8月21日</td><td align="center">26 – 27</td><td align="center">支持</td></tr><tr><td align="center">Android Pie</td><td align="center">9.0.0</td><td align="center">2018年8月6日</td><td align="center">28</td><td align="center">支持</td></tr><tr><td align="center">Android Q</td><td align="center">未知</td><td align="center">2019年3月13日</td><td align="center">29</td><td align="center">测试中</td></tr></tbody></table><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">wiki</a><br><a href="https://source.android.google.cn/setup/community" target="_blank" rel="noopener">Android社区</a></p></blockquote><style>table th:nth-of-type(1){width: 35%;}table th:nth-of-type(2){width: 16%;}table th:nth-of-type(3){width: 25%;}table th:nth-of-type(4){width: 16%;}table th:nth-of-type(5){width: 18%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_in_google.jpg&quot; alt=&quot;android_in_google&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Android" scheme="YobeZhou.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="YobeZhou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C语言操作符优先级</title>
    <link href="YobeZhou.github.io/2019/08/09/0027-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>YobeZhou.github.io/2019/08/09/0027-C语言操作符优先级/</id>
    <published>2019-08-09T06:32:01.000Z</published>
    <updated>2019-08-26T01:24:41.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/C&C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="C语言操作符优先级"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;表达式的求值顺序是由3个因素决定的：操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序。两个相邻的操作符哪个先执行取决于他们的优先级，如果两者的由优先级相同，那么它们的执行顺序由他们的结核性决定。</p><h1 id="C语言操作符的优先级"><a href="#C语言操作符的优先级" class="headerlink" title="C语言操作符的优先级"></a>C语言操作符的优先级</h1><p>表 5.1 列出了C语言中每个操作符的所有属性：</p><table><thead><tr><th align="center">操作符</th><th align="left">描述</th><th align="center">用法示例</th><th align="left">结果类型</th><th align="center">结合性</th><th align="left">控制求值顺序?</th></tr></thead><tbody><tr><td align="center">()</td><td align="left">聚组</td><td align="center">(表达式)</td><td align="left">与表达式同</td><td align="center">N/A</td><td align="left">否</td></tr><tr><td align="center">()</td><td align="left">函数调用</td><td align="center">rexp(rexp,…,rexp)</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">[]</td><td align="left">下标引用</td><td align="center">rexp[rexp]</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">.</td><td align="left">访问结构成员</td><td align="center">lexp.member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">-&gt;</td><td align="left">访问结构指针成员</td><td align="center">rexp-&gt;member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">后缀自增</td><td align="center">lexp++</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">后缀自减</td><td align="center">lexp–</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!</td><td align="left">逻辑反</td><td align="center">!rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">~</td><td align="left">按位取反</td><td align="center">~rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">单目，表示正值</td><td align="center">+rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">单目，表示负值</td><td align="center">-rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">前缀自增</td><td align="center">++lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">前缀自减</td><td align="center">–lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">间接访问</td><td align="center">*rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">取地址</td><td align="center">&amp;lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">sizeof</td><td align="left">取其长度</td><td align="center">sizeof rexp; sizeof(类型)</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">(类型)</td><td align="left">类型转换</td><td align="center">(类型)rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">乘法</td><td align="center">rexp*rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">/</td><td align="left">除法</td><td align="center">rexp/rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">%</td><td align="left">整数取余</td><td align="center">rexp%rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">加法</td><td align="center">rexp+rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">减法</td><td align="center">rexp&#45;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移位</td><td align="center">rexp&#60;&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移位</td><td align="center">rexp&gt;&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;</td><td align="left">大于</td><td align="center">rexp&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于</td><td align="center">rexp&gt;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;</td><td align="left">小于</td><td align="center">rexp&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于</td><td align="center">rexp&#60;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">==</td><td align="left">等于</td><td align="center">rexp==rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!=</td><td align="left">不等于</td><td align="center">rexp!=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">位于</td><td align="center">rexp&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">^</td><td align="left">位异或</td><td align="center">rexp^rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;</td><td align="left">位或</td><td align="center">rexp&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;&amp;</td><td align="left">逻辑与</td><td align="center">rexp&amp;&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;&#124;</td><td align="left">逻辑或</td><td align="center">rexpre&#124;&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr><tr><td align="center">?:</td><td align="left">条件操作符</td><td align="center">rexp?rexp:rexp</td><td align="left">rexp</td><td align="center">N/A</td><td align="left">是</td></tr><tr><td align="center">=</td><td align="left">赋值</td><td align="center">lexp=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+=</td><td align="left">以…加</td><td align="center">lexp+=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">-=</td><td align="left">以…减</td><td align="center">lexp-=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#42;=</td><td align="left">以…乘</td><td align="center">lexp &#42;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">/=</td><td align="left">以…除</td><td align="center">lexp/=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">%=</td><td align="left">以…取模</td><td align="center">lexp%=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">以…左移</td><td align="center">lexp&lt;&lt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">以…右移</td><td align="center">lexp&gt;&gt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;=</td><td align="left">以…与</td><td align="center">lexp&amp;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">^=</td><td align="left">以…异或</td><td align="center">lexp^=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#124;=</td><td align="left">以…或</td><td align="center">lexp&#124;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">,</td><td align="left">逗号</td><td align="center">rexp,rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr></tbody></table><h1 id="附：Markdown特殊字符转义"><a href="#附：Markdown特殊字符转义" class="headerlink" title="附：Markdown特殊字符转义"></a>附：Markdown特殊字符转义</h1><p>&emsp;&emsp;虽然hexo的语法是Markdown格式的，但是在书写时对于特殊字符使用“\“转义是不严谨的做法，最好的方式是使用特殊字符对应的编码，对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &amp;emsp;          --&gt; 空格(Space)</span><br><span class="line">!   &amp;#33;           --&gt; 惊叹号 (Exclamation mark) </span><br><span class="line">”   &amp;#34; &amp;quot;    --&gt; 双引号 (Quotation mark)</span><br><span class="line">#   &amp;#35;           --&gt; 数字标志 (Number sign)</span><br><span class="line">$   &amp;#36;           --&gt; 美元标志(Dollar sign)</span><br><span class="line">%   &amp;#37;           --&gt; 百分号(Percent sign)</span><br><span class="line">&amp;   &amp;#38; &amp;amp;     --&gt; 和号(Ampersand)</span><br><span class="line">|   &amp;#124;          --&gt; 竖线(Vertical bar) </span><br><span class="line">‘   &amp;#39;           --&gt; 单引号(Apostrophe) </span><br><span class="line">(   &amp;#40;           --&gt; 小括号左边部分(Left parenthesis) </span><br><span class="line">)   &amp;#41;           --&gt; 小括号右边部分(Right parenthesis) </span><br><span class="line">+   &amp;#43;           --&gt; 加号(Plus sign)</span><br><span class="line">-   &amp;#45; &amp;minus;   --&gt; 减号(Minus sign)</span><br><span class="line">*   &amp;#42;           --&gt; 星号(Asterisk)</span><br><span class="line">\   &amp;#92;           --&gt; 反斜杠(Reverse solidus (backslash)) </span><br><span class="line">&lt;   &amp;#60; &amp;lt;      --&gt; 小于号(Less than) </span><br><span class="line">=   &amp;#61;           --&gt; 等于符号(Equals sign)</span><br><span class="line">&gt;   &amp;#62;           --&gt; 大于号(Greater than)</span><br><span class="line">?   &amp;#63;           --&gt; 问号(Question mark)</span><br><span class="line">@   &amp;#64;           --&gt; 在标志(Commercial at)</span><br><span class="line">[   &amp;#91;           --&gt; 中括号左边部分(Left square bracket) </span><br><span class="line">]   &amp;#93;           --&gt; 中括号右边部分(Right square bracket)</span><br><span class="line">&#123;   &amp;#123;          --&gt; 大括号左边部分(Left curly brace) </span><br><span class="line">&#125;   &amp;#125;          --&gt; 大括号右边部分(Right curly brace)</span><br></pre></td></tr></table></figure><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 20%;}table th:nth-of-type(3){width: 30%;}table th:nth-of-type(4){width: 15%;}table th:nth-of-type(5){width: 10%;}table th:nth-of-type(6){width: 15%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/C&amp;C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg&quot; alt=&quot;C语言操作符优先级&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Repo入门</title>
    <link href="YobeZhou.github.io/2019/08/08/0026-repo%E5%85%A5%E9%97%A8/"/>
    <id>YobeZhou.github.io/2019/08/08/0026-repo入门/</id>
    <published>2019-08-08T09:49:55.000Z</published>
    <updated>2019-08-09T06:33:18.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>&emsp;&emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自动化部分开发工作流程。但是Repo并不是要取代Git，只是为了让Git更容易使用。repo命令只是一个可执行的Python脚本，我们可以将其放在路径中的任何位置。</p><h1 id="Repo、Git、Gerrit三者的区别"><a href="#Repo、Git、Gerrit三者的区别" class="headerlink" title="Repo、Git、Gerrit三者的区别"></a>Repo、Git、Gerrit三者的区别</h1><h2 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h2><p>&emsp;&emsp;Git 是一个开放源代码的版本控制系统，专用于处理分布在多个代码库上的大型项目。在 Android 环境中，我们会使用 Git 执行本地操作，例如建立本地分支、提交、查看更改、修改。</p><h2 id="1-2-Repo"><a href="#1-2-Repo" class="headerlink" title="1.2 Repo"></a>1.2 Repo</h2><p>&emsp;&emsp;Repo 是我们以 Git 为基础构建的代码库管理工具。Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到我们的修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让我们在 Android 环境中更轻松地使用 Git。Repo 命令是一段可执行的 Python 脚本，我们可以将其放在路径中的任何位置。使用 Android 源代码文件时，就可以使用 Repo 执行跨网络操作。例如，可以借助单个 Repo 命令，将文件从多个代码库下载到本地工作目录。</p><h2 id="1-3-Gerrit"><a href="#1-3-Gerrit" class="headerlink" title="1.3 Gerrit"></a>1.3 Gerrit</h2><p>&emsp;&emsp;Gerrit 是一个基于网页的代码审核系统，适用于使用 Git 的项目。Gerrit 允许所有授权用户提交更改（如果通过代码审核，这些更改会自动纳入项目中），以此鼓励其他人更集中地使用 Git。此外，Gerrit 可以在浏览器中并排显示更改，并支持代码内注释，使得审核工作变得更轻松！</p><h1 id="2-Repo的工作原理"><a href="#2-Repo的工作原理" class="headerlink" title="2. Repo的工作原理"></a>2. Repo的工作原理</h1><p>&emsp;&emsp;repo需要关注当前git库的数量、名称、路径等，有了这些基本信息，才能对这些git库进行操作。通过集中维护所有git库的清单，repo可以方便的从清单中获取git库的信息。 这份清单会随着版本演进升级而产生变化，同时也有一些本地的修改定制需求，所以，repo是通过一个git库来管理项目的清单文件的，这个git库名字叫manifests。<br>&emsp;&emsp;当打开repo这个可执行的python脚本后，发现代码量并不大(不超过1000行)，难道仅这一个脚本就完成了AOSP数百个git库的管理吗？并非如此。 repo是一系列脚本的集合，这些脚本也是通过git库来维护的，这个git库名字叫repo。<br>&emsp;&emsp;在客户端使用repo初始化一个项目时，就会从远程把manifests和repo这两个git库拷贝到本地，但这对于Android开发人员来说，又是近乎无形的(一般通过文件管理器，是无法看到这两个git库的)。 repo将自动化的管理信息都隐藏根目录的.repo子目录中。</p><h1 id="3-安装Repo"><a href="#3-安装Repo" class="headerlink" title="3. 安装Repo"></a>3. 安装Repo</h1><p>创建目录并修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h2 id="3-1-下载repo"><a href="#3-1-下载repo" class="headerlink" title="3.1 下载repo"></a>3.1 下载repo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x ~/bin/repo</span></span><br></pre></td></tr></table></figure><h2 id="3-3-获取帮助"><a href="#3-3-获取帮助" class="headerlink" title="3.3 获取帮助"></a>3.3 获取帮助</h2><p>&emsp;&emsp;安装 Repo 后，运行以下命令可以找到最新文档（开头是包含所有命令的摘要）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-查询具体命令的帮助"><a href="#3-4-查询具体命令的帮助" class="headerlink" title="3.4 查询具体命令的帮助"></a>3.4 查询具体命令的帮助</h2><p>&emsp;&emsp;在 Repo 树中运行以下命令来获取有关某个命令的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> &lt;COMMAND&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-查看Repo-init-参数的说明和选项列表"><a href="#3-5-查看Repo-init-参数的说明和选项列表" class="headerlink" title="3.5 查看Repo init 参数的说明和选项列表"></a>3.5 查看Repo init 参数的说明和选项列表</h2><p>&emsp;&emsp;此命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 <a href="https://source.android.com/source/using-repo.html#init" target="_blank" rel="noopener">init</a>。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> init</span></span><br></pre></td></tr></table></figure><h1 id="4-初始化仓库"><a href="#4-初始化仓库" class="headerlink" title="4. 初始化仓库"></a>4. 初始化仓库</h1><p>&emsp;&emsp;初始化仓库命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示范：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo init -u https://android.googlesource.com/platform/manifest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这将在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。<br>选项：</p><ul><li>-u：指定要从中检索清单代码库的网址。可以在 <a href="https://android.googlesource.com/platform/manifest" target="_blank" rel="noopener">https://android.googlesource.com/platform/manifest</a> 中找到常见清单</li><li>-m：在代码库中选择清单文件。如果未选择任何清单名称，则会默认选择 default.xml。</li><li>-b：指定修订版本，即特定的清单分支。</li></ul><blockquote><p>注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo/ 的父目录或相应父目录的子目录。</p></blockquote><h1 id="5-拉取仓库"><a href="#5-拉取仓库" class="headerlink" title="5. 拉取仓库"></a>5. 拉取仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo sync PROJECT0 PROJECT1 PROJECT2 ...</span></span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-j <numbers>： 多任务，一般8核心可以开到16任务,过多会起反作用</numbers></li><li>-c： 只下载当前分支代码</li><li>-d： 让工程回退到manifest指定的版本</li><li>-f： 如果某个工程同步失败，继续同步</li></ul><h1 id="6-修改仓库结构"><a href="#6-修改仓库结构" class="headerlink" title="6. 修改仓库结构"></a>6. 修改仓库结构</h1><p>&emsp;&emsp;如果想修改repo的结构，应该在 .repo/manifests 文件夹里面修改 default.xml 文件，然后用git命令提交。default.xml 文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">"git://git.mygit.com/"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"kk-shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">"1"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"packages/shift/VideoPlayer"</span> <span class="attr">name</span>=<span class="string">"platform/packages/shift/VideoPlayer"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"another_manifest.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>该文件内容的理解，请移步</p></blockquote><h1 id="7-理解repo-init后生成的-repo目录结构"><a href="#7-理解repo-init后生成的-repo目录结构" class="headerlink" title="7. 理解repo init后生成的.repo目录结构"></a>7. 理解repo init后生成的.repo目录结构</h1><p>&emsp;&emsp;当我们执行repo init命令之后会在当前目录下生成’.repo’目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree .repo -L 1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests</span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml -&gt; manifests/default.xml</span><br><span class="line">├── project.list</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br></pre></td></tr></table></figure><p>.repo目录理解：</p><ul><li>manifests：一个git库，包含default.xml文件，用于描述repo所管理的git库的信息</li><li>manifests.git：manifest这个git库的实体，manifest/.git目录下的所有文件都会链接到该目录</li><li>manifests/default.xml：工作树的主配置文件，一般不要编辑这个文件</li><li>projects/：每个git工程的 .git结构</li><li>manifest.xml：这是一个指向 .repo/manifests/ 目录中所选清单的符号链接</li><li>project.list：git库的所有仓库列表</li><li>repo/： 一个git库，包含repo运行的所有脚本</li></ul><h1 id="8-default-xml-文件解读"><a href="#8-default-xml-文件解读" class="headerlink" title="8. default.xml 文件解读"></a>8. default.xml 文件解读</h1><ul><li>manifest<br>&emsp;&emsp;这个是配置的顶层元素，即根标志</li><li>remote</li></ul><ul><li>name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。</li><li>alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url</li><li>fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径</li><li>review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果</li></ul><ul><li>default<br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</li></ul><ul><li>remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了）</li><li>revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch</li><li>sync_j ： 在repo sync中默认并行的数目</li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li></ul><ul><li>manifest-server<br>它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务，它要支持一下RPC方法：</li></ul><ul><li>GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。</li><li>target参数来自环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT，组成$TARGET_PRODUCT-$TARGET_BUILD_VARIANT</li><li>GetManifest(tag) ：返回指定tag的manifest</li></ul><ul><li>project<br>需要clone的单独git</li></ul><ul><li>name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name</li><li>path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样</li><li>remote ：定义remote name，如果没有定义的话就用default中定义的remote name</li><li>revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值</li><li>groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于</li><li>name:’name’ 和path:’path’组。例如<project name="monkeys" path="barrel-of">，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载</project></li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li><li>upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间</li><li>annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量</li></ul><ul><li>include<br>通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径)</li></ul><ul><li>name ：另一个需要导入的manifest文件名字<br>可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project</li></ul><ul><li>remove-project<br>&emsp;&emsp;从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义</li></ul><h1 id="9-Google提供的参考资源"><a href="#9-Google提供的参考资源" class="headerlink" title="9. Google提供的参考资源"></a>9. Google提供的参考资源</h1><p>&emsp;&emsp;主页：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;错误报告：<a href="https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo" target="_blank" rel="noopener">https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo</a><br>&emsp;&emsp;资料来源：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;概述：<a href="https://source.android.com/source/developing.html" target="_blank" rel="noopener">https://source.android.com/source/developing.html</a><br>&emsp;&emsp;文档：<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">https://source.android.com/source/using-repo.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自
      
    
    </summary>
    
      <category term="Git" scheme="YobeZhou.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="YobeZhou.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C语言显示数据处理进度条</title>
    <link href="YobeZhou.github.io/2019/07/11/0025-C%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>YobeZhou.github.io/2019/07/11/0025-C语言显示数据处理进度条/</id>
    <published>2019-07-11T07:03:41.000Z</published>
    <updated>2019-07-11T09:42:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。<br>&emsp;&emsp;我们见过比如使用git clone命令下载的时候显示的进度那样的效果，类似的还有很多，很多linux命令执行后一般都会有进度条显示，那么我们该怎样实现那样的效果呢？</p><blockquote><p>操作环境：linux；Linux+GCC</p></blockquote><h1 id="从C语言printf格式化控制台移动光标说起"><a href="#从C语言printf格式化控制台移动光标说起" class="headerlink" title="从C语言printf格式化控制台移动光标说起"></a>从C语言printf格式化控制台移动光标说起</h1><p>&emsp;&emsp;在Linux环境下，光标的移动、背景色和字体颜色的设置非常简单。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[47;31mhello world\033[5m"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;47是字背景颜色, 31是字体的颜色, hello world是字符串. 后面的\033[5m是控制码。字背景颜色范围: 40–49 字颜色: 30–39。<br>表2-1 字背景颜色及字颜色范围表</p><table><thead><tr><th align="center">数值</th><th align="left">背景颜色</th><th align="center">数值</th><th align="left">字颜色</th></tr></thead><tbody><tr><td align="center">40</td><td align="left">黑</td><td align="center">30</td><td align="left">黑</td></tr><tr><td align="center">41</td><td align="left">红</td><td align="center">31</td><td align="left">红</td></tr><tr><td align="center">42</td><td align="left">绿</td><td align="center">32</td><td align="left">绿</td></tr><tr><td align="center">43</td><td align="left">黄</td><td align="center">33</td><td align="left">黄</td></tr><tr><td align="center">44</td><td align="left">蓝</td><td align="center">34</td><td align="left">蓝</td></tr><tr><td align="center">45</td><td align="left">紫</td><td align="center">35</td><td align="left">紫</td></tr><tr><td align="center">46</td><td align="left">深绿</td><td align="center">36</td><td align="left">深绿</td></tr><tr><td align="center">47</td><td align="left">白色</td><td align="center">37</td><td align="left">白色</td></tr></tbody></table><p>表2-2 ANSI控制码表</p><table><thead><tr><th align="center">ANSI控制码</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">\033[0m</td><td align="left">关闭所有属性</td></tr><tr><td align="center">\033[1m</td><td align="left">设置高亮度</td></tr><tr><td align="center">\03[4m</td><td align="left">下划线</td></tr><tr><td align="center">\033[5m</td><td align="left">闪烁</td></tr><tr><td align="center">\033[7m</td><td align="left">反显</td></tr><tr><td align="center">\033[8m</td><td align="left">消隐</td></tr><tr><td align="center">\033[30m – \033[37m</td><td align="left">设置前景色</td></tr><tr><td align="center">\033[40m – \033[47m</td><td align="left">设置背景色</td></tr><tr><td align="center">\033[nA</td><td align="left">光标上移n行</td></tr><tr><td align="center">\03[nB</td><td align="left">光标下移n行</td></tr><tr><td align="center">\033[nC</td><td align="left">光标右移n行</td></tr><tr><td align="center">\033[nD</td><td align="left">光标左移n行</td></tr><tr><td align="center">\033[y;xH</td><td align="left">设置光标位置</td></tr><tr><td align="center">\033[2J</td><td align="left">清屏</td></tr><tr><td align="center">\033[K</td><td align="left">清除从光标到行尾的内容</td></tr><tr><td align="center">\033[s</td><td align="left">保存光标位置</td></tr><tr><td align="center">\033[u</td><td align="left">恢复光标位置</td></tr><tr><td align="center">\033[?25l</td><td align="left">隐藏光标</td></tr><tr><td align="center">\33[?25h</td><td align="left">显示光标</td></tr></tbody></table><h2 id="实现显示进度条代码"><a href="#实现显示进度条代码" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法的优点是，由于每次打印显示之前都是先将光标移动到行首并将其后的所有输出内容清除，因此当控制台有其他字符输出时，也不会导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress（进度百分比，取值为0~100）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,本次显示进度条时所输出的字符个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移动到行首并清除从当前光标到行尾的所有内容 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\033[k"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回本次显示进度条时所输出的字符个数 */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用’-b’退格字符实现"><a href="#使用’-b’退格字符实现" class="headerlink" title="使用’\b’退格字符实现"></a>使用’\b’退格字符实现</h1><p>&emsp;&emsp;在C语言中，提供了转义字符’\b’来进行输出后的退格操作。在编程过程中，我们有时候需要进行退格操作。但是，我在以前使用的过程中，发现我使用语句printf(“abc\b”);之后，在输出结果中还是显示的abc并不是我希望得到的ab。</p><h2 id="用法及原理"><a href="#用法及原理" class="headerlink" title="用法及原理"></a>用法及原理</h2><p>&emsp;&emsp;在用’\b’进行退格操作的时候，实际上，每次使用’\b’字符之后，控制台的输出光标会后退一个字符的位置，但是并没有将相应的字符删除。所以，我们需要在’\b’字符后面紧跟一个字符，用来代替需要删除的字符。如果后面没有需要输出的字符，可以用至少一个空格跟在’\b’后面，用来替换需要删除的字符。<br>&emsp;&emsp;该’\b’退格字符，也可以多个连用，以实现对多个字符的删除操作，但是需要注意的是，想要删除几个字符就要使用至少几个’\b’，对应的也需要有相等数量的字符用来替换待删除的字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="对单个字符进行退格操作（删除单个字符）"><a href="#对单个字符进行退格操作（删除单个字符）" class="headerlink" title="对单个字符进行退格操作（删除单个字符）"></a>对单个字符进行退格操作（删除单个字符）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\bv"</span>);  <span class="comment">//此处的输出结果是abv，后面的'v'就是用来替换'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b"</span>);  <span class="comment">//此处的输出结果是abc，可以看出虽然用了'\b'退格，但是并没有提供相应的用来替换最后一个字符'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b "</span>);  <span class="comment">//此处的输出结果是ab，因为在'\b'后面，跟了一个空格' '来替换了字符'c'</span></span><br></pre></td></tr></table></figure><h3 id="对多个字符进行退格操作（删除字符串）"><a href="#对多个字符进行退格操作（删除字符串）" class="headerlink" title="对多个字符进行退格操作（删除字符串）"></a>对多个字符进行退格操作（删除字符串）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b.new"</span>);  <span class="comment">//此处的输出结果是ph.new，后面的字符串".new"是用来替换"rase"的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b newString"</span>);  <span class="comment">//此处输出的结果是ph  newString，中间用了两个空格来代替字符串"ra"，紧接着用了两个字符"ne"来代替字符串"se"，再后面多出的"wString"字符串，则原样输出。</span></span><br></pre></td></tr></table></figure><h2 id="实现显示进度条代码-1"><a href="#实现显示进度条代码-1" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法有个致命的缺点，当控制台有其他字符输出的时候会打乱现有的显示位置，导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress           进度百分比，取值为0~100</span></span><br><span class="line"><span class="comment">* @param[in] last_char_count    上一次显示进度条时所用到的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,目前进度条打印的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress, <span class="keyword">int</span> last_char_count)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把上次显示的进度条信息全部清空*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; last_char_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\b"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回本次显示进度条时所输出的字符个数*/</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================================================================================================&gt;&gt;   [99%]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用C语言对IP地址排序</title>
    <link href="YobeZhou.github.io/2019/06/21/0024-%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AF%B9IP%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F/"/>
    <id>YobeZhou.github.io/2019/06/21/0024-使用C语言对IP地址排序/</id>
    <published>2019-06-21T03:50:30.000Z</published>
    <updated>2019-07-04T11:21:28.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。<br>&emsp;&emsp;程序运行环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- windows 10 64-bit</span><br><span class="line">- Visual Studio 2015</span><br></pre></td></tr></table></figure><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>&emsp;&emsp;假设IP地址格式为：a.b.c.d<br>&emsp;&emsp;由观察可知：每个数字的范围在0~255之间，灭个字段都是模256的余数，则可以将所有字段按照所在位置乘以256的对应次幂。<br>&emsp;&emsp;由观察可得公式：(a<em>256^3) + (b</em>256^2) + (c<em>256^1) + (d</em>256^0)<br>这样我们就可以得到一个长整数。每个IP地址对应一个长整数，只要将IP地址与对应求得的长整数用链表保存起来。这样我们就将问题转换为基数排序，结果的排序即为索求排序，只需用指针或者下标等方法将两者对应。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort_ip_ddresses.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *ip_Str;    <span class="comment">// 数据域</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ip_Int;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;link;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">创建链表 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">creatLink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建头结点 */</span></span><br><span class="line">link * p = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link)); </span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">往链表增加项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link * <span class="title">addLink</span><span class="params">(link * head, <span class="keyword">char</span> *str, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = head;</span><br><span class="line">link *targeLink = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line"><span class="keyword">if</span> (targeLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入结点前申请内存失败！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">targeLink-&gt;ip_Int = value;</span><br><span class="line">targeLink-&gt;ip_Str = str;</span><br><span class="line">targeLink-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tempLink-&gt;next = targeLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tempLink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapStr</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr;</span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str1);</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"><span class="built_in">strcpy</span>(str2, tempStr);</span><br><span class="line"><span class="built_in">free</span>(tempStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *value1, <span class="keyword">long</span> <span class="keyword">long</span> *value2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempValue = *value1;</span><br><span class="line"></span><br><span class="line">*value1 = *value2;</span><br><span class="line">*value2 = tempValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">排序链表【冒泡排序】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">sortTheLinkedList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> canSort = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">while</span> (tempLink != head-&gt;next &amp;&amp; canSort)</span><br><span class="line">&#123;</span><br><span class="line">link *q = head;</span><br><span class="line">canSort = <span class="literal">false</span>;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">for</span> (; q-&gt;next &amp;&amp; q-&gt;next != q; q = q-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if ((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) &gt; 0))  //|| (((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) == 0)) &amp;&amp; (strlen(q-&gt;ip_Str) &gt; strlen(q-&gt;next-&gt;ip_Str)))</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;ip_Int &gt; q-&gt;next-&gt;ip_Int)</span><br><span class="line">&#123;</span><br><span class="line">swapStr(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str);</span><br><span class="line">swapValue(&amp;q-&gt;ip_Int, &amp;q-&gt;next-&gt;ip_Int);</span><br><span class="line">canSort = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tempLink = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历并输出链表内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">showLinkInf</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">link *tempLink = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tempLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：%s，\t大小：%lld\n"</span>, tempLink-&gt;ip_Str, tempLink-&gt;ip_Int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表长度: %d\n\n"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">清空链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tempLink);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strCpy</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(tempStr2, str, len);</span><br><span class="line"><span class="keyword">return</span> tempStr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设IP地址格式为：a.b.c.d</span></span><br><span class="line"><span class="comment">由观察可知：每个数字的范围在0~255之间，则可以将其看成一个四位的256进制数。</span></span><br><span class="line"><span class="comment">由观察可得公式：(a*256^3) + (b*256^2) + (c*256^1) + (d*256^0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">strToInt</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> calcValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> strTIntVal;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">strTIntVal = (<span class="keyword">long</span> <span class="keyword">long</span>)atoi(tokStr);</span><br><span class="line">calcValue = calcValue * <span class="number">256</span> + strTIntVal;</span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> calcValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strTok</span><span class="params">(link * head, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分割字符串 */</span></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">tempLongData = strToInt(tokStr, <span class="built_in">strlen</span>(tokStr));</span><br><span class="line"><span class="comment">//tempStr = strCpy(tokStr, strlen(tokStr));</span></span><br><span class="line">addLink(head, tokStr, tempLongData);<span class="comment">// 加入链表</span></span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> len, tempLen;</span><br><span class="line"><span class="keyword">int</span> linkCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line">link * ipLink = creatLink();</span><br><span class="line"></span><br><span class="line">buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*MAX_LINE);</span><br><span class="line">fp = fopen(<span class="string">"ipAddress.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"打开文件失败！\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="built_in">free</span>(ipLink);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAX_LINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">tempLen = len;</span><br><span class="line">strTok(ipLink, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sortTheLinkedList(ipLink);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!showLinkInf(ipLink))<span class="built_in">printf</span>(<span class="string">"链表为空，遍历失败！\n"</span>);</span><br><span class="line"></span><br><span class="line">emptyList(ipLink);</span><br><span class="line">fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="需排序的IP地址文本"><a href="#需排序的IP地址文本" class="headerlink" title="需排序的IP地址文本"></a>需排序的IP地址文本</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">92</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">82</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">72</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">62</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IP地址：<span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">1722286341</span></span><br><span class="line">IP地址：<span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">1890058517</span></span><br><span class="line">IP地址：<span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">2057830659</span></span><br><span class="line">IP地址：<span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">2225602825</span></span><br><span class="line">IP地址：<span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">2393374983</span></span><br><span class="line">IP地址：<span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">2561147142</span></span><br><span class="line">IP地址：<span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">2728919811</span></span><br><span class="line">IP地址：<span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">2896691460</span></span><br><span class="line">IP地址：<span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3064463875</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">3232235779</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">3232235780</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">3232235781</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">3232235782</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">3232235783</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> ，  大小：<span class="number">3232235784</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">3232235785</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">3232235797</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> ，  大小：<span class="number">3232236034</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3232236035</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> ， 大小：<span class="number">3232236047</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">3232236291</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> ，  大小：<span class="number">3232236292</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> ，  大小：<span class="number">3232236293</span></span><br><span class="line">链表长度: <span class="number">31</span></span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。&lt;br&gt;&amp;emsp;&amp;emsp;程序运行环境
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++,排序,链表" scheme="YobeZhou.github.io/tags/C-C-%E6%8E%92%E5%BA%8F-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C标准库--string.h</title>
    <link href="YobeZhou.github.io/2019/06/13/0023-C%E6%A0%87%E5%87%86%E5%BA%93-string-h/"/>
    <id>YobeZhou.github.io/2019/06/13/0023-C标准库-string-h/</id>
    <published>2019-06-13T08:03:43.000Z</published>
    <updated>2019-08-15T01:25:06.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、strcmp、strcpy等等，更详细的可以到include文件夹里面查看该文件。</p><h1 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h1><p>&emsp;&emsp;头文件 string.h 中定义的变量类型：</p><table><thead><tr><th align="center">变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">size_t</td><td align="left">这是无符号整数类型，它是 sizeof 关键字的结果</td></tr></tbody></table><h1 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h1><p>头文件 string.h 中定义的宏：</p><table><thead><tr><th align="center">宏</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">NULL</td><td align="left">这个宏是一个空指针常量的值</td></tr></tbody></table><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><p>头文件 string.h 中定义的函数，有下表列出的22种用法。</p><table><thead><tr><th align="center">序号</th><th align="left">函数&amp;描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">void *memchr(const void *str, int c, size_t n)<br>在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">2</td><td align="left">int memcmp(const void *str1, const void *str2, size_t n)<br>把 str1 和 str2 的前 n 个字节进行比较。</td></tr><tr><td align="center">3</td><td align="left">void *memcpy(void *dest, const void *src, size_t n)<br>从 src 复制 n 个字符到 dest。</td></tr><tr><td align="center">4</td><td align="left">void *memmove(void *dest, const void *src, size_t n)<br>另一个用于从 src 复制 n 个字符到 dest 的函数。</td></tr><tr><td align="center">5</td><td align="left">void *memset(void *str, int c, size_t n)<br>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</td></tr><tr><td align="center">6</td><td align="left">char *strcat(char *dest, const char *src)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</td></tr><tr><td align="center">7</td><td align="left">char *strncat(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</td></tr><tr><td align="center">8</td><td align="left">char *strchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">9</td><td align="left">int strcmp(const char *str1, const char *str2)<br>把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</td></tr><tr><td align="center">10</td><td align="left">int strncmp(const char *str1, const char *str2, size_t n)<br>把 str1 和 str2 进行比较，最多比较前 n 个字节。</td></tr><tr><td align="center">11</td><td align="left">int strcoll(const char *str1, const char *str2)<br>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</td></tr><tr><td align="center">12</td><td align="left">char *strcpy(char *dest, const char *src)<br>把 src 所指向的字符串复制到 dest。</td></tr><tr><td align="center">13</td><td align="left">char *strncpy(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</td></tr><tr><td align="center">14</td><td align="left">size_t strcspn(const char *str1, const char *str2)<br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td></tr><tr><td align="center">15</td><td align="left">char *strerror(int errnum)<br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td></tr><tr><td align="center">16</td><td align="left">size_t strlen(const char *str)<br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td></tr><tr><td align="center">17</td><td align="left">char *strpbrk(const char *str1, const char *str2)<br>检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td></tr><tr><td align="center">18</td><td align="left">char *strrchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">19</td><td align="left">size_t strspn(const char *str1, const char *str2)<br>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</td></tr><tr><td align="center">20</td><td align="left">char *strstr(const char *haystack, const char *needle)<br>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</td></tr><tr><td align="center">21</td><td align="left">char *strtok(char *str, const char *delim)<br>分解字符串 str 为一组字符串，delim 为分隔符。</td></tr><tr><td align="center">22</td><td align="left">size_t strxfrm(char *dest, const char *src, size_t n)<br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</td></tr></tbody></table><blockquote><p>更详细的内容请查阅include文件夹中的文件。</p></blockquote><style>table th:nth-of-type(1){width: 8%;}table th:nth-of-type(2){width: 92%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、s
      
    
    </summary>
    
      <category term="C/++" scheme="YobeZhou.github.io/categories/C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>进程之进程调度</title>
    <link href="YobeZhou.github.io/2019/06/04/0022-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>YobeZhou.github.io/2019/06/04/0022-进程之进程调度/</id>
    <published>2019-06-04T01:00:00.000Z</published>
    <updated>2019-06-04T01:45:02.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。为了满足这些目标，进程调度器（process scheduler）选择一个可用进程（可能从多个可用进程集合中）到CPU上执行。单处理器系统不会具有多个正在运行的进程。如果有多个进程，那么余下的需要等待CPU空闲并能重新调度。</p><h1 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h1><p>&emsp;&emsp;进程在进入系统时，会被加到作业队列（job queue），这个队列包括系统内的所有进程。驻留在内存中的、就绪的、等待运行的进程保存在就绪队列（ready queue）上。这个队列通常用链表实现；其头节点有两个指针，用于指向链表的第一个和最后一个PCB块，每个PCB还包括一个指针，指向就绪队列的下一个PCB。<br>&emsp;&emsp;系统还有其他队列。当一个进程被分配了CPU后，它执行一段时间，最终退出，或被中断，或等待特定事件发生，如I/O请求的完成。我们假设进程向一个共享设备，如磁盘，发出I/O请求。由于系统具有许多进程，磁盘可能忙于其他进程的I/O请求，因此该进程可能需要等待磁盘空闲。等待特定I/O设备的进程列表，称为设备队列（device queue）。每个设备都有自己的设备队列。</p><p><img src="/images/operating-system/process/2-1_Ready-Queue-And-Various-IO-Device-Queues.png" alt="就绪队列和各种IO设备队列"></p><center>图2-1 就绪队列和各种IO设备队列</center>&emsp;&emsp;进程调度通常用队列图（queueing diagram）来表示，如图1-2所示。每个举行框代表一个队列；这里具有两种队列：就绪队列和设备队列。圆圈表示服务队列的资源；箭头表示系统内的进程流向。<p><img src="/images/operating-system/process/2-2_Representation-of-Process-Scheduling.jpg" alt="表示进程调度的队列图"></p><center>图2-2 表示进程调度的队列</center>&emsp;&emsp;最初，新进程被加载到就绪队列；之后它便在就绪队列中一直等待，知道被选中执行或被分配（dispatched）。当该进程分配到CPU并执行时，以下事件可能发生：* 进程可能发出I/O请求，并被放到I/O队列。* 进程可能创建一个新的子进程，并等待其终止。* 进程可能由于中断而被强制释放CPU，并被放回到就绪队列。对于前面两种情况，进程最终从等待状态切换到就绪状态，并放回到就绪队列。进程重复这一循环直到终止；然后它会从所有队列中删除，其PCB和资源也被释放。<h1 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h1><p>&emsp;&emsp;进程在整个生命周期中，会在葛总调度队列之间迁移。操作系统为了调度必须按一定方式从这些队列中选择进程。进程选择通过适当调度器或调度程序(scheduler)来执行。<br>&emsp;&emsp;通常，对于批处理系统（又名批处理操作系统），提交的进程多于可以立即执行的。这些进程会被保存到大容量存储设备(通常为磁盘)的缓冲池，以便以后执行。长期调度程序(long-term scheduler)或作业调度程序(job scheduler)从该池中选择进程，加到内存，以便执行。短期调度程序（short-term scheduler）或CPU调度程序(CPU scheduler)从准备执行的进程中选择进程，并分配CPU。<br>&emsp;&emsp;这两种调度程序的主要区别是执行频率。短期调度程序必须经常为CPU选择新的进程。进程可能执行几毫秒(ms)，就会等待I/0请求。通常，短期调度程序每100ms至少执行一次。由于执行之间的时间短，短期调度程序必须快速.如果花费10ms来确定执行一个运行一个100ms的进程，那么 10/(100+10)=9% 的CPU时间会用在(或浪费在)调度工作上。<br>&emsp;&emsp;长期调度程序执行并不频繁；在新进程的创建之间，可能有几分钟间隔。长期调度程序控制多道程序程度(degree of multiprogramming)(内存中的进程数量)。如果多道程序程度稳定，那么创建进程的平均每度必须等于进程离开系统的平均速度。因此，只有在进程离开系统时，才需要长期调度程序的调度。由于每次执行之间的更长时间间隔，长期调度程序可以负担得起更多时间，以便决定应该选择执行哪个进程。<br>&emsp;&emsp;重要的是，长期调度程序进行认真选择。通常，大多数进程可分为：I/0为主或CPU为主。I/0密集型进程(I/O-bound process)，执行I/0比执行计算需要花费更多时间。相反，CPU密集型进程(CPU-bound process)很少产生I/O请求，而是将更多时间用于执行计算。重要的是，长期调度程序应该选择I/O密集型和CPU密集型的合理进程组合。</p><ul><li>如果所有进程都是I/O密集型的，那么就绪队列几乎总是为空，从而短期调度程序没有什么可做。</li><li>如果所有进程都是CPU密集型的，那么I/0等待队列几乎总是为空，从而设备没有得到使用，因而系统会不平衡。为了使得性能最佳，系统需要I/O密集型和CPU密集型的进程合理组合。</li></ul><p>&emsp;&emsp;有的系统，可能没有或极少采用长期调度程序。例如，UNIX或微软Windows的分时系统通常没有长期调度程序，只是简单将所有新进程放于内存，以供短期调度程序使用。这些系统的稳定性取决于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么有的用户就会退出。<br>&emsp;&emsp;有的操作系统如分时系统，可能引人一个额外的中期调度程序(medium-term scheduler)。中期调度程序的核心思想是可将进程从内存(或从CPU竞争)中移出，从而降低多道程序程度。之后，进程可被重新调人内存，并从中断处继续执行。这种方案称为交换（swap）。通过中期调度，进程可换出（swap out），并在后来可换入（swap in）。为了改善进程组合，或者由于内存需求改变导致过渡使用内存从而需要释放内存，就有必要使用交换。</p><p><img src="/images/operating-system/process/2-3_Addition-of-Medium-Term-Scheduling.png" alt="添加中级进程调度到队列"></p><center>图3-1 添加中级进程调度到队列</center><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>&emsp;&emsp;中断导致CPU从执行当前任务改变到执行内核程序。这种操作在通用系统中经常发生。当中断发生时，系统需要保存当前运行在CPU上的进程的上下文，以便在处理后能够恢复上下文，即先挂起进程，在恢复进程。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等。通常，通过执行状态保存（state save），保存CPU当前状态（包括系统模式和用户模式）；之后，装填回复（state restore）重新开始运行。<br>&emsp;&emsp;切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称上下文切换(context swiitch)。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。上下文切换的时间是纯粹的开销，因为在切换时系统并没有做任何有用工作。上下文切换的速度因机器不同而有所不同，它依赖于内存速度、必须复制的寄存器数量、是否有特殊指令(如加载或存储所有寄存器的单个指令)。典型速度为几毫秒。<br>&emsp;&emsp;上下文切换的时间与硬件支持密切相关。例如，有的处理器(如Sun U1traspARC)提供了多个寄存器组，上下文切换只需简单改变当前寄存器组的指针。当然，如果活动进程数量超过寄存器的组数，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的就越多。高级的内存管理技术在每次上下文切换时，所需切换的数据会更多。例如，在使用下一个进程的地址空间之前，需要保存当前进程的地址空间。如何保存地址空间，需要做什么才能保存等，取决于操作系统的内存管理方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程，当不执行时，位于某个等待队列。操作系统有两种主要队列：I/O请求队列和就绪队列。就绪队列包括所有准备执行并等待CPU的进程，每个进程都用PCB来表示。<br>&emsp;&emsp;操作系统应从各个调度队列中选择进程。长期调度（用于作业）选择进程以便竞争CPU。通常长期调度充分考虑资源分配，尤其是内存管理。短期调度从就绪队列中选择进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="YobeZhou.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程之基础概念</title>
    <link href="YobeZhou.github.io/2019/06/03/0021-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E6%A6%82%E5%BF%B5/"/>
    <id>YobeZhou.github.io/2019/06/03/0021-进程之概念/</id>
    <published>2019-06-03T00:51:52.000Z</published>
    <updated>2019-06-04T01:37:40.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。这些资源在创建进程或执行进程时得以分配。<br>&emsp;&emsp;进程是大多数系统的工作单元。这种操作系统包含一组进程：操作系统进程执行系统代码，而用户进程执行用户代码。所有这些进程可以并发执行。<br>&emsp;&emsp;操作系统负责进程和线程管理的多个方面：用户进程与系统进程的创建与删除，进程调度，用于进程同步、进程通信与进程死锁处理的机制等。</p><h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>&emsp;&emsp;一个程序文件（program），只是一堆待执行的代码和部分待处理的数据，他们只有被加载到内存中，然后让CPU逐条执行其代码，并根据代码做出相应的动作，才能形成一个真正“活动”、动态的进程（process），因此进程时一个动态变化的过程，是一出有始有终的戏，而程序文件只是这一系列动作的原始蓝本，是一个静态的剧本。</p><p><img src="/images/operating-system/process/01_Process-in-Memory.png" alt="内存中的进程"></p><center>图2-1 进程的内存结构</center>&emsp;&emsp;进程是执行的程序。进程不只是程序代码，进程代码有时称为“文本段（text section）”（或“代码段（code section）”）。&emsp;&emsp;进程还包括：* 进程堆栈（stack）：包括临时数据，如函数参数、返回地址和局部变量。* 数据段（data section）：包括全局变量* 堆（heap）：可能包括堆，这是在进程运行时动态分配的内存。> 进程还包括当前活动，如程序计数器（program）的值和处理器寄存器的内容等。<h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>&emsp;&emsp;进程在执行时会改变状态。进程的状态，部分取决于进程的当前活动。每个进程都有可能处于以下状态的某种状态：</p><ul><li>新的（new）：进程正在创建；</li><li>运行（running）：指令正在执行；</li><li>等待（waiting）：进程正在等待发生某个时间（如I/O完成或受到信号）；</li><li>就绪（ready）：进程等待分配处理器；</li><li>终止（terminated）：进程已经完成执行。</li></ul><p><img src="/images/operating-system/process/02_Diagram-of-Process-State.png" alt="进程状态"></p><center>图3-1 进程状态图</center>> 一次只有一个进程可在处理器上运行（running）；但是可多个进程处于就绪（ready）或者等待（waiting）状态。<h1 id="程序与进程的关系"><a href="#程序与进程的关系" class="headerlink" title="程序与进程的关系"></a>程序与进程的关系</h1><p>&emsp;&emsp;程序本身不是进程。程序是被动（passive）实体，如存储在磁盘上包含一系列指令的文件（我们常称之为“可执行文件”（executable file））。相反，进程是活动（active）实体，具有一个程序计数器用于表示可执行命令和一组相关资源。当一个可执行文件被加载到内存时，这个程序就成为进程。</p><blockquote><p>加载可执行文件通常由两种方法：双击一个代表可执行文件的图标或在命令行上输入可执行文件的名称（如prog.exe或a.out）。</p></blockquote><p><img src="/images/operating-system/process/03_program-and-process.png" alt="程序与进程"></p><center>图4-1 程序与进程的关系</center>&emsp;&emsp;虽然多个进程可以与同一个程序相关联，但是实际上每个都是单独的执行序列。比如，多个用户可以运行电子邮件的不同副本，或者同意用户可以调用Web浏览器程序的多个副本。每个副本（进程）都是单独运行的；虽然文本段相同，但是数据、堆、及堆栈却不同。进程在运行时也经常会生成许多进程（子进程）。# 进程控制块&emsp;&emsp;操作系统内的每个进程表示，都采用进程控制块表示（Process Control Block），也称任务控制块（task control block）。当可执行程序被进行时，内核中实际上产生了一个叫"task_struct{}"的结构体来表示这个进程，进程是一个“活动的实体”，这个活动的实体从一开始诞生就需要各种各样的资源以便于生存下去，而这些信息都被记录在"task_struct"结构体之中，这个结构体被常常称之为进程控制块（PCB，即Process Control Block）。进程控制块包括：* 进程状态：状态可以包括由新的、就绪、运行、等待、停止等。* 程序计数器：计数器表示进程将要执行的下个指令的地址。* CPU寄存器：根据计算机体系的不同寄存器的类型和数量也会不同。他们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件吗信息寄存器。在发生中断时，这些状态信息与程序计数器一起需要保存，一边进程以后能正确地继续执行。* CPU调度信息：这类信息包括进程优先级、调度队列地指针和气压调度参数。* 内存管理信息：根据操作系统使用的内核系统，这类信息可以包括及地址和界限寄存器的值、页表或段表。* 记账信息：这类信息包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开文件列表等。&emsp;&emsp;简而言之，PCB简单地作为这些信息的仓库，这些信息也会随着进程的不同而不同。<p><img src="/images/operating-system/process/04_Process-Control-Block-(PCB).png" alt="进程控制块"></p><center>图5-1 进程控制块</center><p><img src="/images/operating-system/process/05_CPU-Switch-From-Process-to-Process.png" alt="进程间的CPU切换"></p><center>图5-2 进程间的CPU切换</center><h1 id="Linux的进程表示"><a href="#Linux的进程表示" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;Linux操作系统的进程控制块采用C语言结构体 task_struct 来表示，它位于Linux内核源代码目录内的头文件&lt;linux/sched.h&gt;。这个结构体包含用于表示进程的所有必要信息，包括进程的状态、调度和内存管理信息、打开文件列表、指向父进程的指针及指向子进程和兄弟进程列表的指针等。（父进程（parent process）为创建他的进程，子进程（child process）为它本身创建的进程，兄弟进程（sibling process）为具有同一父进程的进程。）<br>这些成员包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pid t pid;                  <span class="comment">/* process identifier */</span> </span><br><span class="line"><span class="keyword">long</span> state;                 <span class="comment">/* state of the process */</span> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> time slice     <span class="comment">/* scheduling information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* this process’s parent */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">head</span> <span class="title">children</span>;</span>  <span class="comment">/* this process’s children */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files</span> <span class="title">struct</span> *<span class="title">files</span>;</span> <span class="comment">/* list of open files */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span> <span class="title">struct</span> *<span class="title">mm</span>;</span>       <span class="comment">/* address space of this process */</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，进程状态是由这个结构的成员 long state 来表示的。在Linux内核中，所有活动进程的表示都采用task_struct 的双向链表。内核采用一个指针即 current，用于指向当前系统正在执行的进车.</p><p><img src="/images/operating-system/process/06_task-struct-double-linuxked-list.png" alt="task_struct双向链表"></p><center>图6-1 task_struct双向链表</center><h1 id="Linux的进程表示-1"><a href="#Linux的进程表示-1" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;下面举例说明，内核如何修改某个特定进程的 task_struct 的成员，假设系统需要将当前运行状态改成值 new_state。如果current 为指向当前运行进程的指针，那么可以这样改变状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state = new_state;</span><br></pre></td></tr></table></figure><blockquote><p>Linux内核代码纷繁复杂，千万头绪，这个结构体是系统进程在执行过程中所有设计的方方面面的缩影，因此以这个所谓的进程控制块（PCB）为切入点，是研究内核的一个很好的窗口。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程是可执行的程序。随着进程的执行，它会改变状态。<br>&emsp;&emsp;程序本身不是进程。程序只是被动实体，进程是活动实体，当一个可执行文件被加载到内存时，这个程序就成为进程。进程状态是由进程当前活动定义的。<br>&emsp;&emsp;每个进程都可以处于如下状态的某一种：新的、就绪、运行、等待或终止。<br>&emsp;&emsp;在操作系统中，每个进程通过它的进程控制块（PCB）来表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="YobeZhou.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解Makefile及典型的Makefile示例</title>
    <link href="YobeZhou.github.io/2019/04/27/0020-%E7%90%86%E8%A7%A3Makefile%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%9A%84Makefile%E7%A4%BA%E4%BE%8B/"/>
    <id>YobeZhou.github.io/2019/04/27/0020-理解Makefile及典型的Makefile示例/</id>
    <published>2019-04-27T13:56:48.000Z</published>
    <updated>2019-04-27T15:08:09.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考<a href="http://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">GNU Make Manual</a></p><h1 id="Makefile到底是什么"><a href="#Makefile到底是什么" class="headerlink" title="Makefile到底是什么"></a>Makefile到底是什么</h1><p>&emsp;&emsp;一个正式的软件工程中源文件可能数不胜数，并且源文件按类型、功能、模块等分别放在不同的目录下，在我们使用使用keil, Visual Studio, avr等工具开发程序时点点鼠标就可以编译了，但是对于其中的内部机制是什么？是怎么组织管理程序的？怎么决定编译哪一个文件？我们一概不知，因为IDE帮我们屏蔽了这方面的细节，让我们得以安心的投入到编码中。但是如果真要我们手工处理的话，那么我们每次都在命令行执行例如这样的指令： gcc a.c b.c c.c -o test ，显然是非常影响效率的！而Makefile是我们可以信赖的好伙伴，它定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br>&emsp;&emsp;综上所述，Makefile 就是一个用来帮助我们编译的工具，和 Windows 下的 IDE 类似，只不过 Makefile 需要我们自己动手编写，一个好的 Makefile 可以极大的提升工作的效率。</p><h1 id="Makefile的核心—规则"><a href="#Makefile的核心—规则" class="headerlink" title="Makefile的核心—规则"></a>Makefile的核心—规则</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################</span></span><br><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">目标 : 依赖1 依赖2 ...</span><br><span class="line">[TAB]命令</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br></pre></td></tr></table></figure><ul><li>target 就是我们编译文件要生成的目标;</li><li>prerequisites 就是我们编译文件需要的依赖;</li><li>command 就是用依赖生成目标所需要执行的命令（注意需用tab开始）。</li></ul><blockquote><p>当”目标文件”[不存在], 或某个依赖文件比目标文件[“新”],则: 执行”命令”</p></blockquote><p>&emsp;&emsp;比如我们平时使用的 gcc a.c b.c -o test<br>&emsp;&emsp;这里的 test 就是我们要生成的目标， a.c 就是我们生成目标需要的依赖，而 gcc a.c -o test 则是命令。将这行命令用 Makefile 的方式来写就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:a.c b.c</span></span><br><span class="line">    gcc a.c b.c -o test</span><br></pre></td></tr></table></figure><blockquote><p>再次强调：Makefile 中的命令必须用 tab 开始，不能是空格。</p></blockquote><p>&emsp;&emsp;Makefile 可以自动推导文件以及文件依赖关系后面的命令，在后面的示例中我们可以看到目标的依赖基本都是 .o 文件而不是 .c 文件，原因正是 Makefile 强大的自动推导功能。<br>&emsp;&emsp;通常 Makefile 中还会有一个名为 clean 的目标，用来清除编译后产生的各种文件。一般情况下 Makefile 会根据依赖和目标的新旧来决定是否编译，但是如果不小心修改了目标而造成目标比依赖新的情况的话，Makefile 会因为目标比依赖新而忽略这个目标下的命令，这个时候显然会造成问题，一个解决的办法就是使用 clean 这样的目标来清除编译后的文件，然后 make 重新编译。<br>&emsp;&emsp;clean 这个目标有点特殊，他是不需要依赖的，因此也叫伪目标。一般使用方式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br></pre></td></tr></table></figure><h1 id="Makefile-使用"><a href="#Makefile-使用" class="headerlink" title="Makefile 使用"></a>Makefile 使用</h1><p>&emsp;&emsp;make 命令执行时，需要一个 Makefile 文件(文件名为 Makefile 、 makefile 、 *.mk )，以告诉 make 命令需要怎么样的去编译和链接程序。执行时只用在命令行输入 make ， Makefile 就会自动执行第一个目标下的命令。而是否执行命令则取决于依赖，如果没有目标文件或是目标后的依赖文件比目标文件新，Makefile 就会执行其下面的命令：</p><ul><li>Makefile 中使用 # 注释,只注释 # 后的一行。</li><li>Makefile 中引用其他 Makefile，用 include 指令来引用。引用的效果就是原地展开。</li><li>Makefile 命令前面加 @ 来静默执行，即执行命令时不打印命令本身。</li></ul><h1 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h1><h2 id="Makefile-变量"><a href="#Makefile-变量" class="headerlink" title="Makefile 变量"></a>Makefile 变量</h2><p>&emsp;&emsp;Makefile 中的变量和 shell 脚本中非常相似，都是直接定义，不需要类型，引用时用 $(var) 。<br>&emsp;&emsp;伪目标（ .PHONY ）：伪目标形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。</p><h2 id="Makefile-中的几种变量赋值运算符"><a href="#Makefile-中的几种变量赋值运算符" class="headerlink" title="Makefile 中的几种变量赋值运算符"></a>Makefile 中的几种变量赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">延时变量赋值，可以被赋值为变量的值，解析时取这个变量最后的值。</td></tr><tr><td align="center">:=</td><td align="left">即时变量赋值，被赋值为变量时解析为变量在这行语句时的值，即变量如果后面改变这里的值也不改变。</td></tr><tr><td align="center">?=</td><td align="left">延时变量赋值, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句。</td></tr><tr><td align="center">+=</td><td align="left">附加, 它是即时变量还是延时变量取决于前面的定义。</td></tr></tbody></table><blockquote><p>关于 = 和 := ，比如 B=$(A)bcd ，那么 B 的值取决于变量 A 最后一次被赋值的值，即使 A 在 B 之后再次被赋值，变量 B 仍然会随着 A 的改变而改变。而 := 则只看之前 A 最后被赋值的值。</p></blockquote><p>&emsp;&emsp;即时变量也叫简单变量，即时变量与延时变量的理解示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := xxx   <span class="comment"># A的值即刻确定，在定义时即确定</span></span><br><span class="line">B  = xxx   <span class="comment"># B的值使用到时才确定</span></span><br></pre></td></tr></table></figure><h2 id="Makefile-中的自动变量"><a href="#Makefile-中的自动变量" class="headerlink" title="Makefile 中的自动变量"></a>Makefile 中的自动变量</h2><p>&emsp;&emsp;自动变量是 Makefile 中提前预定义的特殊意义的符号，类似 C 语言中的宏 <strong>__</strong>LINE__ 等，提前被定义并被赋予了特殊含义。</p><table><thead><tr><th align="center">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">$@</td><td align="left">目标文件名，比如上文的 test 。</td></tr><tr><td align="center">$&lt;</td><td align="left">第一个依赖文件名，如果依赖目标是以模式（即“ % “）定义的，那么” $&lt; “将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</td></tr><tr><td align="center">$^</td><td align="left">依赖的文件集合，比如上文的 a.c b.c 。</td></tr></tbody></table><p>&emsp;&emsp;此外还可以向 Makefile 传参， $# 存放传递参数个数， $1 存放第一个参数的字符串， $2 存放第二个参数的字符串……</p><h2 id="Makefile-的环境变量"><a href="#Makefile-的环境变量" class="headerlink" title="Makefile 的环境变量"></a>Makefile 的环境变量</h2><ul><li>Makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。</li><li>环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>&emsp;&emsp;通配符：比如在当前文件夹下有 1.c 2.c 12.c test.c 1.h 。</p><table><thead><tr><th align="center">通配符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">%</td><td align="left">若干个任意字符，和 * 很相似，但是 % 一般只用于规则描述中，又叫做规则通配符。</td></tr><tr><td align="center">*</td><td align="left">若干个任意字符 *.c 匹配 1.c 2.c 12.c test.c 。</td></tr><tr><td align="center">?</td><td align="left">1个任意字符 ?.c 匹配 1.c 2.c 。</td></tr><tr><td align="center">[]</td><td align="left">将 [] 中的字符依次去和外面的结合匹配 [12].c 匹配 1.c 2.c 。</td></tr><tr><td align="center">$@</td><td align="left">表示目标</td></tr><tr><td align="center">$&lt;</td><td align="left">表示第1个依赖文件</td></tr><tr><td align="center">$^</td><td align="left">表示所有依赖文件</td></tr></tbody></table><p>&emsp;&emsp;Makefile 与 shell 脚本非常相似，shell 脚本中能使用的 Makefile 也能使用，比如 awk 等工具。</p><h2 id="Makefile-的函数"><a href="#Makefile-的函数" class="headerlink" title="Makefile 的函数"></a>Makefile 的函数</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern...,text)</span>      <span class="comment"># 在text中取出符合patten格式的值</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern...,text)</span>  <span class="comment"># 在text中取出不符合patten格式的值</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span>            <span class="comment"># pattern定义了文件名的格式,</span></span><br><span class="line">                               <span class="comment"># wildcard取出其中存在的文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,<span class="variable">$(var)</span>)</span>  <span class="comment"># 从列表中取出每一个值</span></span><br><span class="line">                                        <span class="comment"># 如果符合pattern</span></span><br><span class="line"><span class="comment"># 则替换为replacement</span></span><br></pre></td></tr></table></figure><h1 id="Makefile-典型示例"><a href="#Makefile-典型示例" class="headerlink" title="Makefile 典型示例"></a>Makefile 典型示例</h1><p>&emsp;&emsp;请移步我的<a href="https://github.com/YobeZhou/Example-For-Makefile" target="_blank" rel="noopener">GitHub仓库</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="Linux" scheme="YobeZhou.github.io/tags/Linux/"/>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
  <entry>
    <title>什么是BootLoader？</title>
    <link href="YobeZhou.github.io/2019/04/21/0019-%E4%BB%80%E4%B9%88%E6%98%AFBootloader%EF%BC%9F/"/>
    <id>YobeZhou.github.io/2019/04/21/0019-什么是Bootloader？/</id>
    <published>2019-04-21T01:15:32.000Z</published>
    <updated>2019-04-27T15:08:37.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoader 可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。<br>&emsp;&emsp;Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。对于嵌入式系统，Bootloader是基于特定硬件平台来实现的。因此，几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。<br>&emsp;&emsp;在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p><h1 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h1><ul><li>自启动模式：在这种模式下，bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。</li><li>交互模式：在这种模式下，目标机上的bootloader将通过串口或网络等通行手段从开发主机（Host）上下载内核映像等到RAM中。可以被bootloader写到目标机上的固态存储媒质中，或者直接进入系统的引导。也可以通过串口接收用户的命令。</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><p>&emsp;&emsp;Bootloader启动大多数都分为两个阶段。第一阶段主要包含依赖于CPU的体系结构硬件初始化的代码，通常都用汇编语言来实现。这个阶段的任务有：<br>    1. 基本的硬件设备初始化（屏蔽所有的中断、关闭处理器内部指令/数据Cache等）。<br>    2. 为第二阶段准备RAM空间。<br>    3. 如果是从某个固态存储媒质中，则复制Bootloader的第二阶段代码到RAM。<br>    4. 设置堆栈。<br>    5. 跳转到第二阶段的C程序入口点。</p><p>&emsp;&emsp;第二阶段通常用C语言完成，以便实现更复杂的功能，也使程序有更好的可读性和可移植性。这个阶段的任务有：<br>    1. 初始化本阶段要使用到的硬件设备。<br>    2. 检测系统内存映射。<br>    3. 将内核映像和根文件系统映像从Flash读到RAM。<br>    4. 为内核设置启动参数。<br>    5. 调用内核。</p><blockquote><p>在第一阶段中为什么要关闭Cache？通常使用Cache以及写缓冲是为了提高系统性能，但由于Cache的使用可能改变访问主存的数量、类型和时间，因此Bootloader通常是不需要的。</p></blockquote><h1 id="常见的Bootloader"><a href="#常见的Bootloader" class="headerlink" title="常见的Bootloader"></a>常见的Bootloader</h1><p>BootLoader可以是U-Boot\Eboot\vivi等待其他一切方式。BootLoader是所有boot的总称。</p><h2 id="ARMboot"><a href="#ARMboot" class="headerlink" title="ARMboot"></a>ARMboot</h2><p>&emsp;&emsp;ARMboot是一个ARM平台的开源固件项目，它特别基于PPCBoot，一个为PowerPC平台上的系统提供类似功能的姊妹项目。鉴于对PPCBoot的严重依赖性，已经与PPCBoot项目合并，新的项目为U-Boot。<br>&emsp;&emsp;ARMboot发布的最后版本为ARMboot-1.1.0，2002年ARMboot终止了维护。</p><h2 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h2><p>&emsp;&emsp;U-Boot是由开源项目PPCBoot发展起来的，ARMboot并入了PPCBoot，和其他一些arch的Loader合称U-Boot。2002年12月17日第一个版本U-Boot-0.2.0发布，同时PPCBoot和ARMboot停止维护。<br>&emsp;&emsp;U-Boot支持的处理器构架包括PowerPC (MPC5xx，MPC8xx，MPC82xx，MPC7xx，MPC74xx，4xx)， ARM （ARM7，ARM9，StrongARM，Xscale），MIPS (4Kc，5Kc)，x86等等， U-Boot（Universal Bootloader）从名字就可以看出，它是在GPL下资源代码最完整的一个通用Boot Loader。<br>&emsp;&emsp;U-Boot提供两种操作模式：启动加载（Boot loading）模式和下载（Downloading）模式,并具有大型Boot Loader的全部功能。<br>&emsp;&emsp;U-Boot的功能是如此之强大，涵盖了绝大部分处理器构架，提供大量外设驱动，支持多个文件系统，附带调试、脚本、引导等工具，特别支持Linux,为板级移植做了大量的工作。U-Boot1.1.1版本特别包含了对SA1100和44B0芯片的移植，所以44B0移植主要是针对Board 的移植，包括FLASH、内存配置以及串口波特率等等。U-Boot的完整功能性和后续不断的支持，使系统的升级维护变得十分方便。</p><h2 id="Eboot"><a href="#Eboot" class="headerlink" title="Eboot"></a>Eboot</h2><p>&emsp;&emsp;是使用网口的意思，是微软提供的一般是wince下的bootloader，但是经过修改也可以兼容运行在其他OS下，如linux。如果直接说eboot也是bootloader”这样说不够严谨，对于基于norflash的bootloader来说是对的，如果bootloader是从nandflash开始执行就不对了，但我们所说的bootloader=nboot+eboot，其中nboot负责把eboot加载到SDRAM指定的内存处，然后运行eboot，接着eboot会把NK加载到SDRAM中并且执行。</p><h2 id="vivi"><a href="#vivi" class="headerlink" title="vivi"></a>vivi</h2><p>&emsp;&emsp;vivi是韩国mizi 公司开发的bootloader, 适用于ARM9处理器。Vivi有两种工作模式：启动加载模式和下载模式。启动加载模式可以在一段时间后（这个时间可更改）自行启动linux内核，这是vivi的默认模式。在下载模式下，vivi为用户提供一个命令行接口，通过接口可以使用vivi提供的一些命令</p><h2 id="Redboot"><a href="#Redboot" class="headerlink" title="Redboot"></a>Redboot</h2><p>&emsp;&emsp;Redboot是Redhat公司随eCos发布的一个BOOT方案，是一个开源项目。<br>&emsp;&emsp;Redboot支持的处理器构架有ARM，MIPS，MN10300，PowerPC， Renesas SHx，v850，x86等，是一个完善的嵌入式系统Boot Loader。<br>&emsp;&emsp;Redboot是在ECOS的基础上剥离出来的，继承了ECOS的简洁、轻巧、可灵活配置、稳定可靠等品质优点。它可以使用X-modem或Y-modem协议经由串口下载，也可以经由以太网口通过BOOTP/DHCP服务获得IP参数，使用TFTP方式下载程序映像文件，常用于调试支持和系统初始化（Flash下载更新和网络启动）。Redboot可以通过串口和以太网口与GDB进行通信，调试应用程序，甚至能中断被GDB运行的应用程序。Redboot为管理FLASH映像，映像下载，Redboot配置以及其他如串口、以太网口提供了一个交互式命令行接口，自动启动后，REDBOOT用来从TFTP服务器或者从Flash下载映像文件加载系统的引导脚本文件保存在Flash上。<br>&emsp;&emsp;Redboot是标准的嵌入式调试和引导解决方案，支持几乎所有的处理器构架以及大量的外围硬件接口，并且还在不断地完善过程中。</p><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>&emsp;&emsp;Blob(Boot Loader Object)是由Jan-Derk Bakker and Erik Mouw发布的，是专门为StrongARM 构架下的LART设计的Boot Loader。<br>&emsp;&emsp;Blob也提供两种工作模式，在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 Blob 切换到下载模式。如果在 10 秒内没有用户按键，则 Blob 继续启动 Linux内核。<br>&emsp;&emsp;Blob功能比较齐全，代码较少，比较适合做修改移植，用来引导Liunx，目前大部分S3C44B0板都用Blob修改移植后来加载uClinux。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoade
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
  <entry>
    <title>文件描述符、文件指针和文件偏移量之甄别</title>
    <link href="YobeZhou.github.io/2019/04/18/0018-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%8B%E7%94%84%E5%88%AB/"/>
    <id>YobeZhou.github.io/2019/04/18/0018-文件描述符、文件指针和文件偏移量之甄别/</id>
    <published>2019-04-18T07:14:34.000Z</published>
    <updated>2019-04-27T15:09:48.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在 C 程序中,文件由文件指针或者文件描述符表示。</p><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>&emsp;&emsp;在 linux 系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，也就是说每一个文件描述符都是一个问文件的索引，当然也可以出现多个不同的文件描述符索引同一个文件。<br>Linux标准文件描述符:</p><table><thead><tr><th align="left">文件描述符</th><th align="center">缩写</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">STDIN</td><td align="center">标准输入</td></tr><tr><td align="left">1</td><td align="center">STDOUT</td><td align="center">标准输出</td></tr><tr><td align="left">2</td><td align="center">STDERR</td><td align="center">标准错误输出</td></tr></tbody></table><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>&emsp;&emsp;C语言中使用文件指针做为 I/O 的句柄。文件指针指向进程用户区中的一个被称为 FILE 结构的数据结构。 FILE 结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在 Windows 系统上，文件描述符被称作文件句柄）。</p><h1 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h1><p>&emsp;&emsp;每个打开的文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在 C 程序中,文件由文件指针或者文件描述符表示。&lt;/p&gt;
&lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux下.so、.ko、.a、.o文件的区别</title>
    <link href="YobeZhou.github.io/2019/04/16/0017-Linux%E4%B8%8B-so%E3%80%81-ko%E3%80%81-a%E3%80%81.o%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>YobeZhou.github.io/2019/04/16/0017-Linux下-so、-ko、-a、.o文件的区别/</id>
    <published>2019-04-16T14:02:36.000Z</published>
    <updated>2019-06-03T05:56:14.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;&emsp;&emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是linux/unix的哲学核心思想。这句话中的“文件”不仅仅是我们通常所指的文件，在linux和unix中它代表的更为宽泛。目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”。然而有些文件对于在嵌入式Linux中是比较值得注意的，那就是.so、.ko、.a文件，我们可能会在有意或无意间遇到过，若是初次见面它们很容易就把我们迷惑了，下面概要的说明下这几者的区别。</p><h1 id="so文件"><a href="#so文件" class="headerlink" title=".so文件"></a>.so文件</h1><p>&emsp;&emsp;&emsp;&emsp;.so(share object)文件是用户层的动态链接库，相当于Windows的.dll文件，用于用户层的动态链接使用，内核态的代码同样不能直接访问。</p><h1 id="ko文件"><a href="#ko文件" class="headerlink" title=".ko文件"></a>.ko文件</h1><p>&emsp;&emsp;&emsp;&emsp;.ko(kernel object)文件是内核态的动态链接库，用于内核态的动态链接使用，可以用于内核之间的模块相互调用。用户态的代码不可直接调用内核态的代码，但是可以通过其他方式进行通信。</p><h1 id="a文件"><a href="#a文件" class="headerlink" title=".a文件"></a>.a文件</h1><p>&emsp;&emsp;&emsp;&emsp;.a文件是用于静态链接时，使用的静态库。</p><h1 id="o文件"><a href="#o文件" class="headerlink" title=".o文件"></a>.o文件</h1><p>&emsp;&emsp;&emsp;&emsp;.o文件是目标文件，编译生成,相当于windows中的.obj文件。.a文件就是由.o文件打包生成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="嵌入式" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="Linux" scheme="YobeZhou.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>什么是操作系统？</title>
    <link href="YobeZhou.github.io/2019/04/08/0016-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
    <id>YobeZhou.github.io/2019/04/08/0016-什么是操作系统？/</id>
    <published>2019-04-08T14:04:54.000Z</published>
    <updated>2019-06-04T01:31:28.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。<br>&emsp;&emsp;操作系统是管理计算机硬件的软件。硬件必须提供适当机制，以确保计算机系统的正确运行并且防止用户程序干扰系统的正常运行。<br>&emsp;&emsp;操作系统可以采用许多不同的组织方式，因此内部结构也有很大差异。设计新的操作系统的任务是艰巨的。在设计开始之前，明确界定设计系统的目标是非常重要的。这些目标是选择不回算法和策略的基础。<br>&emsp;&emsp;操作系统既庞大又复杂，因此应分块构造。每块都应具有描述明确的系统部分，并且具有严格定义的输入、输出和功能。</p><blockquote><p>有一个重点我们是必须get住的，那就是：操作系统（operating system）是管理计算机硬件的程序。也就是说操作系统是只是一个管理、控制的程序，它为其他应用程序提供基础，并且从当计算机用户和计算机硬件的中介，所以我们平时所作的所有操作都是在操作系统这个程序下进行的。</p></blockquote><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>&emsp;&emsp;操作系统的存在是因为其提供了合理的方式来解决创建可用计算系统的问题，计算机系统的根本目的是，执行用户程序帮助用户解决实际问题。<br>&emsp;&emsp;操作系统是一直运行在计算机上的程序（通常称为内核（kernel））。除了内核外还有其他两类程序：系统程序（system program）和应用程序。前者是与系统运行息息相关的程序（其保证着系统的正常运作），但不是内核的一部分，后者是与系统运行无关的其他应用程序（可以理解为用户程序）。</p><h1 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h1><p>&emsp;&emsp;计算机操作系统可粗分了四个组件：硬件、操作系统、应用程序和用户。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A7%86%E5%9B%BE.png" alt="计算机系统组件的抽象视图"></p><center>计算机系统组件的抽象视图</center><ul><li>硬件（hardware）为我们的系统提供基本的计算资源；</li><li>应用程序规定了用户为解决计算问题而使用硬件资源的方式；</li><li>而操作系统决定应用程序使用资源的方式和权限。</li></ul><p>至此，计算机系统也可分为硬件、软件和数据，当计算机系统运行时，操作系统提供正确的手段来让这些资源得到合理的利用。</p><blockquote><p>正如刚才强调的，至此，我们可以更形象的将操作系统理解为：操作系统类似于政府，其本身不能实现任何有用的功能，而是为其他程序的执行提供一个合理安全的环境。</p></blockquote><h2 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h2><p>&emsp;&emsp;计算机的用户视角因使用界面的不同而不同。<br>&emsp;&emsp;大多数的计算机用户的都是普通用户，即PC又显示器、键盘、鼠标和主机。这样的计算机是为了让单个用户单独使用资源，目的是优化用户进行的工作（或娱乐）。因此在对于这类群体，操作系统的设计的主要目的是为了用户的使用便利，而次要的是性能，不在乎资源的共享和利用。当然其中也包括我们程序员这一群体。<br>&emsp;&emsp;接着就是服务器了，对于这个视角的用户面对的是与大型机或小型机相连的终端前。这类系统的设计目标是优化资源的利用效率，确保所有的CPU时间、内存和I/O都能得到有效的使用，并且确保没有用户使用操作限制以外的资源。<br>&emsp;&emsp;与我们日常工作接触的是这样一种情况，我们处于工作站内，这类工作站与其他工作站和服务器相连。这时我们作为用户不仅可以使用专用资源，而且可以使用网络和服务器的共享资源，如：文件，计算和打印服务等。这类的操作系统的设计便是上述两种情况的折中方案，即考虑资源利用率与便利性。</p><h2 id="系统视角"><a href="#系统视角" class="headerlink" title="系统视角"></a>系统视角</h2><p>&emsp;&emsp;从计算机的是视角来看，操作系统是与硬件紧密相连的程序。因此，可将操作系统看作资源分配器。操作系统管理着（如：CPU时间、内存空间、文件存储空间、I/O设备等）这些资源，当面对许多甚至冲突的资源请求时，操作系统应该考虑如何为各个程序和用户分配资源，以便计算机能有效且公平地运行。</p><blockquote><p>说到资源请求，此时操作系统是一个控制程序，它特别注重I/O设备的运行和控制，其管理着用户程序的执行，以防止计算机资源的错误或不当使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）</title>
    <link href="YobeZhou.github.io/2019/04/07/0015-Arduino%E6%8E%A7%E5%88%B6ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89/"/>
    <id>YobeZhou.github.io/2019/04/07/0015-Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）/</id>
    <published>2019-04-07T12:22:08.000Z</published>
    <updated>2019-06-04T01:29:40.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的控制需要有精确到微秒级PWM；然而Linux系统很繁忙，最多只能达到毫秒级别的控制，所以对于安装了基于ARM架构的Debian的树莓派达不到我们要求的精确控制。由此自然联想到了使用单片机进行辅助控制，而其中使用Arduino最为简单，因此最终选择Arduino作为项目的辅助控制外设模块。</p><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>&emsp;&emsp;本文实现了对五线四相八拍步进电机（28BYJ8）的较为精确的控制，同时加入了EEPROM记录的功能，在运行过程中能记录步进电机目前的位置，在意外掉电重启后能定位自身所处角度并恢复到设定的位置。</p><h2 id="硬件模块"><a href="#硬件模块" class="headerlink" title="硬件模块"></a>硬件模块</h2><p>&emsp;&emsp;步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲：当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。我们可以通过控制脉冲个来控制角位移量，从而达到准确定位的目的；同时亦可通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。</p><p>&emsp;&emsp;步进电机28BYJ48型四相八拍电机，电压为DC5V—DC12V。当对步进电机施加一系列连续不断的控制脉冲时，它可以连续不断地转动。每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的通电方式有单（单相绕组通电）四拍（A-B-C-D-A…），双（双相绕组通电）四拍（AB-BC-CD-DA-AB-…），八拍（A-AB-B-BC-C-CD-D-DA-A…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uchar code CCW[<span class="number">8</span>]=&#123;<span class="number">0x08</span>,<span class="number">0x0c</span>,<span class="number">0x04</span>,<span class="number">0x06</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x09</span>&#125;;   <span class="comment">//逆时钟旋转相序表</span></span><br><span class="line">uchar code CW[<span class="number">8</span>]=&#123;<span class="number">0x09</span>,<span class="number">0x01</span>,<span class="number">0x03</span>,<span class="number">0x02</span>,<span class="number">0x06</span>,<span class="number">0x04</span>,<span class="number">0x0c</span>,<span class="number">0x08</span>&#125;;    <span class="comment">//正时钟旋转相序表</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;五线四相八拍步进电机（28BYJ8）：<br><img src="/images/%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89.jpg" alt="五线四相八拍步进电机（28BYJ8）"><br><cneter>五线四相八拍步进电机（28BYJ8）</cneter></p><p>&emsp;&emsp;ULN2003驱动模块：<br><img src="/images/ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97.jpg" alt="ULN2003驱动模块"></p><center>ULN2003驱动模块</center><p>&emsp;&emsp;全局概览：<br><img src="/images/IMG_3450.JPG" alt="全局概览"></p><center>全局概览</center><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>&emsp;&emsp;详细代码及更多内容请参考我在<a href="https://github.com/YobeZhou/Stepper-28BYJ48" target="_blank" rel="noopener">GitHub仓库</a>中的项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的
      
    
    </summary>
    
      <category term="Arduino" scheme="YobeZhou.github.io/categories/Arduino/"/>
    
    
      <category term="Arduino" scheme="YobeZhou.github.io/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题</title>
    <link href="YobeZhou.github.io/2019/04/06/0014-Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3TensorFlow%E4%B8%AD%E7%9A%84OpenCV%E8%A7%86%E9%A2%91%E6%B5%81%E8%AF%BB%E5%8F%96%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <id>YobeZhou.github.io/2019/04/06/0014-Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题/</id>
    <published>2019-04-06T15:25:45.000Z</published>
    <updated>2019-05-30T13:11:09.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的 read() 函数时发现其数据处理与数据产生的速度跟不上而导致延迟非常高，甚至内存溢出，因此开始思考解决措施。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval, image = cv.VideoCapture.read([, image])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是因为OpenCV读取视频流时，数据处理程序需要消耗的CPU时间过于长（不同硬件配置情况不可一概而论），而VideoCapture的read是按帧队列读取且先进先出，最后导致视频帧数据产生的速度与读取、处理速度不平衡，所以出现了上面所说的问题。<br>由此联想到我们可以试图将需要读取视频数据和处理视频数据的过程分开处理，从而解决延迟问题。</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;我们可以使用多进程或多线程将读取视频数据和处理视频数据的过程分开处理，但是由于实时视频处理属于CPU密集型任务，多线程的优势发挥不出来，因此我们选择多进程方式。</p><h2 id="所用到的库"><a href="#所用到的库" class="headerlink" title="所用到的库"></a>所用到的库</h2><p>&emsp;&emsp;实现多进程所用到的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两个子进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write()</span><br><span class="line">read()</span><br></pre></td></tr></table></figure><h2 id="在两个子进程中传递参数"><a href="#在两个子进程中传递参数" class="headerlink" title="在两个子进程中传递参数"></a>在两个子进程中传递参数</h2><ul><li>multiprocessing中有Quaue、SimpleQuaue等进程间传参类，以及Manager统领全局。</li><li>使用Manager我们可以在进程键传递字典、列表灯Python原生数据类型</li><li>Quaue时严格的数据结构队列类型</li></ul><h2 id="在读取进程中得到最新的视频帧数据"><a href="#在读取进程中得到最新的视频帧数据" class="headerlink" title="在读取进程中得到最新的视频帧数据"></a>在读取进程中得到最新的视频帧数据</h2><ul><li>首先 VideoCapture 是队列，先进先出。因此我们需要将其转换为压栈存储视频帧数据，才能达到后进先出而获取最新的视频帧数据，因此不能使用Quaue来传递参数。</li><li>为了达到压栈的效果，我们可以使用Python的列表，其append与pop操作可以达到模拟压栈的效果。因此，我们可以使用 multiprocessing.Manager.list 进行进程间传参类型最为理想不过。</li></ul><h2 id="清理传参栈"><a href="#清理传参栈" class="headerlink" title="清理传参栈"></a>清理传参栈</h2><p>&emsp;&emsp;由于压栈频率肯定是要比出栈频率高的，时间一长就会在栈中积累大量无法出栈的视频帧，会导致程序崩溃，因此我们需要考虑传参栈自动清理的问题，我们需要一个自动清理的机制：</p><ul><li>我们可以设定传参栈的容量，每当达到这个容量时就直接把栈清空，再利用gc库手动发起一次python垃圾回收，这样就不会导致严重的内存溢出和程序崩溃。</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>&emsp;&emsp;综上所述，实际上这个程序就是把VideoCapture的队列读取改成了栈读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">__author__ = <span class="string">'YobeZhou'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"><span class="comment">#File name: object_detection.py</span></span><br><span class="line"><span class="comment">#   Author: YobeZhou</span></span><br><span class="line"><span class="comment">#     Date: 2018/12/12</span></span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"><span class="comment">#import pdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import utilites</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br><span class="line"></span><br><span class="line">process_result = <span class="string">'ok'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向共享缓冲栈中写入数据:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(stack, cam, top: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param cam: 摄像头参数</span></span><br><span class="line"><span class="string">    :param stack: Manager.list对象</span></span><br><span class="line"><span class="string">    :param top: 缓冲栈容量</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line"></span><br><span class="line">    video = cv2.VideoCapture(cam)</span><br><span class="line">    ret = video.set(<span class="number">3</span>,<span class="number">1280</span>)</span><br><span class="line">    ret = video.set(<span class="number">4</span>,<span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">    retval = video.get(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (cam)</span><br><span class="line">    print(retval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(video.isOpened()):</span><br><span class="line">        ret, img = video.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            stack.append(img)</span><br><span class="line">            <span class="comment"># 每到一定容量清空一次缓冲栈</span></span><br><span class="line">            <span class="comment"># 利用gc库，手动清理内存垃圾，防止内存溢出</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt;= top:</span><br><span class="line">                <span class="keyword">del</span> stack[:]</span><br><span class="line">                gc.collect()</span><br><span class="line">        <span class="comment"># Press 'q' to quit</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"Write process has safely exited..."</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Clean up</span></span><br><span class="line">    video.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment"># read进程的子线程，用以监听接收socket通信数据包</span></span><br><span class="line"><span class="comment"># 这是从 threading.Thread 继承创建一个新的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threadID, newSocket, data)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.newSocket = newSocket</span><br><span class="line">        self.data = data</span><br><span class="line">        self.cmd = <span class="string">'o'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> (self.cmd == <span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.data = self.newSocket.recv(<span class="number">4</span>)</span><br><span class="line">            <span class="comment">#print (self.data)</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Receiving data thread has safely exited..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在缓冲栈中读取数据:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(stack)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#DST_IP = '192.168.1.106'</span></span><br><span class="line">    DST_IP = <span class="string">'10.3.141.1'</span></span><br><span class="line">    DST_PORT = <span class="number">8666</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 包含正在使用的对象检测模块的目录的名称</span></span><br><span class="line">    MODEL_NAME = <span class="string">'inference_graph'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抓取当前工作目录的路径</span></span><br><span class="line">    CWD_PATH = os.getcwd()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 冻结检测图.pb文件的路径，其中包含用于对象检测的模型</span></span><br><span class="line">    PATH_TO_CKPT = os.path.join(CWD_PATH,MODEL_NAME,<span class="string">'frozen_inference_graph.pb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标签映射文件的路径</span></span><br><span class="line">    PATH_TO_LABELS = os.path.join(CWD_PATH,<span class="string">'training'</span>,<span class="string">'labelmap.pbtxt'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明对象检测器可以识别的类数</span></span><br><span class="line">    NUM_CLASSES = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载标签</span></span><br><span class="line">    label_map = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line">    categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="literal">True</span>)</span><br><span class="line">    category_index = label_map_util.create_category_index(categories)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将Tensorflow模型加载到内存中</span></span><br><span class="line">    detection_graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">        od_graph_def = tf.GraphDef()</span><br><span class="line">        <span class="keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</span><br><span class="line">            serialized_graph = fid.read()</span><br><span class="line">            od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">            tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">        sess = tf.Session(graph=detection_graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入张量是图像</span></span><br><span class="line">    image_tensor = detection_graph.get_tensor_by_name(<span class="string">'image_tensor:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出张量是检测框，分数和类</span></span><br><span class="line">    <span class="comment"># 每个框表示检测到特定对象的图像的一部分</span></span><br><span class="line">    detection_boxes = detection_graph.get_tensor_by_name(<span class="string">'detection_boxes:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个分数代表每个对象的置信水平</span></span><br><span class="line">    <span class="comment"># 分数与结果图像一起显示在结果图像上</span></span><br><span class="line">    detection_scores = detection_graph.get_tensor_by_name(<span class="string">'detection_scores:0'</span>)</span><br><span class="line">    detection_classes = detection_graph.get_tensor_by_name(<span class="string">'detection_classes:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测到的对象数量</span></span><br><span class="line">    num_detections = detection_graph.get_tensor_by_name(<span class="string">'num_detections:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立Socket，SOCK_STREAM表示Socket类型为TCP</span></span><br><span class="line">    print(<span class="string">"Starting socket: TCP..."</span>)</span><br><span class="line">    socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#在客户端开启心跳维护</span></span><br><span class="line">    socket_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>)</span><br><span class="line">    socket_tcp.connect((DST_IP, DST_PORT))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建新线程</span></span><br><span class="line">    thread1 = myThread(<span class="number">1</span>, socket_tcp, <span class="string">'ok'</span>)</span><br><span class="line">    <span class="comment"># 启动新线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#socket_tcp.send(bytes("Tensorflow ok!",encoding="utf-8"))</span></span><br><span class="line">    socket_tcp.send(<span class="string">b'Tensorflow ok!'</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> len(stack) != <span class="number">0</span>: </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取框架并扩展框架尺寸以具有形状：[1，无，无，3]</span></span><br><span class="line">            <span class="comment"># 即单列阵列，其中列中的每个项目具有像素RGB值</span></span><br><span class="line">            frame = stack.pop()</span><br><span class="line"></span><br><span class="line">            frame_expanded = np.expand_dims(frame, axis=<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 通过以图像作为输入运行模型来执行实际检测</span></span><br><span class="line">            (boxes, scores, classes, num) = sess.run(</span><br><span class="line">                [detection_boxes, detection_scores, detection_classes, num_detections],</span><br><span class="line">                feed_dict=&#123;image_tensor: frame_expanded&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绘制检测结果（也称为“可视化结果”）</span></span><br><span class="line">            <span class="comment"># 可视化图像阵列上的框和标签</span></span><br><span class="line">            image,tablename = vis_util.my_visualize_boxes_and_labels_on_image_array(</span><br><span class="line">                frame,</span><br><span class="line">                np.squeeze(boxes),</span><br><span class="line">                np.squeeze(classes).astype(np.int32),</span><br><span class="line">                np.squeeze(scores),</span><br><span class="line">                category_index,</span><br><span class="line">                use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">                line_thickness=<span class="number">8</span>,</span><br><span class="line">                min_score_thresh=<span class="number">0.60</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将结果绘制在框架上并显示出来。</span></span><br><span class="line">            cv2.imshow(<span class="string">'Object detector V1.0 Author:Yobe Zhou'</span>, frame)</span><br><span class="line">            </span><br><span class="line">            datar = thread1.data</span><br><span class="line">            <span class="keyword">print</span> (datar)</span><br><span class="line">            <span class="keyword">if</span> (datar == <span class="string">b'ok'</span>):</span><br><span class="line">                <span class="keyword">print</span> (tablename)</span><br><span class="line">                <span class="keyword">if</span> tablename == <span class="string">"metal"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'metal'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"plastic"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'plastic'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"paper"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'paper'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"peel"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'peel'</span>)</span><br><span class="line">            <span class="comment"># 按'q'退出</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>) :</span><br><span class="line">                socket_tcp.sendall(<span class="string">b'exit'</span>)</span><br><span class="line">                thread1.cmd = <span class="string">'q'</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Clean up</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    socket_tcp.close()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Read process has safely exited..."</span>)            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    print(tf.__version__)</span><br><span class="line"></span><br><span class="line">    sys.path.append(<span class="string">".."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize webcam feed (Raspberry)</span></span><br><span class="line">    url = <span class="string">'http://10.3.141.1:8081/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 父进程创建缓冲栈，并传给各个子进程：</span></span><br><span class="line">    q = Manager().list()</span><br><span class="line">    pw = Process(target=write, args=(q, url, <span class="number">100</span>))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程结束</span></span><br><span class="line">    pw.join()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"End of program!"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的
      
    
    </summary>
    
      <category term="TensorFlow" scheme="YobeZhou.github.io/categories/TensorFlow/"/>
    
    
      <category term="Python" scheme="YobeZhou.github.io/tags/Python/"/>
    
      <category term="TensorFlow" scheme="YobeZhou.github.io/tags/TensorFlow/"/>
    
  </entry>
  
</feed>
