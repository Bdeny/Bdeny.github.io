<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YobeZhou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="YobeZhou.github.io/"/>
  <updated>2019-08-14T06:29:13.587Z</updated>
  <id>YobeZhou.github.io/</id>
  
  <author>
    <name>YobeZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android之源起</title>
    <link href="YobeZhou.github.io/2019/08/14/0028-Android%E4%B9%8B%E6%BA%90%E8%B5%B7/"/>
    <id>YobeZhou.github.io/2019/08/14/0028-Android之源起/</id>
    <published>2019-08-14T03:38:25.000Z</published>
    <updated>2019-08-14T06:29:13.587Z</updated>
    
    <content type="html"><![CDATA[<style>table th:nth-of-type(1){width: 35%;}table th:nth-of-type(2){width: 16%;}table th:nth-of-type(3){width: 25%;}table th:nth-of-type(4){width: 16%;}table th:nth-of-type(5){width: 18%;}</style><p><img src="/images/Android/android_in_google.jpg" alt="android_in_google"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android（读音：英：[‘ændrɔɪd]，美：[ˈænˌdrɔɪd]），常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。</p><h1 id="Android的成立"><a href="#Android的成立" class="headerlink" title="Android的成立"></a>Android的成立</h1><p>&emsp;&emsp;2003年10月，有“Android之父”之称的安迪·鲁宾（Andy Rubin）、利奇·米纳尔（Rich Miner）、尼克·席尔斯（Nick Sears）、克里斯·怀特（Chris White）在美国加利福尼亚州帕罗奥图共同成立了Android科技公司（Android Inc.），鲁宾把Android项目描述为“有极大的潜能以开发更智能的移动设备，以更了解其用家的位置及偏好。”该公司早期的方向是为数字相机开发先进的操作系统，此亦是2004年4月该公司向投资者介绍的基础。尽管Android科技公司的创始人和员工过去都具有各自的科技成就，但是Android科技公司的经营只显露出它在智能手机软件的方面，该公司随后认为相机市场不足以实现其目标，并且在5个月之后努力把Android转移到一款可跟Symbian及微软Windows Mobile互相媲美的手机操作系统。</p><p>Android的后续发展：</p><ul><li>2005年7月11日Android Inc.被美国科技企业Google收购。</li><li>2007年11月，Google与84家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良Android，随后，Google以Apache免费开放源代码许可证的授权方式，发布了Android的源代码，开放源代码加速了Android普及，让生产商推出搭载Android的智能手机，Android后来更逐渐拓展到平板电脑及其他领域上。</li><li>2010年末数据显示，Andrioid超越称霸逾十年的诺基亚Symbian系统，成为全球第一大智能手机操作系统。</li><li>2013年6月最高曾有5.38亿台活跃的安卓设备；2013年6月最高曾有10亿台活跃的安卓设备</li><li>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</li><li>2018年8月6日，Android 9宣布发行。</li></ul><h1 id="Android命名由来"><a href="#Android命名由来" class="headerlink" title="Android命名由来"></a>Android命名由来</h1><p>&emsp;&emsp;Android一词最早出现于法国作家维利耶·德·利尔－阿达姆·利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃（L’Ève future）》中。他把外表像人的机器人取名为Android。</p><h1 id="Android标志"><a href="#Android标志" class="headerlink" title="Android标志"></a>Android标志</h1><p>&emsp;&emsp;Android是一个全身绿色的机器人，半圆形的头部，有两支天线和空白的点作为眼睛。它的头部与身体之间有空白的区域，相似于一枚有平底的鸡蛋，两侧各有两个圆角矩形，作为它的双臂。Android的标志是由Ascender公司设计，颜色采用了PMS 376C和RGB中十六进制的#A4C639来绘制，这是Android操作系统的品牌象征。当中的文字使用了Ascender公司专门制作的称之为“Google Droid”的字体有时候，它会以纯文字的标志展示。</p><h2 id="Android机器人"><a href="#Android机器人" class="headerlink" title="Android机器人"></a>Android机器人</h2><p><img src="/images/Android/Android_Robot.png" alt="Android_Robot"></p><h2 id="Android字标"><a href="#Android字标" class="headerlink" title="Android字标"></a>Android字标</h2><p><img src="/images/Android/android_logo_no_2x.png" alt="android_logo"></p><h1 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h1><p>&emsp;&emsp;Android系统架构包含以下组件：<br><img src="/images/Android/ape_fwk_all.png" alt="ape_fwk_all"></p><ul><li>应用框架。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息，因此如果作为硬件开发者，需要非常了解其中的 API。</li><li>Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。</li><li>系统服务。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。 应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。</li><li>硬件抽象层 (HAL)。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。</li><li>Linux 内核。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含几个特殊的补充功能，例如：Low Memory Killer（一种内存管理系统，可更主动地保留内存）、唤醒锁定（一种 PowerManager 系统服务）、Binder IPC 驱动程序以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。</li></ul><h1 id="Android堆栈"><a href="#Android堆栈" class="headerlink" title="Android堆栈"></a>Android堆栈</h1><p>&emsp;&emsp;Android 是一个针对多种不同设备类型打造的开放源代码软件堆栈。Android 的主要目的是为运营商、OEM 和开发者打造一个开放的软件平台，使他们能够将创新理念变为现实，并推出能够卓有成效地改善用户移动体验的真实产品。<br>&emsp;&emsp;Android 平台的设计可确保不存在一个集中瓶颈，即没有任何行业参与者可一手限制或控制其他参与者的创新。这样，我们不但可以打造功能完善的高品质消费类产品，而且可以完全开放源代码，供第三方自由定制和移植。<br><img src="/images/Android/Android%E5%A0%86%E6%A0%88.png" alt="Android 堆栈"></p><h1 id="Android更新时间表"><a href="#Android更新时间表" class="headerlink" title="Android更新时间表"></a>Android更新时间表</h1><table><thead><tr><th align="center">名称</th><th align="center">版本号</th><th align="center">发行日期</th><th align="center">API等级</th><th align="center">安全性更新状态</th></tr></thead><tbody><tr><td align="center">Android 1.0</td><td align="center">1.0</td><td align="center">2008年9月23日</td><td align="center">1</td><td align="center">不支持</td></tr><tr><td align="center">Android Petit Four</td><td align="center">1.1</td><td align="center">2009年2月9日</td><td align="center">2</td><td align="center">不支持</td></tr><tr><td align="center">Android Cupcake</td><td align="center">1.5</td><td align="center">2009年4月27日</td><td align="center">3</td><td align="center">不支持</td></tr><tr><td align="center">Android Donut</td><td align="center">1.6</td><td align="center">2009年9月15日</td><td align="center">4</td><td align="center">不支持</td></tr><tr><td align="center">Android Eclair</td><td align="center">2.0 – 2.1</td><td align="center">2009年10月26日</td><td align="center">5 – 7</td><td align="center">不支持</td></tr><tr><td align="center">Android Froyo</td><td align="center">2.2 – 2.2.3</td><td align="center">2010年5月20日</td><td align="center">8</td><td align="center">不支持</td></tr><tr><td align="center">Android Gingerbread</td><td align="center">2.3 – 2.3.7</td><td align="center">2010年12月6日</td><td align="center">9 – 10</td><td align="center">不支持</td></tr><tr><td align="center">Android Honeycomb</td><td align="center">3.0 – 3.2.6</td><td align="center">2011年2月22日</td><td align="center">11 – 13</td><td align="center">不支持</td></tr><tr><td align="center">Android Ice Cream Sandwich</td><td align="center">4.0 – 4.0.4</td><td align="center">2011年10月18日</td><td align="center">14 – 15</td><td align="center">不支持</td></tr><tr><td align="center">Android Jelly Bean</td><td align="center">4.1 – 4.3.1</td><td align="center">2012年7月9日</td><td align="center">16 – 18</td><td align="center">不支持</td></tr><tr><td align="center">Android KitKat</td><td align="center">4.4 – 4.4.4</td><td align="center">2013年10月31日</td><td align="center">19 – 20</td><td align="center">不支持</td></tr><tr><td align="center">Android Lollipop</td><td align="center">5.0 – 5.1.1</td><td align="center">2014年11月12日</td><td align="center">21 – 22</td><td align="center">不支持</td></tr><tr><td align="center">Android Marshmallow</td><td align="center">6.0 – 6.0.1</td><td align="center">2015年10月5日</td><td align="center">23</td><td align="center">支持</td></tr><tr><td align="center">Android Nougat</td><td align="center">7.0 – 7.1.2</td><td align="center">2016年8月22日</td><td align="center">24 – 25</td><td align="center">支持</td></tr><tr><td align="center">Android Oreo</td><td align="center">8.0 – 8.1</td><td align="center">2017年8月21日</td><td align="center">26 – 27</td><td align="center">支持</td></tr><tr><td align="center">Android Pie</td><td align="center">9.0.0</td><td align="center">2018年8月6日</td><td align="center">28</td><td align="center">支持</td></tr><tr><td align="center">Android Q</td><td align="center">未知</td><td align="center">2019年3月13日</td><td align="center">29</td><td align="center">测试中</td></tr></tbody></table><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">wiki</a><br><a href="https://source.android.google.cn/setup/community" target="_blank" rel="noopener">Android社区</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
table th:nth-of-type(1){
width: 35%;
}
table th:nth-of-type(2){
width: 16%;
}
table th:nth-of-type(3){
width: 25%;
}
table th:nth-of
      
    
    </summary>
    
      <category term="Android" scheme="YobeZhou.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="YobeZhou.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C语言操作符优先级</title>
    <link href="YobeZhou.github.io/2019/08/09/0027-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>YobeZhou.github.io/2019/08/09/0027-C语言操作符优先级/</id>
    <published>2019-08-09T06:32:01.000Z</published>
    <updated>2019-08-13T06:32:43.559Z</updated>
    
    <content type="html"><![CDATA[<style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 20%;}table th:nth-of-type(3){width: 30%;}table th:nth-of-type(4){width: 15%;}table th:nth-of-type(5){width: 10%;}table th:nth-of-type(6){width: 15%;}</style><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;表达式的求值顺序是由3个因素决定的：操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序。两个相邻的操作符哪个先执行取决于他们的优先级，如果两者的由优先级相同，那么它们的执行顺序由他们的结核性决定。</p><h1 id="C语言操作符的优先级"><a href="#C语言操作符的优先级" class="headerlink" title="C语言操作符的优先级"></a>C语言操作符的优先级</h1><p>表 5.1 列出了C语言中每个操作符的所有属性：</p><table><thead><tr><th align="center">操作符</th><th align="left">描述</th><th align="center">用法示例</th><th align="left">结果类型</th><th align="center">结合性</th><th align="left">控制求值顺序?</th></tr></thead><tbody><tr><td align="center">()</td><td align="left">聚组</td><td align="center">(表达式)</td><td align="left">与表达式同</td><td align="center">N/A</td><td align="left">否</td></tr><tr><td align="center">()</td><td align="left">函数调用</td><td align="center">rexp(rexp,…,rexp)</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">[]</td><td align="left">下标引用</td><td align="center">rexp[rexp]</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">.</td><td align="left">访问结构成员</td><td align="center">lexp.member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">-&gt;</td><td align="left">访问结构指针成员</td><td align="center">rexp-&gt;member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">后缀自增</td><td align="center">lexp++</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">后缀自减</td><td align="center">lexp–</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!</td><td align="left">逻辑反</td><td align="center">!rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">~</td><td align="left">按位取反</td><td align="center">~rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">单目，表示正值</td><td align="center">+rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">单目，表示负值</td><td align="center">-rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">前缀自增</td><td align="center">++lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">前缀自减</td><td align="center">–lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">间接访问</td><td align="center">*rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">取地址</td><td align="center">&amp;lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">sizeof</td><td align="left">取其长度</td><td align="center">sizeof rexp; sizeof(类型)</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">(类型)</td><td align="left">类型转换</td><td align="center">(类型)rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">乘法</td><td align="center">rexp*rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">/</td><td align="left">除法</td><td align="center">rexp/rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">%</td><td align="left">整数取余</td><td align="center">rexp%rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">加法</td><td align="center">rexp+rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">减法</td><td align="center">rexp&#45;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移位</td><td align="center">rexp&#60;&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移位</td><td align="center">rexp&gt;&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;</td><td align="left">大于</td><td align="center">rexp&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于</td><td align="center">rexp&gt;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;</td><td align="left">小于</td><td align="center">rexp&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于</td><td align="center">rexp&#60;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">==</td><td align="left">等于</td><td align="center">rexp==rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!=</td><td align="left">不等于</td><td align="center">rexp!=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">位于</td><td align="center">rexp&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">^</td><td align="left">位异或</td><td align="center">rexp^rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;</td><td align="left">位或</td><td align="center">rexp&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;&amp;</td><td align="left">逻辑与</td><td align="center">rexp&amp;&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;&#124;</td><td align="left">逻辑或</td><td align="center">rexpre&#124;&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr><tr><td align="center">?:</td><td align="left">条件操作符</td><td align="center">rexp?rexp:rexp</td><td align="left">rexp</td><td align="center">N/A</td><td align="left">是</td></tr><tr><td align="center">=</td><td align="left">赋值</td><td align="center">lexp=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+=</td><td align="left">以…加</td><td align="center">lexp+=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">-=</td><td align="left">以…减</td><td align="center">lexp-=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#42;=</td><td align="left">以…乘</td><td align="center">lexp &#42;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">/=</td><td align="left">以…除</td><td align="center">lexp/=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">%=</td><td align="left">以…取模</td><td align="center">lexp%=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">以…左移</td><td align="center">lexp&lt;&lt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">以…右移</td><td align="center">lexp&gt;&gt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;=</td><td align="left">以…与</td><td align="center">lexp&amp;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">^=</td><td align="left">以…异或</td><td align="center">lexp^=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#124;=</td><td align="left">以…或</td><td align="center">lexp&#124;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">,</td><td align="left">逗号</td><td align="center">rexp,rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr></tbody></table><h1 id="附：Markdown特殊字符转义"><a href="#附：Markdown特殊字符转义" class="headerlink" title="附：Markdown特殊字符转义"></a>附：Markdown特殊字符转义</h1><p>&emsp;&emsp;虽然hexo的语法是Markdown格式的，但是在书写时对于特殊字符使用“\“转义是不严谨的做法，最好的方式是使用特殊字符对应的编码，对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &amp;emsp;          --&gt; 空格(Space)</span><br><span class="line">!   &amp;#33;           --&gt; 惊叹号 (Exclamation mark) </span><br><span class="line">”   &amp;#34; &amp;quot;    --&gt; 双引号 (Quotation mark)</span><br><span class="line">#   &amp;#35;           --&gt; 数字标志 (Number sign)</span><br><span class="line">$   &amp;#36;           --&gt; 美元标志(Dollar sign)</span><br><span class="line">%   &amp;#37;           --&gt; 百分号(Percent sign)</span><br><span class="line">&amp;   &amp;#38; &amp;amp;     --&gt; 和号(Ampersand)</span><br><span class="line">|   &amp;#124;          --&gt; 竖线(Vertical bar) </span><br><span class="line">‘   &amp;#39;           --&gt; 单引号(Apostrophe) </span><br><span class="line">(   &amp;#40;           --&gt; 小括号左边部分(Left parenthesis) </span><br><span class="line">)   &amp;#41;           --&gt; 小括号右边部分(Right parenthesis) </span><br><span class="line">+   &amp;#43;           --&gt; 加号(Plus sign)</span><br><span class="line">-   &amp;#45; &amp;minus;   --&gt; 减号(Minus sign)</span><br><span class="line">*   &amp;#42;           --&gt; 星号(Asterisk)</span><br><span class="line">\   &amp;#92;           --&gt; 反斜杠(Reverse solidus (backslash)) </span><br><span class="line">&lt;   &amp;#60; &amp;lt;      --&gt; 小于号(Less than) </span><br><span class="line">=   &amp;#61;           --&gt; 等于符号(Equals sign)</span><br><span class="line">&gt;   &amp;#62;           --&gt; 大于号(Greater than)</span><br><span class="line">?   &amp;#63;           --&gt; 问号(Question mark)</span><br><span class="line">@   &amp;#64;           --&gt; 在标志(Commercial at)</span><br><span class="line">[   &amp;#91;           --&gt; 中括号左边部分(Left square bracket) </span><br><span class="line">]   &amp;#93;           --&gt; 中括号右边部分(Right square bracket)</span><br><span class="line">&#123;   &amp;#123;          --&gt; 大括号左边部分(Left curly brace) </span><br><span class="line">&#125;   &amp;#125;          --&gt; 大括号右边部分(Right curly brace)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 20%;
}
table th:nth-of-type(3){
width: 30%;
}
table th:nth-of
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Repo入门</title>
    <link href="YobeZhou.github.io/2019/08/08/0026-repo%E5%85%A5%E9%97%A8/"/>
    <id>YobeZhou.github.io/2019/08/08/0026-repo入门/</id>
    <published>2019-08-08T09:49:55.000Z</published>
    <updated>2019-08-09T06:33:18.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>&emsp;&emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自动化部分开发工作流程。但是Repo并不是要取代Git，只是为了让Git更容易使用。repo命令只是一个可执行的Python脚本，我们可以将其放在路径中的任何位置。</p><h1 id="Repo、Git、Gerrit三者的区别"><a href="#Repo、Git、Gerrit三者的区别" class="headerlink" title="Repo、Git、Gerrit三者的区别"></a>Repo、Git、Gerrit三者的区别</h1><h2 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h2><p>&emsp;&emsp;Git 是一个开放源代码的版本控制系统，专用于处理分布在多个代码库上的大型项目。在 Android 环境中，我们会使用 Git 执行本地操作，例如建立本地分支、提交、查看更改、修改。</p><h2 id="1-2-Repo"><a href="#1-2-Repo" class="headerlink" title="1.2 Repo"></a>1.2 Repo</h2><p>&emsp;&emsp;Repo 是我们以 Git 为基础构建的代码库管理工具。Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到我们的修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让我们在 Android 环境中更轻松地使用 Git。Repo 命令是一段可执行的 Python 脚本，我们可以将其放在路径中的任何位置。使用 Android 源代码文件时，就可以使用 Repo 执行跨网络操作。例如，可以借助单个 Repo 命令，将文件从多个代码库下载到本地工作目录。</p><h2 id="1-3-Gerrit"><a href="#1-3-Gerrit" class="headerlink" title="1.3 Gerrit"></a>1.3 Gerrit</h2><p>&emsp;&emsp;Gerrit 是一个基于网页的代码审核系统，适用于使用 Git 的项目。Gerrit 允许所有授权用户提交更改（如果通过代码审核，这些更改会自动纳入项目中），以此鼓励其他人更集中地使用 Git。此外，Gerrit 可以在浏览器中并排显示更改，并支持代码内注释，使得审核工作变得更轻松！</p><h1 id="2-Repo的工作原理"><a href="#2-Repo的工作原理" class="headerlink" title="2. Repo的工作原理"></a>2. Repo的工作原理</h1><p>&emsp;&emsp;repo需要关注当前git库的数量、名称、路径等，有了这些基本信息，才能对这些git库进行操作。通过集中维护所有git库的清单，repo可以方便的从清单中获取git库的信息。 这份清单会随着版本演进升级而产生变化，同时也有一些本地的修改定制需求，所以，repo是通过一个git库来管理项目的清单文件的，这个git库名字叫manifests。<br>&emsp;&emsp;当打开repo这个可执行的python脚本后，发现代码量并不大(不超过1000行)，难道仅这一个脚本就完成了AOSP数百个git库的管理吗？并非如此。 repo是一系列脚本的集合，这些脚本也是通过git库来维护的，这个git库名字叫repo。<br>&emsp;&emsp;在客户端使用repo初始化一个项目时，就会从远程把manifests和repo这两个git库拷贝到本地，但这对于Android开发人员来说，又是近乎无形的(一般通过文件管理器，是无法看到这两个git库的)。 repo将自动化的管理信息都隐藏根目录的.repo子目录中。</p><h1 id="3-安装Repo"><a href="#3-安装Repo" class="headerlink" title="3. 安装Repo"></a>3. 安装Repo</h1><p>创建目录并修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h2 id="3-1-下载repo"><a href="#3-1-下载repo" class="headerlink" title="3.1 下载repo"></a>3.1 下载repo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x ~/bin/repo</span></span><br></pre></td></tr></table></figure><h2 id="3-3-获取帮助"><a href="#3-3-获取帮助" class="headerlink" title="3.3 获取帮助"></a>3.3 获取帮助</h2><p>&emsp;&emsp;安装 Repo 后，运行以下命令可以找到最新文档（开头是包含所有命令的摘要）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-查询具体命令的帮助"><a href="#3-4-查询具体命令的帮助" class="headerlink" title="3.4 查询具体命令的帮助"></a>3.4 查询具体命令的帮助</h2><p>&emsp;&emsp;在 Repo 树中运行以下命令来获取有关某个命令的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> &lt;COMMAND&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-查看Repo-init-参数的说明和选项列表"><a href="#3-5-查看Repo-init-参数的说明和选项列表" class="headerlink" title="3.5 查看Repo init 参数的说明和选项列表"></a>3.5 查看Repo init 参数的说明和选项列表</h2><p>&emsp;&emsp;此命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 <a href="https://source.android.com/source/using-repo.html#init" target="_blank" rel="noopener">init</a>。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> init</span></span><br></pre></td></tr></table></figure><h1 id="4-初始化仓库"><a href="#4-初始化仓库" class="headerlink" title="4. 初始化仓库"></a>4. 初始化仓库</h1><p>&emsp;&emsp;初始化仓库命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示范：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo init -u https://android.googlesource.com/platform/manifest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这将在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。<br>选项：</p><ul><li>-u：指定要从中检索清单代码库的网址。可以在 <a href="https://android.googlesource.com/platform/manifest" target="_blank" rel="noopener">https://android.googlesource.com/platform/manifest</a> 中找到常见清单</li><li>-m：在代码库中选择清单文件。如果未选择任何清单名称，则会默认选择 default.xml。</li><li>-b：指定修订版本，即特定的清单分支。</li></ul><blockquote><p>注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo/ 的父目录或相应父目录的子目录。</p></blockquote><h1 id="5-拉取仓库"><a href="#5-拉取仓库" class="headerlink" title="5. 拉取仓库"></a>5. 拉取仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo sync PROJECT0 PROJECT1 PROJECT2 ...</span></span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-j <numbers>： 多任务，一般8核心可以开到16任务,过多会起反作用</numbers></li><li>-c： 只下载当前分支代码</li><li>-d： 让工程回退到manifest指定的版本</li><li>-f： 如果某个工程同步失败，继续同步</li></ul><h1 id="6-修改仓库结构"><a href="#6-修改仓库结构" class="headerlink" title="6. 修改仓库结构"></a>6. 修改仓库结构</h1><p>&emsp;&emsp;如果想修改repo的结构，应该在 .repo/manifests 文件夹里面修改 default.xml 文件，然后用git命令提交。default.xml 文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">"git://git.mygit.com/"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"kk-shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">"1"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"packages/shift/VideoPlayer"</span> <span class="attr">name</span>=<span class="string">"platform/packages/shift/VideoPlayer"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"another_manifest.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>该文件内容的理解，请移步</p></blockquote><h1 id="7-理解repo-init后生成的-repo目录结构"><a href="#7-理解repo-init后生成的-repo目录结构" class="headerlink" title="7. 理解repo init后生成的.repo目录结构"></a>7. 理解repo init后生成的.repo目录结构</h1><p>&emsp;&emsp;当我们执行repo init命令之后会在当前目录下生成’.repo’目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree .repo -L 1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests</span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml -&gt; manifests/default.xml</span><br><span class="line">├── project.list</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br></pre></td></tr></table></figure><p>.repo目录理解：</p><ul><li>manifests：一个git库，包含default.xml文件，用于描述repo所管理的git库的信息</li><li>manifests.git：manifest这个git库的实体，manifest/.git目录下的所有文件都会链接到该目录</li><li>manifests/default.xml：工作树的主配置文件，一般不要编辑这个文件</li><li>projects/：每个git工程的 .git结构</li><li>manifest.xml：这是一个指向 .repo/manifests/ 目录中所选清单的符号链接</li><li>project.list：git库的所有仓库列表</li><li>repo/： 一个git库，包含repo运行的所有脚本</li></ul><h1 id="8-default-xml-文件解读"><a href="#8-default-xml-文件解读" class="headerlink" title="8. default.xml 文件解读"></a>8. default.xml 文件解读</h1><ul><li>manifest<br>&emsp;&emsp;这个是配置的顶层元素，即根标志</li><li>remote</li></ul><ul><li>name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。</li><li>alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url</li><li>fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径</li><li>review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果</li></ul><ul><li>default<br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</li></ul><ul><li>remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了）</li><li>revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch</li><li>sync_j ： 在repo sync中默认并行的数目</li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li></ul><ul><li>manifest-server<br>它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务，它要支持一下RPC方法：</li></ul><ul><li>GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。</li><li>target参数来自环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT，组成$TARGET_PRODUCT-$TARGET_BUILD_VARIANT</li><li>GetManifest(tag) ：返回指定tag的manifest</li></ul><ul><li>project<br>需要clone的单独git</li></ul><ul><li>name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name</li><li>path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样</li><li>remote ：定义remote name，如果没有定义的话就用default中定义的remote name</li><li>revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值</li><li>groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于</li><li>name:’name’ 和path:’path’组。例如<project name="monkeys" path="barrel-of">，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载</project></li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li><li>upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间</li><li>annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量</li></ul><ul><li>include<br>通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径)</li></ul><ul><li>name ：另一个需要导入的manifest文件名字<br>可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project</li></ul><ul><li>remove-project<br>&emsp;&emsp;从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义</li></ul><h1 id="9-Google提供的参考资源"><a href="#9-Google提供的参考资源" class="headerlink" title="9. Google提供的参考资源"></a>9. Google提供的参考资源</h1><p>&emsp;&emsp;主页：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;错误报告：<a href="https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo" target="_blank" rel="noopener">https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo</a><br>&emsp;&emsp;资料来源：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;概述：<a href="https://source.android.com/source/developing.html" target="_blank" rel="noopener">https://source.android.com/source/developing.html</a><br>&emsp;&emsp;文档：<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">https://source.android.com/source/using-repo.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自
      
    
    </summary>
    
      <category term="Git" scheme="YobeZhou.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="YobeZhou.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C语言显示数据处理进度条</title>
    <link href="YobeZhou.github.io/2019/07/11/0025-C%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>YobeZhou.github.io/2019/07/11/0025-C语言显示数据处理进度条/</id>
    <published>2019-07-11T07:03:41.000Z</published>
    <updated>2019-07-11T09:42:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。<br>&emsp;&emsp;我们见过比如使用git clone命令下载的时候显示的进度那样的效果，类似的还有很多，很多linux命令执行后一般都会有进度条显示，那么我们该怎样实现那样的效果呢？</p><blockquote><p>操作环境：linux；Linux+GCC</p></blockquote><h1 id="从C语言printf格式化控制台移动光标说起"><a href="#从C语言printf格式化控制台移动光标说起" class="headerlink" title="从C语言printf格式化控制台移动光标说起"></a>从C语言printf格式化控制台移动光标说起</h1><p>&emsp;&emsp;在Linux环境下，光标的移动、背景色和字体颜色的设置非常简单。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[47;31mhello world\033[5m"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;47是字背景颜色, 31是字体的颜色, hello world是字符串. 后面的\033[5m是控制码。字背景颜色范围: 40–49 字颜色: 30–39。<br>表2-1 字背景颜色及字颜色范围表</p><table><thead><tr><th align="center">数值</th><th align="left">背景颜色</th><th align="center">数值</th><th align="left">字颜色</th></tr></thead><tbody><tr><td align="center">40</td><td align="left">黑</td><td align="center">30</td><td align="left">黑</td></tr><tr><td align="center">41</td><td align="left">红</td><td align="center">31</td><td align="left">红</td></tr><tr><td align="center">42</td><td align="left">绿</td><td align="center">32</td><td align="left">绿</td></tr><tr><td align="center">43</td><td align="left">黄</td><td align="center">33</td><td align="left">黄</td></tr><tr><td align="center">44</td><td align="left">蓝</td><td align="center">34</td><td align="left">蓝</td></tr><tr><td align="center">45</td><td align="left">紫</td><td align="center">35</td><td align="left">紫</td></tr><tr><td align="center">46</td><td align="left">深绿</td><td align="center">36</td><td align="left">深绿</td></tr><tr><td align="center">47</td><td align="left">白色</td><td align="center">37</td><td align="left">白色</td></tr></tbody></table><p>表2-2 ANSI控制码表</p><table><thead><tr><th align="center">ANSI控制码</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">\033[0m</td><td align="left">关闭所有属性</td></tr><tr><td align="center">\033[1m</td><td align="left">设置高亮度</td></tr><tr><td align="center">\03[4m</td><td align="left">下划线</td></tr><tr><td align="center">\033[5m</td><td align="left">闪烁</td></tr><tr><td align="center">\033[7m</td><td align="left">反显</td></tr><tr><td align="center">\033[8m</td><td align="left">消隐</td></tr><tr><td align="center">\033[30m – \033[37m</td><td align="left">设置前景色</td></tr><tr><td align="center">\033[40m – \033[47m</td><td align="left">设置背景色</td></tr><tr><td align="center">\033[nA</td><td align="left">光标上移n行</td></tr><tr><td align="center">\03[nB</td><td align="left">光标下移n行</td></tr><tr><td align="center">\033[nC</td><td align="left">光标右移n行</td></tr><tr><td align="center">\033[nD</td><td align="left">光标左移n行</td></tr><tr><td align="center">\033[y;xH</td><td align="left">设置光标位置</td></tr><tr><td align="center">\033[2J</td><td align="left">清屏</td></tr><tr><td align="center">\033[K</td><td align="left">清除从光标到行尾的内容</td></tr><tr><td align="center">\033[s</td><td align="left">保存光标位置</td></tr><tr><td align="center">\033[u</td><td align="left">恢复光标位置</td></tr><tr><td align="center">\033[?25l</td><td align="left">隐藏光标</td></tr><tr><td align="center">\33[?25h</td><td align="left">显示光标</td></tr></tbody></table><h2 id="实现显示进度条代码"><a href="#实现显示进度条代码" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法的优点是，由于每次打印显示之前都是先将光标移动到行首并将其后的所有输出内容清除，因此当控制台有其他字符输出时，也不会导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress（进度百分比，取值为0~100）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,本次显示进度条时所输出的字符个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移动到行首并清除从当前光标到行尾的所有内容 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\033[k"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回本次显示进度条时所输出的字符个数 */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用’-b’退格字符实现"><a href="#使用’-b’退格字符实现" class="headerlink" title="使用’\b’退格字符实现"></a>使用’\b’退格字符实现</h1><p>&emsp;&emsp;在C语言中，提供了转义字符’\b’来进行输出后的退格操作。在编程过程中，我们有时候需要进行退格操作。但是，我在以前使用的过程中，发现我使用语句printf(“abc\b”);之后，在输出结果中还是显示的abc并不是我希望得到的ab。</p><h2 id="用法及原理"><a href="#用法及原理" class="headerlink" title="用法及原理"></a>用法及原理</h2><p>&emsp;&emsp;在用’\b’进行退格操作的时候，实际上，每次使用’\b’字符之后，控制台的输出光标会后退一个字符的位置，但是并没有将相应的字符删除。所以，我们需要在’\b’字符后面紧跟一个字符，用来代替需要删除的字符。如果后面没有需要输出的字符，可以用至少一个空格跟在’\b’后面，用来替换需要删除的字符。<br>&emsp;&emsp;该’\b’退格字符，也可以多个连用，以实现对多个字符的删除操作，但是需要注意的是，想要删除几个字符就要使用至少几个’\b’，对应的也需要有相等数量的字符用来替换待删除的字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="对单个字符进行退格操作（删除单个字符）"><a href="#对单个字符进行退格操作（删除单个字符）" class="headerlink" title="对单个字符进行退格操作（删除单个字符）"></a>对单个字符进行退格操作（删除单个字符）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\bv"</span>);  <span class="comment">//此处的输出结果是abv，后面的'v'就是用来替换'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b"</span>);  <span class="comment">//此处的输出结果是abc，可以看出虽然用了'\b'退格，但是并没有提供相应的用来替换最后一个字符'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b "</span>);  <span class="comment">//此处的输出结果是ab，因为在'\b'后面，跟了一个空格' '来替换了字符'c'</span></span><br></pre></td></tr></table></figure><h3 id="对多个字符进行退格操作（删除字符串）"><a href="#对多个字符进行退格操作（删除字符串）" class="headerlink" title="对多个字符进行退格操作（删除字符串）"></a>对多个字符进行退格操作（删除字符串）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b.new"</span>);  <span class="comment">//此处的输出结果是ph.new，后面的字符串".new"是用来替换"rase"的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b newString"</span>);  <span class="comment">//此处输出的结果是ph  newString，中间用了两个空格来代替字符串"ra"，紧接着用了两个字符"ne"来代替字符串"se"，再后面多出的"wString"字符串，则原样输出。</span></span><br></pre></td></tr></table></figure><h2 id="实现显示进度条代码-1"><a href="#实现显示进度条代码-1" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法有个致命的缺点，当控制台有其他字符输出的时候会打乱现有的显示位置，导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress           进度百分比，取值为0~100</span></span><br><span class="line"><span class="comment">* @param[in] last_char_count    上一次显示进度条时所用到的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,目前进度条打印的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress, <span class="keyword">int</span> last_char_count)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把上次显示的进度条信息全部清空*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; last_char_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\b"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回本次显示进度条时所输出的字符个数*/</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================================================================================================&gt;&gt;   [99%]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用C语言对IP地址排序</title>
    <link href="YobeZhou.github.io/2019/06/21/0024-%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AF%B9IP%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F/"/>
    <id>YobeZhou.github.io/2019/06/21/0024-使用C语言对IP地址排序/</id>
    <published>2019-06-21T03:50:30.000Z</published>
    <updated>2019-07-04T11:21:28.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。<br>&emsp;&emsp;程序运行环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- windows 10 64-bit</span><br><span class="line">- Visual Studio 2015</span><br></pre></td></tr></table></figure><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>&emsp;&emsp;假设IP地址格式为：a.b.c.d<br>&emsp;&emsp;由观察可知：每个数字的范围在0~255之间，灭个字段都是模256的余数，则可以将所有字段按照所在位置乘以256的对应次幂。<br>&emsp;&emsp;由观察可得公式：(a<em>256^3) + (b</em>256^2) + (c<em>256^1) + (d</em>256^0)<br>这样我们就可以得到一个长整数。每个IP地址对应一个长整数，只要将IP地址与对应求得的长整数用链表保存起来。这样我们就将问题转换为基数排序，结果的排序即为索求排序，只需用指针或者下标等方法将两者对应。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort_ip_ddresses.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *ip_Str;    <span class="comment">// 数据域</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ip_Int;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;link;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">创建链表 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">creatLink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建头结点 */</span></span><br><span class="line">link * p = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link)); </span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">往链表增加项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link * <span class="title">addLink</span><span class="params">(link * head, <span class="keyword">char</span> *str, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = head;</span><br><span class="line">link *targeLink = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line"><span class="keyword">if</span> (targeLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入结点前申请内存失败！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">targeLink-&gt;ip_Int = value;</span><br><span class="line">targeLink-&gt;ip_Str = str;</span><br><span class="line">targeLink-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tempLink-&gt;next = targeLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tempLink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapStr</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr;</span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str1);</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"><span class="built_in">strcpy</span>(str2, tempStr);</span><br><span class="line"><span class="built_in">free</span>(tempStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *value1, <span class="keyword">long</span> <span class="keyword">long</span> *value2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempValue = *value1;</span><br><span class="line"></span><br><span class="line">*value1 = *value2;</span><br><span class="line">*value2 = tempValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">排序链表【冒泡排序】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">sortTheLinkedList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> canSort = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">while</span> (tempLink != head-&gt;next &amp;&amp; canSort)</span><br><span class="line">&#123;</span><br><span class="line">link *q = head;</span><br><span class="line">canSort = <span class="literal">false</span>;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">for</span> (; q-&gt;next &amp;&amp; q-&gt;next != q; q = q-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if ((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) &gt; 0))  //|| (((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) == 0)) &amp;&amp; (strlen(q-&gt;ip_Str) &gt; strlen(q-&gt;next-&gt;ip_Str)))</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;ip_Int &gt; q-&gt;next-&gt;ip_Int)</span><br><span class="line">&#123;</span><br><span class="line">swapStr(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str);</span><br><span class="line">swapValue(&amp;q-&gt;ip_Int, &amp;q-&gt;next-&gt;ip_Int);</span><br><span class="line">canSort = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tempLink = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历并输出链表内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">showLinkInf</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">link *tempLink = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tempLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：%s，\t大小：%lld\n"</span>, tempLink-&gt;ip_Str, tempLink-&gt;ip_Int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表长度: %d\n\n"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">清空链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tempLink);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strCpy</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(tempStr2, str, len);</span><br><span class="line"><span class="keyword">return</span> tempStr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设IP地址格式为：a.b.c.d</span></span><br><span class="line"><span class="comment">由观察可知：每个数字的范围在0~255之间，则可以将其看成一个四位的256进制数。</span></span><br><span class="line"><span class="comment">由观察可得公式：(a*256^3) + (b*256^2) + (c*256^1) + (d*256^0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">strToInt</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> calcValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> strTIntVal;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">strTIntVal = (<span class="keyword">long</span> <span class="keyword">long</span>)atoi(tokStr);</span><br><span class="line">calcValue = calcValue * <span class="number">256</span> + strTIntVal;</span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> calcValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strTok</span><span class="params">(link * head, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分割字符串 */</span></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">tempLongData = strToInt(tokStr, <span class="built_in">strlen</span>(tokStr));</span><br><span class="line"><span class="comment">//tempStr = strCpy(tokStr, strlen(tokStr));</span></span><br><span class="line">addLink(head, tokStr, tempLongData);<span class="comment">// 加入链表</span></span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> len, tempLen;</span><br><span class="line"><span class="keyword">int</span> linkCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line">link * ipLink = creatLink();</span><br><span class="line"></span><br><span class="line">buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*MAX_LINE);</span><br><span class="line">fp = fopen(<span class="string">"ipAddress.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"打开文件失败！\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="built_in">free</span>(ipLink);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAX_LINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">tempLen = len;</span><br><span class="line">strTok(ipLink, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sortTheLinkedList(ipLink);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!showLinkInf(ipLink))<span class="built_in">printf</span>(<span class="string">"链表为空，遍历失败！\n"</span>);</span><br><span class="line"></span><br><span class="line">emptyList(ipLink);</span><br><span class="line">fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="需排序的IP地址文本"><a href="#需排序的IP地址文本" class="headerlink" title="需排序的IP地址文本"></a>需排序的IP地址文本</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">92</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">82</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">72</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">62</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IP地址：<span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">1722286341</span></span><br><span class="line">IP地址：<span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">1890058517</span></span><br><span class="line">IP地址：<span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">2057830659</span></span><br><span class="line">IP地址：<span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">2225602825</span></span><br><span class="line">IP地址：<span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">2393374983</span></span><br><span class="line">IP地址：<span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">2561147142</span></span><br><span class="line">IP地址：<span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">2728919811</span></span><br><span class="line">IP地址：<span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">2896691460</span></span><br><span class="line">IP地址：<span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3064463875</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">3232235779</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">3232235780</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">3232235781</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">3232235782</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">3232235783</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> ，  大小：<span class="number">3232235784</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">3232235785</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">3232235797</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> ，  大小：<span class="number">3232236034</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3232236035</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> ， 大小：<span class="number">3232236047</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">3232236291</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> ，  大小：<span class="number">3232236292</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> ，  大小：<span class="number">3232236293</span></span><br><span class="line">链表长度: <span class="number">31</span></span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。&lt;br&gt;&amp;emsp;&amp;emsp;程序运行环境
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C/C++,排序,链表" scheme="YobeZhou.github.io/tags/C-C-%E6%8E%92%E5%BA%8F-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C标准库--string.h</title>
    <link href="YobeZhou.github.io/2019/06/13/0023-C%E6%A0%87%E5%87%86%E5%BA%93-string-h/"/>
    <id>YobeZhou.github.io/2019/06/13/0023-C标准库-string-h/</id>
    <published>2019-06-13T08:03:43.000Z</published>
    <updated>2019-07-11T09:19:16.729Z</updated>
    
    <content type="html"><![CDATA[<style>table th:nth-of-type(1){width: 8%;}table th:nth-of-type(2){width: 92%;}</style><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、strcmp、strcpy等等，更详细的可以到include文件夹里面查看该文件。</p><h1 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h1><p>&emsp;&emsp;头文件 string.h 中定义的变量类型：</p><table><thead><tr><th align="center">变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">size_t</td><td align="left">这是无符号整数类型，它是 sizeof 关键字的结果</td></tr></tbody></table><h1 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h1><p>头文件 string.h 中定义的宏：</p><table><thead><tr><th align="center">宏</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">NULL</td><td align="left">这个宏是一个空指针常量的值</td></tr></tbody></table><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><p>头文件 string.h 中定义的函数，有下表列出的22种用法。</p><table><thead><tr><th align="center">序号</th><th align="left">函数&amp;描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">void *memchr(const void *str, int c, size_t n)<br>在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">2</td><td align="left">int memcmp(const void *str1, const void *str2, size_t n)<br>把 str1 和 str2 的前 n 个字节进行比较。</td></tr><tr><td align="center">3</td><td align="left">void *memcpy(void *dest, const void *src, size_t n)<br>从 src 复制 n 个字符到 dest。</td></tr><tr><td align="center">4</td><td align="left">void *memmove(void *dest, const void *src, size_t n)<br>另一个用于从 src 复制 n 个字符到 dest 的函数。</td></tr><tr><td align="center">5</td><td align="left">void *memset(void *str, int c, size_t n)<br>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</td></tr><tr><td align="center">6</td><td align="left">char *strcat(char *dest, const char *src)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</td></tr><tr><td align="center">7</td><td align="left">char *strncat(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</td></tr><tr><td align="center">8</td><td align="left">char *strchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">9</td><td align="left">int strcmp(const char *str1, const char *str2)<br>把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</td></tr><tr><td align="center">10</td><td align="left">int strncmp(const char *str1, const char *str2, size_t n)<br>把 str1 和 str2 进行比较，最多比较前 n 个字节。</td></tr><tr><td align="center">11</td><td align="left">int strcoll(const char *str1, const char *str2)<br>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</td></tr><tr><td align="center">12</td><td align="left">char *strcpy(char *dest, const char *src)<br>把 src 所指向的字符串复制到 dest。</td></tr><tr><td align="center">13</td><td align="left">char *strncpy(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</td></tr><tr><td align="center">14</td><td align="left">size_t strcspn(const char *str1, const char *str2)<br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td></tr><tr><td align="center">15</td><td align="left">char *strerror(int errnum)<br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td></tr><tr><td align="center">16</td><td align="left">size_t strlen(const char *str)<br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td></tr><tr><td align="center">17</td><td align="left">char *strpbrk(const char *str1, const char *str2)<br>检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td></tr><tr><td align="center">18</td><td align="left">char *strrchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">19</td><td align="left">size_t strspn(const char *str1, const char *str2)<br>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</td></tr><tr><td align="center">20</td><td align="left">char *strstr(const char *haystack, const char *needle)<br>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</td></tr><tr><td align="center">21</td><td align="left">char *strtok(char *str, const char *delim)<br>分解字符串 str 为一组字符串，delim 为分隔符。</td></tr><tr><td align="center">22</td><td align="left">size_t strxfrm(char *dest, const char *src, size_t n)<br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</td></tr></tbody></table><blockquote><p>更详细的内容请查阅include文件夹中的文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
table th:nth-of-type(1){
width: 8%;
}
table th:nth-of-type(2){
width: 92%;
}
&lt;/style&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="C/++" scheme="YobeZhou.github.io/categories/C/"/>
    
    
      <category term="C/C++" scheme="YobeZhou.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>进程之进程调度</title>
    <link href="YobeZhou.github.io/2019/06/04/0022-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>YobeZhou.github.io/2019/06/04/0022-进程之进程调度/</id>
    <published>2019-06-04T01:00:00.000Z</published>
    <updated>2019-06-04T01:45:02.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。为了满足这些目标，进程调度器（process scheduler）选择一个可用进程（可能从多个可用进程集合中）到CPU上执行。单处理器系统不会具有多个正在运行的进程。如果有多个进程，那么余下的需要等待CPU空闲并能重新调度。</p><h1 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h1><p>&emsp;&emsp;进程在进入系统时，会被加到作业队列（job queue），这个队列包括系统内的所有进程。驻留在内存中的、就绪的、等待运行的进程保存在就绪队列（ready queue）上。这个队列通常用链表实现；其头节点有两个指针，用于指向链表的第一个和最后一个PCB块，每个PCB还包括一个指针，指向就绪队列的下一个PCB。<br>&emsp;&emsp;系统还有其他队列。当一个进程被分配了CPU后，它执行一段时间，最终退出，或被中断，或等待特定事件发生，如I/O请求的完成。我们假设进程向一个共享设备，如磁盘，发出I/O请求。由于系统具有许多进程，磁盘可能忙于其他进程的I/O请求，因此该进程可能需要等待磁盘空闲。等待特定I/O设备的进程列表，称为设备队列（device queue）。每个设备都有自己的设备队列。</p><p><img src="/images/operating-system/process/2-1_Ready-Queue-And-Various-IO-Device-Queues.png" alt="就绪队列和各种IO设备队列"></p><center>图2-1 就绪队列和各种IO设备队列</center>&emsp;&emsp;进程调度通常用队列图（queueing diagram）来表示，如图1-2所示。每个举行框代表一个队列；这里具有两种队列：就绪队列和设备队列。圆圈表示服务队列的资源；箭头表示系统内的进程流向。<p><img src="/images/operating-system/process/2-2_Representation-of-Process-Scheduling.jpg" alt="表示进程调度的队列图"></p><center>图2-2 表示进程调度的队列</center>&emsp;&emsp;最初，新进程被加载到就绪队列；之后它便在就绪队列中一直等待，知道被选中执行或被分配（dispatched）。当该进程分配到CPU并执行时，以下事件可能发生：* 进程可能发出I/O请求，并被放到I/O队列。* 进程可能创建一个新的子进程，并等待其终止。* 进程可能由于中断而被强制释放CPU，并被放回到就绪队列。对于前面两种情况，进程最终从等待状态切换到就绪状态，并放回到就绪队列。进程重复这一循环直到终止；然后它会从所有队列中删除，其PCB和资源也被释放。<h1 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h1><p>&emsp;&emsp;进程在整个生命周期中，会在葛总调度队列之间迁移。操作系统为了调度必须按一定方式从这些队列中选择进程。进程选择通过适当调度器或调度程序(scheduler)来执行。<br>&emsp;&emsp;通常，对于批处理系统（又名批处理操作系统），提交的进程多于可以立即执行的。这些进程会被保存到大容量存储设备(通常为磁盘)的缓冲池，以便以后执行。长期调度程序(long-term scheduler)或作业调度程序(job scheduler)从该池中选择进程，加到内存，以便执行。短期调度程序（short-term scheduler）或CPU调度程序(CPU scheduler)从准备执行的进程中选择进程，并分配CPU。<br>&emsp;&emsp;这两种调度程序的主要区别是执行频率。短期调度程序必须经常为CPU选择新的进程。进程可能执行几毫秒(ms)，就会等待I/0请求。通常，短期调度程序每100ms至少执行一次。由于执行之间的时间短，短期调度程序必须快速.如果花费10ms来确定执行一个运行一个100ms的进程，那么 10/(100+10)=9% 的CPU时间会用在(或浪费在)调度工作上。<br>&emsp;&emsp;长期调度程序执行并不频繁；在新进程的创建之间，可能有几分钟间隔。长期调度程序控制多道程序程度(degree of multiprogramming)(内存中的进程数量)。如果多道程序程度稳定，那么创建进程的平均每度必须等于进程离开系统的平均速度。因此，只有在进程离开系统时，才需要长期调度程序的调度。由于每次执行之间的更长时间间隔，长期调度程序可以负担得起更多时间，以便决定应该选择执行哪个进程。<br>&emsp;&emsp;重要的是，长期调度程序进行认真选择。通常，大多数进程可分为：I/0为主或CPU为主。I/0密集型进程(I/O-bound process)，执行I/0比执行计算需要花费更多时间。相反，CPU密集型进程(CPU-bound process)很少产生I/O请求，而是将更多时间用于执行计算。重要的是，长期调度程序应该选择I/O密集型和CPU密集型的合理进程组合。</p><ul><li>如果所有进程都是I/O密集型的，那么就绪队列几乎总是为空，从而短期调度程序没有什么可做。</li><li>如果所有进程都是CPU密集型的，那么I/0等待队列几乎总是为空，从而设备没有得到使用，因而系统会不平衡。为了使得性能最佳，系统需要I/O密集型和CPU密集型的进程合理组合。</li></ul><p>&emsp;&emsp;有的系统，可能没有或极少采用长期调度程序。例如，UNIX或微软Windows的分时系统通常没有长期调度程序，只是简单将所有新进程放于内存，以供短期调度程序使用。这些系统的稳定性取决于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么有的用户就会退出。<br>&emsp;&emsp;有的操作系统如分时系统，可能引人一个额外的中期调度程序(medium-term scheduler)。中期调度程序的核心思想是可将进程从内存(或从CPU竞争)中移出，从而降低多道程序程度。之后，进程可被重新调人内存，并从中断处继续执行。这种方案称为交换（swap）。通过中期调度，进程可换出（swap out），并在后来可换入（swap in）。为了改善进程组合，或者由于内存需求改变导致过渡使用内存从而需要释放内存，就有必要使用交换。</p><p><img src="/images/operating-system/process/2-3_Addition-of-Medium-Term-Scheduling.png" alt="添加中级进程调度到队列"></p><center>图3-1 添加中级进程调度到队列</center><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>&emsp;&emsp;中断导致CPU从执行当前任务改变到执行内核程序。这种操作在通用系统中经常发生。当中断发生时，系统需要保存当前运行在CPU上的进程的上下文，以便在处理后能够恢复上下文，即先挂起进程，在恢复进程。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等。通常，通过执行状态保存（state save），保存CPU当前状态（包括系统模式和用户模式）；之后，装填回复（state restore）重新开始运行。<br>&emsp;&emsp;切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称上下文切换(context swiitch)。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。上下文切换的时间是纯粹的开销，因为在切换时系统并没有做任何有用工作。上下文切换的速度因机器不同而有所不同，它依赖于内存速度、必须复制的寄存器数量、是否有特殊指令(如加载或存储所有寄存器的单个指令)。典型速度为几毫秒。<br>&emsp;&emsp;上下文切换的时间与硬件支持密切相关。例如，有的处理器(如Sun U1traspARC)提供了多个寄存器组，上下文切换只需简单改变当前寄存器组的指针。当然，如果活动进程数量超过寄存器的组数，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的就越多。高级的内存管理技术在每次上下文切换时，所需切换的数据会更多。例如，在使用下一个进程的地址空间之前，需要保存当前进程的地址空间。如何保存地址空间，需要做什么才能保存等，取决于操作系统的内存管理方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程，当不执行时，位于某个等待队列。操作系统有两种主要队列：I/O请求队列和就绪队列。就绪队列包括所有准备执行并等待CPU的进程，每个进程都用PCB来表示。<br>&emsp;&emsp;操作系统应从各个调度队列中选择进程。长期调度（用于作业）选择进程以便竞争CPU。通常长期调度充分考虑资源分配，尤其是内存管理。短期调度从就绪队列中选择进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="YobeZhou.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程之基础概念</title>
    <link href="YobeZhou.github.io/2019/06/03/0021-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E6%A6%82%E5%BF%B5/"/>
    <id>YobeZhou.github.io/2019/06/03/0021-进程之概念/</id>
    <published>2019-06-03T00:51:52.000Z</published>
    <updated>2019-06-04T01:37:40.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。这些资源在创建进程或执行进程时得以分配。<br>&emsp;&emsp;进程是大多数系统的工作单元。这种操作系统包含一组进程：操作系统进程执行系统代码，而用户进程执行用户代码。所有这些进程可以并发执行。<br>&emsp;&emsp;操作系统负责进程和线程管理的多个方面：用户进程与系统进程的创建与删除，进程调度，用于进程同步、进程通信与进程死锁处理的机制等。</p><h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>&emsp;&emsp;一个程序文件（program），只是一堆待执行的代码和部分待处理的数据，他们只有被加载到内存中，然后让CPU逐条执行其代码，并根据代码做出相应的动作，才能形成一个真正“活动”、动态的进程（process），因此进程时一个动态变化的过程，是一出有始有终的戏，而程序文件只是这一系列动作的原始蓝本，是一个静态的剧本。</p><p><img src="/images/operating-system/process/01_Process-in-Memory.png" alt="内存中的进程"></p><center>图2-1 进程的内存结构</center>&emsp;&emsp;进程是执行的程序。进程不只是程序代码，进程代码有时称为“文本段（text section）”（或“代码段（code section）”）。&emsp;&emsp;进程还包括：* 进程堆栈（stack）：包括临时数据，如函数参数、返回地址和局部变量。* 数据段（data section）：包括全局变量* 堆（heap）：可能包括堆，这是在进程运行时动态分配的内存。> 进程还包括当前活动，如程序计数器（program）的值和处理器寄存器的内容等。<h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>&emsp;&emsp;进程在执行时会改变状态。进程的状态，部分取决于进程的当前活动。每个进程都有可能处于以下状态的某种状态：</p><ul><li>新的（new）：进程正在创建；</li><li>运行（running）：指令正在执行；</li><li>等待（waiting）：进程正在等待发生某个时间（如I/O完成或受到信号）；</li><li>就绪（ready）：进程等待分配处理器；</li><li>终止（terminated）：进程已经完成执行。</li></ul><p><img src="/images/operating-system/process/02_Diagram-of-Process-State.png" alt="进程状态"></p><center>图3-1 进程状态图</center>> 一次只有一个进程可在处理器上运行（running）；但是可多个进程处于就绪（ready）或者等待（waiting）状态。<h1 id="程序与进程的关系"><a href="#程序与进程的关系" class="headerlink" title="程序与进程的关系"></a>程序与进程的关系</h1><p>&emsp;&emsp;程序本身不是进程。程序是被动（passive）实体，如存储在磁盘上包含一系列指令的文件（我们常称之为“可执行文件”（executable file））。相反，进程是活动（active）实体，具有一个程序计数器用于表示可执行命令和一组相关资源。当一个可执行文件被加载到内存时，这个程序就成为进程。</p><blockquote><p>加载可执行文件通常由两种方法：双击一个代表可执行文件的图标或在命令行上输入可执行文件的名称（如prog.exe或a.out）。</p></blockquote><p><img src="/images/operating-system/process/03_program-and-process.png" alt="程序与进程"></p><center>图4-1 程序与进程的关系</center>&emsp;&emsp;虽然多个进程可以与同一个程序相关联，但是实际上每个都是单独的执行序列。比如，多个用户可以运行电子邮件的不同副本，或者同意用户可以调用Web浏览器程序的多个副本。每个副本（进程）都是单独运行的；虽然文本段相同，但是数据、堆、及堆栈却不同。进程在运行时也经常会生成许多进程（子进程）。# 进程控制块&emsp;&emsp;操作系统内的每个进程表示，都采用进程控制块表示（Process Control Block），也称任务控制块（task control block）。当可执行程序被进行时，内核中实际上产生了一个叫"task_struct{}"的结构体来表示这个进程，进程是一个“活动的实体”，这个活动的实体从一开始诞生就需要各种各样的资源以便于生存下去，而这些信息都被记录在"task_struct"结构体之中，这个结构体被常常称之为进程控制块（PCB，即Process Control Block）。进程控制块包括：* 进程状态：状态可以包括由新的、就绪、运行、等待、停止等。* 程序计数器：计数器表示进程将要执行的下个指令的地址。* CPU寄存器：根据计算机体系的不同寄存器的类型和数量也会不同。他们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件吗信息寄存器。在发生中断时，这些状态信息与程序计数器一起需要保存，一边进程以后能正确地继续执行。* CPU调度信息：这类信息包括进程优先级、调度队列地指针和气压调度参数。* 内存管理信息：根据操作系统使用的内核系统，这类信息可以包括及地址和界限寄存器的值、页表或段表。* 记账信息：这类信息包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开文件列表等。&emsp;&emsp;简而言之，PCB简单地作为这些信息的仓库，这些信息也会随着进程的不同而不同。<p><img src="/images/operating-system/process/04_Process-Control-Block-(PCB).png" alt="进程控制块"></p><center>图5-1 进程控制块</center><p><img src="/images/operating-system/process/05_CPU-Switch-From-Process-to-Process.png" alt="进程间的CPU切换"></p><center>图5-2 进程间的CPU切换</center><h1 id="Linux的进程表示"><a href="#Linux的进程表示" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;Linux操作系统的进程控制块采用C语言结构体 task_struct 来表示，它位于Linux内核源代码目录内的头文件&lt;linux/sched.h&gt;。这个结构体包含用于表示进程的所有必要信息，包括进程的状态、调度和内存管理信息、打开文件列表、指向父进程的指针及指向子进程和兄弟进程列表的指针等。（父进程（parent process）为创建他的进程，子进程（child process）为它本身创建的进程，兄弟进程（sibling process）为具有同一父进程的进程。）<br>这些成员包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pid t pid;                  <span class="comment">/* process identifier */</span> </span><br><span class="line"><span class="keyword">long</span> state;                 <span class="comment">/* state of the process */</span> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> time slice     <span class="comment">/* scheduling information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* this process’s parent */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">head</span> <span class="title">children</span>;</span>  <span class="comment">/* this process’s children */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files</span> <span class="title">struct</span> *<span class="title">files</span>;</span> <span class="comment">/* list of open files */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span> <span class="title">struct</span> *<span class="title">mm</span>;</span>       <span class="comment">/* address space of this process */</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，进程状态是由这个结构的成员 long state 来表示的。在Linux内核中，所有活动进程的表示都采用task_struct 的双向链表。内核采用一个指针即 current，用于指向当前系统正在执行的进车.</p><p><img src="/images/operating-system/process/06_task-struct-double-linuxked-list.png" alt="task_struct双向链表"></p><center>图6-1 task_struct双向链表</center><h1 id="Linux的进程表示-1"><a href="#Linux的进程表示-1" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;下面举例说明，内核如何修改某个特定进程的 task_struct 的成员，假设系统需要将当前运行状态改成值 new_state。如果current 为指向当前运行进程的指针，那么可以这样改变状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state = new_state;</span><br></pre></td></tr></table></figure><blockquote><p>Linux内核代码纷繁复杂，千万头绪，这个结构体是系统进程在执行过程中所有设计的方方面面的缩影，因此以这个所谓的进程控制块（PCB）为切入点，是研究内核的一个很好的窗口。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程是可执行的程序。随着进程的执行，它会改变状态。<br>&emsp;&emsp;程序本身不是进程。程序只是被动实体，进程是活动实体，当一个可执行文件被加载到内存时，这个程序就成为进程。进程状态是由进程当前活动定义的。<br>&emsp;&emsp;每个进程都可以处于如下状态的某一种：新的、就绪、运行、等待或终止。<br>&emsp;&emsp;在操作系统中，每个进程通过它的进程控制块（PCB）来表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="YobeZhou.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解Makefile及典型的Makefile示例</title>
    <link href="YobeZhou.github.io/2019/04/27/0020-%E7%90%86%E8%A7%A3Makefile%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%9A%84Makefile%E7%A4%BA%E4%BE%8B/"/>
    <id>YobeZhou.github.io/2019/04/27/0020-理解Makefile及典型的Makefile示例/</id>
    <published>2019-04-27T13:56:48.000Z</published>
    <updated>2019-04-27T15:08:09.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考<a href="http://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">GNU Make Manual</a></p><h1 id="Makefile到底是什么"><a href="#Makefile到底是什么" class="headerlink" title="Makefile到底是什么"></a>Makefile到底是什么</h1><p>&emsp;&emsp;一个正式的软件工程中源文件可能数不胜数，并且源文件按类型、功能、模块等分别放在不同的目录下，在我们使用使用keil, Visual Studio, avr等工具开发程序时点点鼠标就可以编译了，但是对于其中的内部机制是什么？是怎么组织管理程序的？怎么决定编译哪一个文件？我们一概不知，因为IDE帮我们屏蔽了这方面的细节，让我们得以安心的投入到编码中。但是如果真要我们手工处理的话，那么我们每次都在命令行执行例如这样的指令： gcc a.c b.c c.c -o test ，显然是非常影响效率的！而Makefile是我们可以信赖的好伙伴，它定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br>&emsp;&emsp;综上所述，Makefile 就是一个用来帮助我们编译的工具，和 Windows 下的 IDE 类似，只不过 Makefile 需要我们自己动手编写，一个好的 Makefile 可以极大的提升工作的效率。</p><h1 id="Makefile的核心—规则"><a href="#Makefile的核心—规则" class="headerlink" title="Makefile的核心—规则"></a>Makefile的核心—规则</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################</span></span><br><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">目标 : 依赖1 依赖2 ...</span><br><span class="line">[TAB]命令</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br></pre></td></tr></table></figure><ul><li>target 就是我们编译文件要生成的目标;</li><li>prerequisites 就是我们编译文件需要的依赖;</li><li>command 就是用依赖生成目标所需要执行的命令（注意需用tab开始）。</li></ul><blockquote><p>当”目标文件”[不存在], 或某个依赖文件比目标文件[“新”],则: 执行”命令”</p></blockquote><p>&emsp;&emsp;比如我们平时使用的 gcc a.c b.c -o test<br>&emsp;&emsp;这里的 test 就是我们要生成的目标， a.c 就是我们生成目标需要的依赖，而 gcc a.c -o test 则是命令。将这行命令用 Makefile 的方式来写就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:a.c b.c</span></span><br><span class="line">    gcc a.c b.c -o test</span><br></pre></td></tr></table></figure><blockquote><p>再次强调：Makefile 中的命令必须用 tab 开始，不能是空格。</p></blockquote><p>&emsp;&emsp;Makefile 可以自动推导文件以及文件依赖关系后面的命令，在后面的示例中我们可以看到目标的依赖基本都是 .o 文件而不是 .c 文件，原因正是 Makefile 强大的自动推导功能。<br>&emsp;&emsp;通常 Makefile 中还会有一个名为 clean 的目标，用来清除编译后产生的各种文件。一般情况下 Makefile 会根据依赖和目标的新旧来决定是否编译，但是如果不小心修改了目标而造成目标比依赖新的情况的话，Makefile 会因为目标比依赖新而忽略这个目标下的命令，这个时候显然会造成问题，一个解决的办法就是使用 clean 这样的目标来清除编译后的文件，然后 make 重新编译。<br>&emsp;&emsp;clean 这个目标有点特殊，他是不需要依赖的，因此也叫伪目标。一般使用方式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br></pre></td></tr></table></figure><h1 id="Makefile-使用"><a href="#Makefile-使用" class="headerlink" title="Makefile 使用"></a>Makefile 使用</h1><p>&emsp;&emsp;make 命令执行时，需要一个 Makefile 文件(文件名为 Makefile 、 makefile 、 *.mk )，以告诉 make 命令需要怎么样的去编译和链接程序。执行时只用在命令行输入 make ， Makefile 就会自动执行第一个目标下的命令。而是否执行命令则取决于依赖，如果没有目标文件或是目标后的依赖文件比目标文件新，Makefile 就会执行其下面的命令：</p><ul><li>Makefile 中使用 # 注释,只注释 # 后的一行。</li><li>Makefile 中引用其他 Makefile，用 include 指令来引用。引用的效果就是原地展开。</li><li>Makefile 命令前面加 @ 来静默执行，即执行命令时不打印命令本身。</li></ul><h1 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h1><h2 id="Makefile-变量"><a href="#Makefile-变量" class="headerlink" title="Makefile 变量"></a>Makefile 变量</h2><p>&emsp;&emsp;Makefile 中的变量和 shell 脚本中非常相似，都是直接定义，不需要类型，引用时用 $(var) 。<br>&emsp;&emsp;伪目标（ .PHONY ）：伪目标形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。</p><h2 id="Makefile-中的几种变量赋值运算符"><a href="#Makefile-中的几种变量赋值运算符" class="headerlink" title="Makefile 中的几种变量赋值运算符"></a>Makefile 中的几种变量赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">延时变量赋值，可以被赋值为变量的值，解析时取这个变量最后的值。</td></tr><tr><td align="center">:=</td><td align="left">即时变量赋值，被赋值为变量时解析为变量在这行语句时的值，即变量如果后面改变这里的值也不改变。</td></tr><tr><td align="center">?=</td><td align="left">延时变量赋值, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句。</td></tr><tr><td align="center">+=</td><td align="left">附加, 它是即时变量还是延时变量取决于前面的定义。</td></tr></tbody></table><blockquote><p>关于 = 和 := ，比如 B=$(A)bcd ，那么 B 的值取决于变量 A 最后一次被赋值的值，即使 A 在 B 之后再次被赋值，变量 B 仍然会随着 A 的改变而改变。而 := 则只看之前 A 最后被赋值的值。</p></blockquote><p>&emsp;&emsp;即时变量也叫简单变量，即时变量与延时变量的理解示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := xxx   <span class="comment"># A的值即刻确定，在定义时即确定</span></span><br><span class="line">B  = xxx   <span class="comment"># B的值使用到时才确定</span></span><br></pre></td></tr></table></figure><h2 id="Makefile-中的自动变量"><a href="#Makefile-中的自动变量" class="headerlink" title="Makefile 中的自动变量"></a>Makefile 中的自动变量</h2><p>&emsp;&emsp;自动变量是 Makefile 中提前预定义的特殊意义的符号，类似 C 语言中的宏 <strong>__</strong>LINE__ 等，提前被定义并被赋予了特殊含义。</p><table><thead><tr><th align="center">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">$@</td><td align="left">目标文件名，比如上文的 test 。</td></tr><tr><td align="center">$&lt;</td><td align="left">第一个依赖文件名，如果依赖目标是以模式（即“ % “）定义的，那么” $&lt; “将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</td></tr><tr><td align="center">$^</td><td align="left">依赖的文件集合，比如上文的 a.c b.c 。</td></tr></tbody></table><p>&emsp;&emsp;此外还可以向 Makefile 传参， $# 存放传递参数个数， $1 存放第一个参数的字符串， $2 存放第二个参数的字符串……</p><h2 id="Makefile-的环境变量"><a href="#Makefile-的环境变量" class="headerlink" title="Makefile 的环境变量"></a>Makefile 的环境变量</h2><ul><li>Makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。</li><li>环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>&emsp;&emsp;通配符：比如在当前文件夹下有 1.c 2.c 12.c test.c 1.h 。</p><table><thead><tr><th align="center">通配符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">%</td><td align="left">若干个任意字符，和 * 很相似，但是 % 一般只用于规则描述中，又叫做规则通配符。</td></tr><tr><td align="center">*</td><td align="left">若干个任意字符 *.c 匹配 1.c 2.c 12.c test.c 。</td></tr><tr><td align="center">?</td><td align="left">1个任意字符 ?.c 匹配 1.c 2.c 。</td></tr><tr><td align="center">[]</td><td align="left">将 [] 中的字符依次去和外面的结合匹配 [12].c 匹配 1.c 2.c 。</td></tr><tr><td align="center">$@</td><td align="left">表示目标</td></tr><tr><td align="center">$&lt;</td><td align="left">表示第1个依赖文件</td></tr><tr><td align="center">$^</td><td align="left">表示所有依赖文件</td></tr></tbody></table><p>&emsp;&emsp;Makefile 与 shell 脚本非常相似，shell 脚本中能使用的 Makefile 也能使用，比如 awk 等工具。</p><h2 id="Makefile-的函数"><a href="#Makefile-的函数" class="headerlink" title="Makefile 的函数"></a>Makefile 的函数</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern...,text)</span>      <span class="comment"># 在text中取出符合patten格式的值</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern...,text)</span>  <span class="comment"># 在text中取出不符合patten格式的值</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span>            <span class="comment"># pattern定义了文件名的格式,</span></span><br><span class="line">                               <span class="comment"># wildcard取出其中存在的文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,<span class="variable">$(var)</span>)</span>  <span class="comment"># 从列表中取出每一个值</span></span><br><span class="line">                                        <span class="comment"># 如果符合pattern</span></span><br><span class="line"><span class="comment"># 则替换为replacement</span></span><br></pre></td></tr></table></figure><h1 id="Makefile-典型示例"><a href="#Makefile-典型示例" class="headerlink" title="Makefile 典型示例"></a>Makefile 典型示例</h1><p>&emsp;&emsp;请移步我的<a href="https://github.com/YobeZhou/Example-For-Makefile" target="_blank" rel="noopener">GitHub仓库</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="Linux" scheme="YobeZhou.github.io/tags/Linux/"/>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
  <entry>
    <title>什么是BootLoader？</title>
    <link href="YobeZhou.github.io/2019/04/21/0019-%E4%BB%80%E4%B9%88%E6%98%AFBootloader%EF%BC%9F/"/>
    <id>YobeZhou.github.io/2019/04/21/0019-什么是Bootloader？/</id>
    <published>2019-04-21T01:15:32.000Z</published>
    <updated>2019-04-27T15:08:37.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoader 可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。<br>&emsp;&emsp;Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。对于嵌入式系统，Bootloader是基于特定硬件平台来实现的。因此，几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。<br>&emsp;&emsp;在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p><h1 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h1><ul><li>自启动模式：在这种模式下，bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。</li><li>交互模式：在这种模式下，目标机上的bootloader将通过串口或网络等通行手段从开发主机（Host）上下载内核映像等到RAM中。可以被bootloader写到目标机上的固态存储媒质中，或者直接进入系统的引导。也可以通过串口接收用户的命令。</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><p>&emsp;&emsp;Bootloader启动大多数都分为两个阶段。第一阶段主要包含依赖于CPU的体系结构硬件初始化的代码，通常都用汇编语言来实现。这个阶段的任务有：<br>    1. 基本的硬件设备初始化（屏蔽所有的中断、关闭处理器内部指令/数据Cache等）。<br>    2. 为第二阶段准备RAM空间。<br>    3. 如果是从某个固态存储媒质中，则复制Bootloader的第二阶段代码到RAM。<br>    4. 设置堆栈。<br>    5. 跳转到第二阶段的C程序入口点。</p><p>&emsp;&emsp;第二阶段通常用C语言完成，以便实现更复杂的功能，也使程序有更好的可读性和可移植性。这个阶段的任务有：<br>    1. 初始化本阶段要使用到的硬件设备。<br>    2. 检测系统内存映射。<br>    3. 将内核映像和根文件系统映像从Flash读到RAM。<br>    4. 为内核设置启动参数。<br>    5. 调用内核。</p><blockquote><p>在第一阶段中为什么要关闭Cache？通常使用Cache以及写缓冲是为了提高系统性能，但由于Cache的使用可能改变访问主存的数量、类型和时间，因此Bootloader通常是不需要的。</p></blockquote><h1 id="常见的Bootloader"><a href="#常见的Bootloader" class="headerlink" title="常见的Bootloader"></a>常见的Bootloader</h1><p>BootLoader可以是U-Boot\Eboot\vivi等待其他一切方式。BootLoader是所有boot的总称。</p><h2 id="ARMboot"><a href="#ARMboot" class="headerlink" title="ARMboot"></a>ARMboot</h2><p>&emsp;&emsp;ARMboot是一个ARM平台的开源固件项目，它特别基于PPCBoot，一个为PowerPC平台上的系统提供类似功能的姊妹项目。鉴于对PPCBoot的严重依赖性，已经与PPCBoot项目合并，新的项目为U-Boot。<br>&emsp;&emsp;ARMboot发布的最后版本为ARMboot-1.1.0，2002年ARMboot终止了维护。</p><h2 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h2><p>&emsp;&emsp;U-Boot是由开源项目PPCBoot发展起来的，ARMboot并入了PPCBoot，和其他一些arch的Loader合称U-Boot。2002年12月17日第一个版本U-Boot-0.2.0发布，同时PPCBoot和ARMboot停止维护。<br>&emsp;&emsp;U-Boot支持的处理器构架包括PowerPC (MPC5xx，MPC8xx，MPC82xx，MPC7xx，MPC74xx，4xx)， ARM （ARM7，ARM9，StrongARM，Xscale），MIPS (4Kc，5Kc)，x86等等， U-Boot（Universal Bootloader）从名字就可以看出，它是在GPL下资源代码最完整的一个通用Boot Loader。<br>&emsp;&emsp;U-Boot提供两种操作模式：启动加载（Boot loading）模式和下载（Downloading）模式,并具有大型Boot Loader的全部功能。<br>&emsp;&emsp;U-Boot的功能是如此之强大，涵盖了绝大部分处理器构架，提供大量外设驱动，支持多个文件系统，附带调试、脚本、引导等工具，特别支持Linux,为板级移植做了大量的工作。U-Boot1.1.1版本特别包含了对SA1100和44B0芯片的移植，所以44B0移植主要是针对Board 的移植，包括FLASH、内存配置以及串口波特率等等。U-Boot的完整功能性和后续不断的支持，使系统的升级维护变得十分方便。</p><h2 id="Eboot"><a href="#Eboot" class="headerlink" title="Eboot"></a>Eboot</h2><p>&emsp;&emsp;是使用网口的意思，是微软提供的一般是wince下的bootloader，但是经过修改也可以兼容运行在其他OS下，如linux。如果直接说eboot也是bootloader”这样说不够严谨，对于基于norflash的bootloader来说是对的，如果bootloader是从nandflash开始执行就不对了，但我们所说的bootloader=nboot+eboot，其中nboot负责把eboot加载到SDRAM指定的内存处，然后运行eboot，接着eboot会把NK加载到SDRAM中并且执行。</p><h2 id="vivi"><a href="#vivi" class="headerlink" title="vivi"></a>vivi</h2><p>&emsp;&emsp;vivi是韩国mizi 公司开发的bootloader, 适用于ARM9处理器。Vivi有两种工作模式：启动加载模式和下载模式。启动加载模式可以在一段时间后（这个时间可更改）自行启动linux内核，这是vivi的默认模式。在下载模式下，vivi为用户提供一个命令行接口，通过接口可以使用vivi提供的一些命令</p><h2 id="Redboot"><a href="#Redboot" class="headerlink" title="Redboot"></a>Redboot</h2><p>&emsp;&emsp;Redboot是Redhat公司随eCos发布的一个BOOT方案，是一个开源项目。<br>&emsp;&emsp;Redboot支持的处理器构架有ARM，MIPS，MN10300，PowerPC， Renesas SHx，v850，x86等，是一个完善的嵌入式系统Boot Loader。<br>&emsp;&emsp;Redboot是在ECOS的基础上剥离出来的，继承了ECOS的简洁、轻巧、可灵活配置、稳定可靠等品质优点。它可以使用X-modem或Y-modem协议经由串口下载，也可以经由以太网口通过BOOTP/DHCP服务获得IP参数，使用TFTP方式下载程序映像文件，常用于调试支持和系统初始化（Flash下载更新和网络启动）。Redboot可以通过串口和以太网口与GDB进行通信，调试应用程序，甚至能中断被GDB运行的应用程序。Redboot为管理FLASH映像，映像下载，Redboot配置以及其他如串口、以太网口提供了一个交互式命令行接口，自动启动后，REDBOOT用来从TFTP服务器或者从Flash下载映像文件加载系统的引导脚本文件保存在Flash上。<br>&emsp;&emsp;Redboot是标准的嵌入式调试和引导解决方案，支持几乎所有的处理器构架以及大量的外围硬件接口，并且还在不断地完善过程中。</p><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>&emsp;&emsp;Blob(Boot Loader Object)是由Jan-Derk Bakker and Erik Mouw发布的，是专门为StrongARM 构架下的LART设计的Boot Loader。<br>&emsp;&emsp;Blob也提供两种工作模式，在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 Blob 切换到下载模式。如果在 10 秒内没有用户按键，则 Blob 继续启动 Linux内核。<br>&emsp;&emsp;Blob功能比较齐全，代码较少，比较适合做修改移植，用来引导Liunx，目前大部分S3C44B0板都用Blob修改移植后来加载uClinux。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoade
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
  <entry>
    <title>文件描述符、文件指针和文件偏移量之甄别</title>
    <link href="YobeZhou.github.io/2019/04/18/0018-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E5%92%8C%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%8B%E7%94%84%E5%88%AB/"/>
    <id>YobeZhou.github.io/2019/04/18/0018-文件描述符、文件指针和文件偏移量之甄别/</id>
    <published>2019-04-18T07:14:34.000Z</published>
    <updated>2019-04-27T15:09:48.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在 C 程序中,文件由文件指针或者文件描述符表示。</p><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>&emsp;&emsp;在 linux 系统中打开文件就会获得文件描述符，它是个很小的正整数。每个进程在 PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，也就是说每一个文件描述符都是一个问文件的索引，当然也可以出现多个不同的文件描述符索引同一个文件。<br>Linux标准文件描述符:</p><table><thead><tr><th align="left">文件描述符</th><th align="center">缩写</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="center">STDIN</td><td align="center">标准输入</td></tr><tr><td align="left">1</td><td align="center">STDOUT</td><td align="center">标准输出</td></tr><tr><td align="left">2</td><td align="center">STDERR</td><td align="center">标准错误输出</td></tr></tbody></table><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>&emsp;&emsp;C语言中使用文件指针做为 I/O 的句柄。文件指针指向进程用户区中的一个被称为 FILE 结构的数据结构。 FILE 结构包括一个缓冲区和一个文件描述符。而文件描述符是文件描述符表的一个索引，因此从某种意义上说文件指针就是句柄的句柄（在 Windows 系统上，文件描述符被称作文件句柄）。</p><h1 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h1><p>&emsp;&emsp;每个打开的文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在 C 程序中,文件由文件指针或者文件描述符表示。&lt;/p&gt;
&lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux下.so、.ko、.a、.o文件的区别</title>
    <link href="YobeZhou.github.io/2019/04/16/0017-Linux%E4%B8%8B-so%E3%80%81-ko%E3%80%81-a%E3%80%81.o%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>YobeZhou.github.io/2019/04/16/0017-Linux下-so、-ko、-a、.o文件的区别/</id>
    <published>2019-04-16T14:02:36.000Z</published>
    <updated>2019-06-03T05:56:14.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;&emsp;&emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是linux/unix的哲学核心思想。这句话中的“文件”不仅仅是我们通常所指的文件，在linux和unix中它代表的更为宽泛。目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”。然而有些文件对于在嵌入式Linux中是比较值得注意的，那就是.so、.ko、.a文件，我们可能会在有意或无意间遇到过，若是初次见面它们很容易就把我们迷惑了，下面概要的说明下这几者的区别。</p><h1 id="so文件"><a href="#so文件" class="headerlink" title=".so文件"></a>.so文件</h1><p>&emsp;&emsp;&emsp;&emsp;.so(share object)文件是用户层的动态链接库，相当于Windows的.dll文件，用于用户层的动态链接使用，内核态的代码同样不能直接访问。</p><h1 id="ko文件"><a href="#ko文件" class="headerlink" title=".ko文件"></a>.ko文件</h1><p>&emsp;&emsp;&emsp;&emsp;.ko(kernel object)文件是内核态的动态链接库，用于内核态的动态链接使用，可以用于内核之间的模块相互调用。用户态的代码不可直接调用内核态的代码，但是可以通过其他方式进行通信。</p><h1 id="a文件"><a href="#a文件" class="headerlink" title=".a文件"></a>.a文件</h1><p>&emsp;&emsp;&emsp;&emsp;.a文件是用于静态链接时，使用的静态库。</p><h1 id="o文件"><a href="#o文件" class="headerlink" title=".o文件"></a>.o文件</h1><p>&emsp;&emsp;&emsp;&emsp;.o文件是目标文件，编译生成,相当于windows中的.obj文件。.a文件就是由.o文件打包生成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;在Linux开发或学习过程中，相信大家都听过一句话叫作“Linux下，一切皆文件”。这句话是
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="嵌入式" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="Linux" scheme="YobeZhou.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>什么是操作系统？</title>
    <link href="YobeZhou.github.io/2019/04/08/0016-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
    <id>YobeZhou.github.io/2019/04/08/0016-什么是操作系统？/</id>
    <published>2019-04-08T14:04:54.000Z</published>
    <updated>2019-06-04T01:31:28.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。<br>&emsp;&emsp;操作系统是管理计算机硬件的软件。硬件必须提供适当机制，以确保计算机系统的正确运行并且防止用户程序干扰系统的正常运行。<br>&emsp;&emsp;操作系统可以采用许多不同的组织方式，因此内部结构也有很大差异。设计新的操作系统的任务是艰巨的。在设计开始之前，明确界定设计系统的目标是非常重要的。这些目标是选择不回算法和策略的基础。<br>&emsp;&emsp;操作系统既庞大又复杂，因此应分块构造。每块都应具有描述明确的系统部分，并且具有严格定义的输入、输出和功能。</p><blockquote><p>有一个重点我们是必须get住的，那就是：操作系统（operating system）是管理计算机硬件的程序。也就是说操作系统是只是一个管理、控制的程序，它为其他应用程序提供基础，并且从当计算机用户和计算机硬件的中介，所以我们平时所作的所有操作都是在操作系统这个程序下进行的。</p></blockquote><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>&emsp;&emsp;操作系统的存在是因为其提供了合理的方式来解决创建可用计算系统的问题，计算机系统的根本目的是，执行用户程序帮助用户解决实际问题。<br>&emsp;&emsp;操作系统是一直运行在计算机上的程序（通常称为内核（kernel））。除了内核外还有其他两类程序：系统程序（system program）和应用程序。前者是与系统运行息息相关的程序（其保证着系统的正常运作），但不是内核的一部分，后者是与系统运行无关的其他应用程序（可以理解为用户程序）。</p><h1 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h1><p>&emsp;&emsp;计算机操作系统可粗分了四个组件：硬件、操作系统、应用程序和用户。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A7%86%E5%9B%BE.png" alt="计算机系统组件的抽象视图"></p><center>计算机系统组件的抽象视图</center><ul><li>硬件（hardware）为我们的系统提供基本的计算资源；</li><li>应用程序规定了用户为解决计算问题而使用硬件资源的方式；</li><li>而操作系统决定应用程序使用资源的方式和权限。</li></ul><p>至此，计算机系统也可分为硬件、软件和数据，当计算机系统运行时，操作系统提供正确的手段来让这些资源得到合理的利用。</p><blockquote><p>正如刚才强调的，至此，我们可以更形象的将操作系统理解为：操作系统类似于政府，其本身不能实现任何有用的功能，而是为其他程序的执行提供一个合理安全的环境。</p></blockquote><h2 id="用户视角"><a href="#用户视角" class="headerlink" title="用户视角"></a>用户视角</h2><p>&emsp;&emsp;计算机的用户视角因使用界面的不同而不同。<br>&emsp;&emsp;大多数的计算机用户的都是普通用户，即PC又显示器、键盘、鼠标和主机。这样的计算机是为了让单个用户单独使用资源，目的是优化用户进行的工作（或娱乐）。因此在对于这类群体，操作系统的设计的主要目的是为了用户的使用便利，而次要的是性能，不在乎资源的共享和利用。当然其中也包括我们程序员这一群体。<br>&emsp;&emsp;接着就是服务器了，对于这个视角的用户面对的是与大型机或小型机相连的终端前。这类系统的设计目标是优化资源的利用效率，确保所有的CPU时间、内存和I/O都能得到有效的使用，并且确保没有用户使用操作限制以外的资源。<br>&emsp;&emsp;与我们日常工作接触的是这样一种情况，我们处于工作站内，这类工作站与其他工作站和服务器相连。这时我们作为用户不仅可以使用专用资源，而且可以使用网络和服务器的共享资源，如：文件，计算和打印服务等。这类的操作系统的设计便是上述两种情况的折中方案，即考虑资源利用率与便利性。</p><h2 id="系统视角"><a href="#系统视角" class="headerlink" title="系统视角"></a>系统视角</h2><p>&emsp;&emsp;从计算机的是视角来看，操作系统是与硬件紧密相连的程序。因此，可将操作系统看作资源分配器。操作系统管理着（如：CPU时间、内存空间、文件存储空间、I/O设备等）这些资源，当面对许多甚至冲突的资源请求时，操作系统应该考虑如何为各个程序和用户分配资源，以便计算机能有效且公平地运行。</p><blockquote><p>说到资源请求，此时操作系统是一个控制程序，它特别注重I/O设备的运行和控制，其管理着用户程序的执行，以防止计算机资源的错误或不当使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷而且高效地执行程序。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="操作系统" scheme="YobeZhou.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）</title>
    <link href="YobeZhou.github.io/2019/04/07/0015-Arduino%E6%8E%A7%E5%88%B6ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89/"/>
    <id>YobeZhou.github.io/2019/04/07/0015-Arduino控制ULN2003驱动模块驱动五线四相八拍步进电机（28BYJ8）/</id>
    <published>2019-04-07T12:22:08.000Z</published>
    <updated>2019-06-04T01:29:40.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的控制需要有精确到微秒级PWM；然而Linux系统很繁忙，最多只能达到毫秒级别的控制，所以对于安装了基于ARM架构的Debian的树莓派达不到我们要求的精确控制。由此自然联想到了使用单片机进行辅助控制，而其中使用Arduino最为简单，因此最终选择Arduino作为项目的辅助控制外设模块。</p><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>&emsp;&emsp;本文实现了对五线四相八拍步进电机（28BYJ8）的较为精确的控制，同时加入了EEPROM记录的功能，在运行过程中能记录步进电机目前的位置，在意外掉电重启后能定位自身所处角度并恢复到设定的位置。</p><h2 id="硬件模块"><a href="#硬件模块" class="headerlink" title="硬件模块"></a>硬件模块</h2><p>&emsp;&emsp;步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲：当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。我们可以通过控制脉冲个来控制角位移量，从而达到准确定位的目的；同时亦可通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。</p><p>&emsp;&emsp;步进电机28BYJ48型四相八拍电机，电压为DC5V—DC12V。当对步进电机施加一系列连续不断的控制脉冲时，它可以连续不断地转动。每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的通电方式有单（单相绕组通电）四拍（A-B-C-D-A…），双（双相绕组通电）四拍（AB-BC-CD-DA-AB-…），八拍（A-AB-B-BC-C-CD-D-DA-A…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uchar code CCW[<span class="number">8</span>]=&#123;<span class="number">0x08</span>,<span class="number">0x0c</span>,<span class="number">0x04</span>,<span class="number">0x06</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x09</span>&#125;;   <span class="comment">//逆时钟旋转相序表</span></span><br><span class="line">uchar code CW[<span class="number">8</span>]=&#123;<span class="number">0x09</span>,<span class="number">0x01</span>,<span class="number">0x03</span>,<span class="number">0x02</span>,<span class="number">0x06</span>,<span class="number">0x04</span>,<span class="number">0x0c</span>,<span class="number">0x08</span>&#125;;    <span class="comment">//正时钟旋转相序表</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;五线四相八拍步进电机（28BYJ8）：<br><img src="/images/%E4%BA%94%E7%BA%BF%E5%9B%9B%E7%9B%B8%E5%85%AB%E6%8B%8D%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%EF%BC%8828BYJ8%EF%BC%89.jpg" alt="五线四相八拍步进电机（28BYJ8）"><br><cneter>五线四相八拍步进电机（28BYJ8）</cneter></p><p>&emsp;&emsp;ULN2003驱动模块：<br><img src="/images/ULN2003%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97.jpg" alt="ULN2003驱动模块"></p><center>ULN2003驱动模块</center><p>&emsp;&emsp;全局概览：<br><img src="/images/IMG_3450.JPG" alt="全局概览"></p><center>全局概览</center><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>&emsp;&emsp;详细代码及更多内容请参考我在<a href="https://github.com/YobeZhou/Stepper-28BYJ48" target="_blank" rel="noopener">GitHub仓库</a>中的项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近做的一个项目涉及对步进电机的控制，一开始时打算在树莓派中直接控制驱动步进电机，但是由于需要达到对步进电机最精确的
      
    
    </summary>
    
      <category term="Arduino" scheme="YobeZhou.github.io/categories/Arduino/"/>
    
    
      <category term="Arduino" scheme="YobeZhou.github.io/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题</title>
    <link href="YobeZhou.github.io/2019/04/06/0014-Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3TensorFlow%E4%B8%AD%E7%9A%84OpenCV%E8%A7%86%E9%A2%91%E6%B5%81%E8%AF%BB%E5%8F%96%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <id>YobeZhou.github.io/2019/04/06/0014-Python多进程解决TensorFlow中的OpenCV视频流读取延迟问题/</id>
    <published>2019-04-06T15:25:45.000Z</published>
    <updated>2019-05-30T13:11:09.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的 read() 函数时发现其数据处理与数据产生的速度跟不上而导致延迟非常高，甚至内存溢出，因此开始思考解决措施。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval, image = cv.VideoCapture.read([, image])</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是因为OpenCV读取视频流时，数据处理程序需要消耗的CPU时间过于长（不同硬件配置情况不可一概而论），而VideoCapture的read是按帧队列读取且先进先出，最后导致视频帧数据产生的速度与读取、处理速度不平衡，所以出现了上面所说的问题。<br>由此联想到我们可以试图将需要读取视频数据和处理视频数据的过程分开处理，从而解决延迟问题。</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;我们可以使用多进程或多线程将读取视频数据和处理视频数据的过程分开处理，但是由于实时视频处理属于CPU密集型任务，多线程的优势发挥不出来，因此我们选择多进程方式。</p><h2 id="所用到的库"><a href="#所用到的库" class="headerlink" title="所用到的库"></a>所用到的库</h2><p>&emsp;&emsp;实现多进程所用到的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两个子进程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write()</span><br><span class="line">read()</span><br></pre></td></tr></table></figure><h2 id="在两个子进程中传递参数"><a href="#在两个子进程中传递参数" class="headerlink" title="在两个子进程中传递参数"></a>在两个子进程中传递参数</h2><ul><li>multiprocessing中有Quaue、SimpleQuaue等进程间传参类，以及Manager统领全局。</li><li>使用Manager我们可以在进程键传递字典、列表灯Python原生数据类型</li><li>Quaue时严格的数据结构队列类型</li></ul><h2 id="在读取进程中得到最新的视频帧数据"><a href="#在读取进程中得到最新的视频帧数据" class="headerlink" title="在读取进程中得到最新的视频帧数据"></a>在读取进程中得到最新的视频帧数据</h2><ul><li>首先 VideoCapture 是队列，先进先出。因此我们需要将其转换为压栈存储视频帧数据，才能达到后进先出而获取最新的视频帧数据，因此不能使用Quaue来传递参数。</li><li>为了达到压栈的效果，我们可以使用Python的列表，其append与pop操作可以达到模拟压栈的效果。因此，我们可以使用 multiprocessing.Manager.list 进行进程间传参类型最为理想不过。</li></ul><h2 id="清理传参栈"><a href="#清理传参栈" class="headerlink" title="清理传参栈"></a>清理传参栈</h2><p>&emsp;&emsp;由于压栈频率肯定是要比出栈频率高的，时间一长就会在栈中积累大量无法出栈的视频帧，会导致程序崩溃，因此我们需要考虑传参栈自动清理的问题，我们需要一个自动清理的机制：</p><ul><li>我们可以设定传参栈的容量，每当达到这个容量时就直接把栈清空，再利用gc库手动发起一次python垃圾回收，这样就不会导致严重的内存溢出和程序崩溃。</li></ul><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>&emsp;&emsp;综上所述，实际上这个程序就是把VideoCapture的队列读取改成了栈读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">__author__ = <span class="string">'YobeZhou'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"><span class="comment">#File name: object_detection.py</span></span><br><span class="line"><span class="comment">#   Author: YobeZhou</span></span><br><span class="line"><span class="comment">#     Date: 2018/12/12</span></span><br><span class="line"><span class="comment">#########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"><span class="comment">#import pdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import utilites</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br><span class="line"></span><br><span class="line">process_result = <span class="string">'ok'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向共享缓冲栈中写入数据:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(stack, cam, top: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param cam: 摄像头参数</span></span><br><span class="line"><span class="string">    :param stack: Manager.list对象</span></span><br><span class="line"><span class="string">    :param top: 缓冲栈容量</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line"></span><br><span class="line">    video = cv2.VideoCapture(cam)</span><br><span class="line">    ret = video.set(<span class="number">3</span>,<span class="number">1280</span>)</span><br><span class="line">    ret = video.set(<span class="number">4</span>,<span class="number">720</span>)</span><br><span class="line"></span><br><span class="line">    retval = video.get(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (cam)</span><br><span class="line">    print(retval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(video.isOpened()):</span><br><span class="line">        ret, img = video.read()</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            stack.append(img)</span><br><span class="line">            <span class="comment"># 每到一定容量清空一次缓冲栈</span></span><br><span class="line">            <span class="comment"># 利用gc库，手动清理内存垃圾，防止内存溢出</span></span><br><span class="line">            <span class="keyword">if</span> len(stack) &gt;= top:</span><br><span class="line">                <span class="keyword">del</span> stack[:]</span><br><span class="line">                gc.collect()</span><br><span class="line">        <span class="comment"># Press 'q' to quit</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"Write process has safely exited..."</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Clean up</span></span><br><span class="line">    video.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment"># read进程的子线程，用以监听接收socket通信数据包</span></span><br><span class="line"><span class="comment"># 这是从 threading.Thread 继承创建一个新的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threadID, newSocket, data)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.newSocket = newSocket</span><br><span class="line">        self.data = data</span><br><span class="line">        self.cmd = <span class="string">'o'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> (self.cmd == <span class="string">'q'</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.data = self.newSocket.recv(<span class="number">4</span>)</span><br><span class="line">            <span class="comment">#print (self.data)</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Receiving data thread has safely exited..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在缓冲栈中读取数据:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(stack)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#DST_IP = '192.168.1.106'</span></span><br><span class="line">    DST_IP = <span class="string">'10.3.141.1'</span></span><br><span class="line">    DST_PORT = <span class="number">8666</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 包含正在使用的对象检测模块的目录的名称</span></span><br><span class="line">    MODEL_NAME = <span class="string">'inference_graph'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抓取当前工作目录的路径</span></span><br><span class="line">    CWD_PATH = os.getcwd()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 冻结检测图.pb文件的路径，其中包含用于对象检测的模型</span></span><br><span class="line">    PATH_TO_CKPT = os.path.join(CWD_PATH,MODEL_NAME,<span class="string">'frozen_inference_graph.pb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标签映射文件的路径</span></span><br><span class="line">    PATH_TO_LABELS = os.path.join(CWD_PATH,<span class="string">'training'</span>,<span class="string">'labelmap.pbtxt'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明对象检测器可以识别的类数</span></span><br><span class="line">    NUM_CLASSES = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载标签</span></span><br><span class="line">    label_map = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line">    categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=<span class="literal">True</span>)</span><br><span class="line">    category_index = label_map_util.create_category_index(categories)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将Tensorflow模型加载到内存中</span></span><br><span class="line">    detection_graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">        od_graph_def = tf.GraphDef()</span><br><span class="line">        <span class="keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</span><br><span class="line">            serialized_graph = fid.read()</span><br><span class="line">            od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">            tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">        sess = tf.Session(graph=detection_graph)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入张量是图像</span></span><br><span class="line">    image_tensor = detection_graph.get_tensor_by_name(<span class="string">'image_tensor:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出张量是检测框，分数和类</span></span><br><span class="line">    <span class="comment"># 每个框表示检测到特定对象的图像的一部分</span></span><br><span class="line">    detection_boxes = detection_graph.get_tensor_by_name(<span class="string">'detection_boxes:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个分数代表每个对象的置信水平</span></span><br><span class="line">    <span class="comment"># 分数与结果图像一起显示在结果图像上</span></span><br><span class="line">    detection_scores = detection_graph.get_tensor_by_name(<span class="string">'detection_scores:0'</span>)</span><br><span class="line">    detection_classes = detection_graph.get_tensor_by_name(<span class="string">'detection_classes:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测到的对象数量</span></span><br><span class="line">    num_detections = detection_graph.get_tensor_by_name(<span class="string">'num_detections:0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立Socket，SOCK_STREAM表示Socket类型为TCP</span></span><br><span class="line">    print(<span class="string">"Starting socket: TCP..."</span>)</span><br><span class="line">    socket_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#在客户端开启心跳维护</span></span><br><span class="line">    socket_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>)</span><br><span class="line">    socket_tcp.connect((DST_IP, DST_PORT))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建新线程</span></span><br><span class="line">    thread1 = myThread(<span class="number">1</span>, socket_tcp, <span class="string">'ok'</span>)</span><br><span class="line">    <span class="comment"># 启动新线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#socket_tcp.send(bytes("Tensorflow ok!",encoding="utf-8"))</span></span><br><span class="line">    socket_tcp.send(<span class="string">b'Tensorflow ok!'</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">if</span> len(stack) != <span class="number">0</span>: </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取框架并扩展框架尺寸以具有形状：[1，无，无，3]</span></span><br><span class="line">            <span class="comment"># 即单列阵列，其中列中的每个项目具有像素RGB值</span></span><br><span class="line">            frame = stack.pop()</span><br><span class="line"></span><br><span class="line">            frame_expanded = np.expand_dims(frame, axis=<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 通过以图像作为输入运行模型来执行实际检测</span></span><br><span class="line">            (boxes, scores, classes, num) = sess.run(</span><br><span class="line">                [detection_boxes, detection_scores, detection_classes, num_detections],</span><br><span class="line">                feed_dict=&#123;image_tensor: frame_expanded&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绘制检测结果（也称为“可视化结果”）</span></span><br><span class="line">            <span class="comment"># 可视化图像阵列上的框和标签</span></span><br><span class="line">            image,tablename = vis_util.my_visualize_boxes_and_labels_on_image_array(</span><br><span class="line">                frame,</span><br><span class="line">                np.squeeze(boxes),</span><br><span class="line">                np.squeeze(classes).astype(np.int32),</span><br><span class="line">                np.squeeze(scores),</span><br><span class="line">                category_index,</span><br><span class="line">                use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">                line_thickness=<span class="number">8</span>,</span><br><span class="line">                min_score_thresh=<span class="number">0.60</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 将结果绘制在框架上并显示出来。</span></span><br><span class="line">            cv2.imshow(<span class="string">'Object detector V1.0 Author:Yobe Zhou'</span>, frame)</span><br><span class="line">            </span><br><span class="line">            datar = thread1.data</span><br><span class="line">            <span class="keyword">print</span> (datar)</span><br><span class="line">            <span class="keyword">if</span> (datar == <span class="string">b'ok'</span>):</span><br><span class="line">                <span class="keyword">print</span> (tablename)</span><br><span class="line">                <span class="keyword">if</span> tablename == <span class="string">"metal"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'metal'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"plastic"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'plastic'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"paper"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'paper'</span>)</span><br><span class="line">                <span class="keyword">elif</span> tablename == <span class="string">"peel"</span>:</span><br><span class="line">                    socket_tcp.sendall(<span class="string">b'peel'</span>)</span><br><span class="line">            <span class="comment"># 按'q'退出</span></span><br><span class="line">            <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>) :</span><br><span class="line">                socket_tcp.sendall(<span class="string">b'exit'</span>)</span><br><span class="line">                thread1.cmd = <span class="string">'q'</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Clean up</span></span><br><span class="line">    thread1.join()</span><br><span class="line">    socket_tcp.close()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Read process has safely exited..."</span>)            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    print(tf.__version__)</span><br><span class="line"></span><br><span class="line">    sys.path.append(<span class="string">".."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize webcam feed (Raspberry)</span></span><br><span class="line">    url = <span class="string">'http://10.3.141.1:8081/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 父进程创建缓冲栈，并传给各个子进程：</span></span><br><span class="line">    q = Manager().list()</span><br><span class="line">    pw = Process(target=write, args=(q, url, <span class="number">100</span>))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程结束</span></span><br><span class="line">    pw.join()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"End of program!"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近在做的一个项目涉及到TensoFlow。然而在使用TensorFlow做物体分类识别时，发现其调用的读取视频帧的
      
    
    </summary>
    
      <category term="TensorFlow" scheme="YobeZhou.github.io/categories/TensorFlow/"/>
    
    
      <category term="Python" scheme="YobeZhou.github.io/tags/Python/"/>
    
      <category term="TensorFlow" scheme="YobeZhou.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Qt串口读取连贯数据</title>
    <link href="YobeZhou.github.io/2019/04/05/0013-Qt%E4%B8%B2%E5%8F%A3%E8%AF%BB%E5%8F%96%E8%BF%9E%E8%B4%AF%E6%95%B0%E6%8D%AE/"/>
    <id>YobeZhou.github.io/2019/04/05/0013-Qt串口读取连贯数据/</id>
    <published>2019-04-05T00:45:58.000Z</published>
    <updated>2019-04-27T15:09:48.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Qt的“信号与槽”机制极大的便利了内部事件的处理，但是在接收串口数据时我们利用到Qt的这一机制，却发现接收到的数据往往是不连贯的，这是由于当有数据到来时便立即触发读取操作，串口数据发送亦然，借此我们的程序能够及时处理串口中的数据。然而由于串口传输速率以及延迟问题，此时如果没有对接收到的串口数据做缓冲处理，最终导致我们接收到的数据呈现出来的将是断断续续的状态。<br>因此下面的笔记为Qt中加了缓冲区的串口读取操作。</p><h2 id="串口缓冲区读取操作"><a href="#串口缓冲区读取操作" class="headerlink" title="串口缓冲区读取操作"></a>串口缓冲区读取操作</h2><figure class="highlight qt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建静态全局变量，用以串口读取缓冲区 */</span></span><br><span class="line">static QByreArry s_serialDataBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*！</span></span><br><span class="line"><span class="comment">  * \rief Qt串口数据读取</span></span><br><span class="line"><span class="comment">  * \param 无输入参数</span></span><br><span class="line"><span class="comment">  * \return 无返回值</span></span><br><span class="line"><span class="comment">  * \attention 仅作参考</span></span><br><span class="line"><span class="comment">  * \author Yobe Zhou</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="attribute">MainWindow</span>::readSerialData()</span><br><span class="line">&#123;</span><br><span class="line">    QString readData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取串口数据，当串口有数据到来时马上读取 */</span></span><br><span class="line">    <span class="keyword">const</span> QByreArry bufferData = m_serial-&gt;readAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将读取到数据追加到缓冲区 */</span></span><br><span class="line">    s_serialDataBuf.append(bufferData);</span><br><span class="line">    <span class="comment">/* 追加数据直到缓冲区有至少一条目标语句 */</span></span><br><span class="line">    <span class="keyword">if</span> (s_serialBuffer.contains(<span class="string">'B'</span>)) &amp;&amp; (s_serialDataBuf.contains(<span class="string">'\n'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        QString tempString;</span><br><span class="line">        QList&lt;QByteArry&gt; lineList;</span><br><span class="line">        <span class="built_in">int</span> listCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tempString = s_serialDataBuf;</span><br><span class="line">        <span class="comment">/* 根据字头标识分割各条语句 */</span></span><br><span class="line">        lineList = s_serialDataBuf.split(<span class="string">'B'</span>);</span><br><span class="line">        <span class="comment">/* 清空缓冲区用以下一轮接收 */</span></span><br><span class="line">        s_serialDataBuf.clear();</span><br><span class="line">        <span class="comment">/* 确定有多少目标语句 */</span></span><br><span class="line">        listCount = lineList.count();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理分割后的每条语句 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; listCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            readData = lineList.at(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 当出现语句不完整（断句） */</span></span><br><span class="line">            <span class="keyword">if</span> (!(readData.contains(<span class="string">'\n'</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 当前处理语句为待处理语句的最后一句（有效断句） */</span></span><br><span class="line">                <span class="keyword">if</span> (i == listCount - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 为断句补充标识 */</span></span><br><span class="line">                    s_serialDataBUf.append(<span class="string">'B'</span>);</span><br><span class="line">                    <span class="comment">/* 保存断句（存入清空后的缓冲区），承接下一轮接收 */</span></span><br><span class="line">                    s_serialDataBuf.append(readData);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 不是有效断句，直接跳过 */</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 语句中包含标识字符1 */</span></span><br><span class="line">            <span class="keyword">if</span> (readData.contains(<span class="string">"Target character2"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* code */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 语句中包含标识字符2 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (readData.contains(<span class="string">"Target character"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* code */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*....*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* code */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Qt的“信号与槽”机制极大的便利了内部事件的处理，但是在接收串口数据时我们利用到Qt的这一机制，却发现接收到的数据往
      
    
    </summary>
    
      <category term="Qt" scheme="YobeZhou.github.io/categories/Qt/"/>
    
    
      <category term="C++" scheme="YobeZhou.github.io/tags/C/"/>
    
      <category term="Qt" scheme="YobeZhou.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>标准库函数与运算符的区别</title>
    <link href="YobeZhou.github.io/2019/04/01/0012-%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>YobeZhou.github.io/2019/04/01/0012-标准库函数与运算符的区别/</id>
    <published>2019-04-01T02:26:52.000Z</published>
    <updated>2019-04-27T15:09:48.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。下面来看他们的区别。</p><h1 id="标准库函数与运算符的区别"><a href="#标准库函数与运算符的区别" class="headerlink" title="标准库函数与运算符的区别"></a>标准库函数与运算符的区别</h1><h2 id="一、操作对象有所不同"><a href="#一、操作对象有所不同" class="headerlink" title="一、操作对象有所不同"></a>一、操作对象有所不同</h2><p>&emsp;&emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。</p><p>&emsp;&emsp;对象在创建的同时要自动执行构造函数，对象消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。</p><p>&emsp;&emsp;运算符是语言自身的特性，它有固定的语义，而且编译器也知道意味着什么。就像 +-*/ 一样，由编译器解释语义，生成相应的代码。 库函数是依赖于库的，没有库就没有它，也就是一定程度上独立于语言的。理论上，编译器不知道也不关心函数的作用，编译器只保证编译函数，以及调用该函数时参数和返回值符合语法，并生成相应 call 函数的代码。但实际中一些高级点的编译器，都会对标准库自带的一些函数进行特别处理。</p><h2 id="二、在用法上也有所不同"><a href="#二、在用法上也有所不同" class="headerlink" title="二、在用法上也有所不同"></a>二、在用法上也有所不同</h2><p>&emsp;&emsp;函数malloc的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用malloc 申请一块长度为length 的整数类型的内存，程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。</p><ol><li>malloc返回值的类型是void *，所以在调用malloc时要显示地进行类型转换，将void * 转换成所需要的指针类型。</li><li>mallo函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。</li></ol><p>&emsp;&emsp;函数free的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">( <span class="keyword">void</span> * memblock )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>为什么free 函数不象malloc 函数那样复杂呢？</strong><br>&emsp;&emsp;这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。</p><h1 id="new-delete的使用要点"><a href="#new-delete的使用要点" class="headerlink" title="new/delete的使用要点"></a>new/delete的使用要点</h1><p>&emsp;&emsp;运算符new使用起来要比函数malloc简单得多，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);  </span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。</p><p>&emsp;&emsp;如果new创建对象数组，那么只能使用对象的无参构造函数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>]; <span class="comment">// 创建100 个动态对象</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不能写成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>](<span class="number">1</span>);<span class="comment">// 创建100 个动态对象的同时赋初值1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在用delete 释放对象数组时，留意不要丢了符号‘[ ]’。例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法  </span></span><br><span class="line"><span class="keyword">delete</span> objects; <span class="comment">// 错误的用法</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后者相当于<strong>delete objects[0]</strong>，漏掉了另外99个对象。</p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><ol><li><p>new自动计算需要分配的空间，而malloc需要手工计算字节数</p></li><li><p>new是类型安全的，而malloc不是，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">// 编译时指出错误  </span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>)); <span class="comment">// 编译时无法指出错误</span></span><br></pre></td></tr></table></figure><p> <em>new operator 由两步构成，分别是 operator new 和 construct（构造）</em></p></li><li><p>operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力</p></li><li><p>new将调用constructor（构造函数），而malloc不能；delete将调用destructor（析构函数），而free不能。</p></li><li><p>malloc/free要库文件支持，new/delete不要。</p></li></ol><h2 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h2><p>&emsp;&emsp;malloc/free是c/C++语言的标准库函数，new/delete是C++的运算符。<br>&emsp;&emsp;对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span> :  </span><br><span class="line">    Obj( ) &#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;  </span><br><span class="line">    ~ Obj( ) &#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">( )</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; <span class="built_in">endl</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">( )</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; <span class="built_in">endl</span>; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseMallocFree</span><span class="params">( )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Obj * a = (Obj * ) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span> ( Obj ) ); <span class="comment">// allocate memory   </span></span><br><span class="line">    a -&gt; Initialize(); <span class="comment">// initialization  </span></span><br><span class="line">    <span class="comment">// …   </span></span><br><span class="line">    a -&gt; Destroy(); <span class="comment">// deconstruction   </span></span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">// release memory  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseNewDelete</span><span class="params">( <span class="keyword">void</span> )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Obj * a = <span class="keyword">new</span> Obj;   </span><br><span class="line">    <span class="comment">// …   </span></span><br><span class="line">    <span class="keyword">delete</span> a;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类Obj的函数Initialize实现了构造函数的功能，函数Destroy实现了析构函数的功能。函数UseMallocFree中，由于 malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成“构造”与“析构”。（注意：即malloc不会执行对象的构造函数，free不会执行对象的析构函数，而new会自动执行构造函数，delete会自动执行析构函数）。<br>&emsp;&emsp;所以我们不要用 malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言 malloc/free和new/delete是等价的。</p><h2 id="两者的联系"><a href="#两者的联系" class="headerlink" title="两者的联系"></a>两者的联系</h2><p>&emsp;&emsp;既然new/delete的功能完全覆盖了malloc /free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用 free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete，malloc/free必须配对使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和
      
    
    </summary>
    
      <category term="C/C++" scheme="YobeZhou.github.io/categories/C-C/"/>
    
    
      <category term="C" scheme="YobeZhou.github.io/tags/C/"/>
    
      <category term="C++" scheme="YobeZhou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客主页文章展示实用设置</title>
    <link href="YobeZhou.github.io/2019/03/31/0011-Hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E6%96%87%E7%AB%A0%E5%B1%95%E7%A4%BA%E5%AE%9E%E7%94%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>YobeZhou.github.io/2019/03/31/0011-Hexo博客主页文章展示实用设置/</id>
    <published>2019-03-31T14:26:30.000Z</published>
    <updated>2019-07-04T11:30:16.178Z</updated>
    
    <content type="html"><![CDATA[<p>调整主页文章展示间距，最后添加</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-tags</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br></pre></td></tr></table></figure><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-button</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-base;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$grey</span>-dim;</span><br><span class="line">    <span class="attribute">background</span>: none;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="variable">$grey</span>-dim;</span><br><span class="line">    <span class="attribute">transition-property</span>: border;</span><br><span class="line"></span><br><span class="line">    +mobile() &#123; <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-small; &#125;</span><br><span class="line">    +desktop-large() &#123; <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-large; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123; <span class="attribute">border-bottom-color</span>: <span class="variable">$black</span>-deep; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-tags</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br></pre></td></tr></table></figure><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-button</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-base;</span><br><span class="line">    <span class="attribute">color</span>: Red;  <span class="comment">// http://cc.oulu.fi/~thu/jwz/Colours/545454.html</span></span><br><span class="line">    <span class="attribute">background</span>: none;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid Red;</span><br><span class="line">    <span class="attribute">transition-property</span>: border;</span><br><span class="line"></span><br><span class="line">    +mobile() &#123; <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-small; &#125;</span><br><span class="line">    +desktop-large() &#123; <span class="attribute">font-size</span>: <span class="variable">$font</span>-size-large; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123; <span class="attribute">border-bottom-color</span>: <span class="variable">$black</span>-deep; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调整主页文章展示间距，最后添加&lt;/p&gt;
&lt;figure class=&quot;highlight styl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="Hexo" scheme="YobeZhou.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="YobeZhou.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>内存的三种地址及其转换</title>
    <link href="YobeZhou.github.io/2019/03/31/0010-%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>YobeZhou.github.io/2019/03/31/0010-内存的三种地址及其转换/</id>
    <published>2019-03-31T13:09:11.000Z</published>
    <updated>2019-04-27T15:10:46.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址（以80x86微处理器为例）：</p><ul><li>逻辑地址（logical address）：机器语言指令中用来指定一个操作数或者一条指令的地址，每一个逻辑地址由一个段和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。</li><li>线性地址（linear address 也叫做虚拟地址 virtual address）：是一个 32 位无符号整数，可以用来表达 4GB 的地址，通常用十六进制数表示。</li><li>物理地址（physical address）：用于内存芯片内的内存单元寻址，它们从微处理器的地址引脚发送到内存总线上的电信号对应。</li></ul><p><em>以上内容来自 《Understanding The Linux Kernel》</em></p><p>内存管理单元（Memory Management Unit, MMU）通过分段单元的把一个逻辑地址转换成线性地址，通过分页单元把线性地址转换成物理地址。</p><h1 id="三种内存地址"><a href="#三种内存地址" class="headerlink" title="三种内存地址"></a>三种内存地址</h1><h2 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h2><p>&emsp;&emsp;包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在 80X86 著名的分段结构中表现得尤为具体，它促使 MS-DOS 或 Windows 程序员把程序分成若干段。每一个逻辑地址都是有一个段和偏移量组成，偏移量指明了从段开始的地方到时间地址之间的距离。</p><h2 id="线性地址（虚拟地址）"><a href="#线性地址（虚拟地址）" class="headerlink" title="线性地址（虚拟地址）"></a>线性地址（虚拟地址）</h2><p>&emsp;&emsp;是一个32位无符号整数，可以用来表示高达4GB的地址，也就是高达4294967296个内存单元。线性地址通常用十六进制数字表示。</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>&emsp;&emsp;用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。</p><p>&emsp;&emsp;内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址</p><h1 id="分段与分页机制"><a href="#分段与分页机制" class="headerlink" title="分段与分页机制"></a>分段与分页机制</h1><p>&emsp;&emsp;从 80286 开始，Intel 处理器以两种不同的方式执行地址转换，分别为实模式（real mode）和保护模式（protected mode）。下面我们就展开描述，在保护模式下，硬件的分段机制和分页机制</p><h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>&emsp;&emsp;段选择符和段寄存器<br>&emsp;&emsp;逻辑地址有两部分组成：一个段标识符和一个偏移量。短标识符是一个 16 位的字段，成为段选择符；偏移量是一个 32 位长的字段。<br>&emsp;&emsp;为了快速找到段选择符，处理器提供了段寄存器用来存放段选择符，分别为 cs，ss，ds，es，fs，gs。<br>&emsp;&emsp;其中有三个有专门的用途：</p><ul><li>cs：代码段寄存器，指向包含程序指令的段</li><li>ss：栈段寄存器，指向包含当前程序栈的段</li><li>ds：数据段寄存器，指向包含静态数据或者全局数据段<br>&emsp;&emsp;其中，cs 含有一个两位的字段，用来指明当前的 CPU 特权等级（CPL），0 代表最高等级、3 代表最低等级。 Linux 只用到了 0 和 3，分别称为 内核态 和 用户态</li></ul><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>&emsp;&emsp;每个段由一个 8 字节的段描述符表示，描述了段的基本信息。段描述符放在全局描述符表（GDT）或者局部描述符表（LDT）中。<br>&emsp;&emsp;通常只会定义一个 GDT，每个进程除了放在 GDT 中的段以外，如还需要创建附加的段，就可以有自己的 LDT。GDT 在主存中的地址和大小存放在 gdtr 控制寄存器中，LDT 的地址和大小则存放在 ldtr 中。<br>&emsp;&emsp;段描述符包涵以下关键字段：</p><p>|Base| 包含段的首字节的线性地址<br>|Type| 描述了段的类型特征和它的存取权限<br>|DPL| 限制对这个段的存取权限，表示访问这个段的要求的最小 CPU 特权等级<br>|P| Segment-Present 标志，表明当前段是否在内存中。Linux 总是把这个标志设为 1，从来不会把整个段交换到磁盘上去</p><h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>&emsp;&emsp;那么逻辑地址是如何转换到线性地址的呢？</p><ol><li>先检查段选择符的TI字段，已决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址）</li><li>从段选择符的index字段计算段描述符的地址，index字段的值乘以8，这个结果与gdtr或ldtr寄存器的内容相加</li><li>把逻辑地址的偏移量与段描述符base字段的值相加就得到了线性地址</li></ol><p>&emsp;&emsp;第二个称为分页单元的硬件电路把线性地址转化成一个物理地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">       分段单元       分页单元</span><br><span class="line">逻辑地址 ----&gt; 线性地址 ----&gt; 物理地址</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，分段和分页在某种程度上有点多余，因为它们都可以划分进程的物理地址空间：分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间，与分段相比，Linux更喜欢使用分页方式。因为当所有进程使用相同的段寄存器值时，内存管理变得更简单，也就是说它们能共享同样的一组线性地址。Linux设计目标之一是可以把它移植到绝大多数流行的处理器平台上。然而，RISC体系结构对分段的支持很有限。<br>在多处理系统中，所有与CPU都共享同一内存；这意味着RAM芯片可以由独立的CPU并发访问。因为在RAM芯片上的读或写操作必须串行的执行。因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间，作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含有一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。 在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如：双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。</p><p>&emsp;&emsp;仲裁器由硬件电路管理，是隐藏的。</p><h3 id="快速访问分段机制"><a href="#快速访问分段机制" class="headerlink" title="快速访问分段机制"></a>快速访问分段机制</h3><p>&emsp;&emsp;如果每次都执行上述的过程，可能会比较耗时，因为 GDT 是存储在主存中的，每次都访问主存，可能会比较慢，所以为了提高逻辑地址到线性地址的转换速度，80x86 处理器提供了一组6个不可编程寄存器。每一个不可编程寄存器含有 8 个字节的段描述符，具体的值由相对应的段寄存器中的段描述符确定。每当一个段选择符被装入段寄存器，相对应的段描述符就由主存装入到对应的不可编程寄存器，这样就可以不需要上面三个过程中的前两个，就可以得到线性地址了。</p><h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><h3 id="页、页框和页表"><a href="#页、页框和页表" class="headerlink" title="页、页框和页表"></a>页、页框和页表</h3><p>&emsp;&emsp;分页单元把线性地址转换成物理地址，其中的关键任务是把所请求的访问类型与线性地址的访问权限做对比。</p><ul><li>页：为了更高效和更经济的管理内存，线性地址被分为以固定长度为单位的组，成为页。页内部连续的线性地址空间被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和对应的存取权限，而不用指定全部线性地址的存取权限。这里说页，同时指一组线性地址以及这组地址包含的数据</li><li>页框：分页单元把所有的 RAM 分成固定长度的页框，每一个页框包含一个页。页框是主存的一部分，因此也是一个存储区域。页和页框相比，前者只是一个数据块，可以存放在页框或者磁盘中。</li><li>页表：把线性地址映射到物理地址的数据结构成为页表，页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化</li></ul><h3 id="常规的分页"><a href="#常规的分页" class="headerlink" title="常规的分页"></a>常规的分页</h3><p>&emsp;&emsp;从 80386 开始，Intel 处理器的页大小为 4KB。<br>&emsp;&emsp;32 位的线性地址被分为 3 个域：</p><ul><li>Directory（目录）：最高 10 位</li><li>Table（页表）：中间 10 位</li><li>Offset（偏移量）：最低 12 位<br>&emsp;&emsp;线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表成为页目录表，第二种转换表成为页表。</li></ul><p>&emsp;&emsp;为什么需要两级呢？目的在于减少每个进程页表所需的 RAM 的数量。如果使用简单的一级页表，将需要高达 2^20 个表项来表示每个进程的页表，即时一个进程并不使用所有的地址，二级模式通过职位进程实际使用的那些虚拟内存区请求页表来减少内存容量。每个活动的进程必须有一个页目录，但是却没有必要马上为所有进程的所有页表都分配 RAM，只有在实际需要一个页表时候才给该页表分配 RAM。</p><p>&emsp;&emsp;页目录项和页表项的结构如下：</p><ul><li>Present 标志：为 1 则表示页在主存中；如果为 0 则表示不在内存中，如果执行一个地址转换的时候，所需的页表项或者页目录项中的该标志为 0，那么分页单元就把该线性地址存在在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。</li><li>包含页框物理地址最高 20 位的字段</li><li>Dirty：当对页框进行写操作时就设置这个标志</li><li>Read/Write 标志：含有页或者页表的存取权限</li><li>User/Supervisor：含有访问页或者页表所需的特权等级</li></ul><p>&emsp;&emsp;了解了以上结构之后，我们看看如何从线性地址转换到物理地址的：</p><ul><li>线性地址中的 Directory 字段决定页目录中的目录项，目录项指向适当的页表</li><li>线性地址中的 Table 字段又决定页表的页表项，页表项含有页所在页框的物理地址</li><li>线性地址中的 Offset 地段决定了页框内的相对位置，由于 offset 为 12 为，所以一页含有 4096 字节的数据</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;以上描述的为 80x86 微处理器硬件分页机制，不同架构的 64 位处理器分页机制，大体的思路就是将二级模式拓展为三级（ia64）或者四级（x86_64），以达到对更大范围寻址空间的支持。</p><h1 id="笔记：16进制线性地址转换"><a href="#笔记：16进制线性地址转换" class="headerlink" title="笔记：16进制线性地址转换"></a>笔记：16进制线性地址转换</h1><p>&emsp;&emsp;16进制的线性地址转化为地址的物理空间大小。<br>&emsp;&emsp;如：0x00000000  -  0x08000000的物理空间大小为128MB<br>    换算：0x08000000 === 134217728 (Bytes)<br>          134217728(Bytes) / 1024 = 131072(KB)<br>          131072(KB) / 1024 = 128(MB)  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;今天我们来学习一下 Linux 下的内存寻址，通常我们在谈内存地址的时候，我们在谈什么呢？所以首先我们得明确三种地址
      
    
    </summary>
    
      <category term="嵌入式" scheme="YobeZhou.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="操作系统" scheme="YobeZhou.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="嵌入式" scheme="YobeZhou.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="硬件" scheme="YobeZhou.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo提交搜索引擎收录（Google+Baidu）</title>
    <link href="YobeZhou.github.io/2019/03/31/0009-Hexo%E6%8F%90%E4%BA%A4%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%EF%BC%88Google-Baidu%EF%BC%89/"/>
    <id>YobeZhou.github.io/2019/03/31/0009-Hexo提交搜索引擎收录（Google-Baidu）/</id>
    <published>2019-03-31T03:42:24.000Z</published>
    <updated>2019-04-27T15:10:46.939Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
