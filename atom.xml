<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YobeZhou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhouyuebiao.cn/"/>
  <updated>2019-10-11T09:27:24.793Z</updated>
  <id>https://zhouyuebiao.cn/</id>
  
  <author>
    <name>YobeZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析Android-Recovery-UI的实现过程.md</title>
    <link href="https://zhouyuebiao.cn/2019/10/11/0038-%E5%88%86%E6%9E%90Android-Recovery-UI%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <id>https://zhouyuebiao.cn/2019/10/11/0038-分析Android-Recovery-UI的实现过程/</id>
    <published>2019-10-11T09:26:43.000Z</published>
    <updated>2019-10-11T09:27:24.793Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/Android_Recovery_UI.jpg" alt="Android_Recovery_UI"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;recovery作为一个简单的rootfs, 提供了非常有限的几个功能，利用 boottable/recovery下的minui库作为基础，采用直接刷framebuffer的形式绘制显示UI。<br>&emsp;&emsp;在recovery的源码中，跟ui显示相关的代码主要有： </p><ol><li>定义并实现几个类，如ScreenRecoveryUI，ScreenRecoveryUI、RecoveryUI，这几个类由抽象到具体一层层继承下来，在recovery.cpp的main中实例化并被使用</li><li>将minui库里resources.cpp，graphics.cpp提供的基本api封装到几个方法中，这几个方法在类中基本被按功能划分，单独负责一个ui单元的显示，如draw_background_locked、draw_battery_locked、draw_logo_locked、update_progress_locked、draw_progressbar_locked、draw_state_locked等,之后再将这些方法进一步按照设计需求组合，实现了一些完成更多功能的方法，如SetBackground，ShowProgress</li><li>boottable/recovery/minui下的resources.cpp，graphics.cpp其中resources.cpp提供的api主要用于图片资源的读取和加载，graphics.cpp负责具体完成各类ui的绘制</li><li>recovery下面根据分辨率不同保存的图片资源，如boottable/recovery/res-xxhdpi等</li></ol><p>&emsp;&emsp;以Android P原生代码作为分析材料，对Recovery模式下各类UI资源被加载并显示的过程来做具体分析：<br>&emsp;&emsp;recovery的UI实现的大部分实现细节放在了screen_ui.cpp等文件中，在recovery的main中，主要是要完成ui的显示。</p><h1 id="recovery-cpp-main-function"><a href="#recovery-cpp-main-function" class="headerlink" title="recovery.cpp main function"></a>recovery.cpp main function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recovery.cpp */</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv) &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line"></span><br><span class="line">    Device* device = make_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : Device::REBOOT;</span></span><br><span class="line">    <span class="comment">// 1. If the recovery menu is visible, prompt and wait for commands.</span></span><br><span class="line">    <span class="comment">// 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into</span></span><br><span class="line">    <span class="comment">//    recovery to sideload a package.)</span></span><br><span class="line">    <span class="comment">// 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device</span></span><br><span class="line">    <span class="comment">//    without waiting.</span></span><br><span class="line">    <span class="comment">// 4. In all other cases, reboot the device. Therefore, normal users will observe the device</span></span><br><span class="line">    <span class="comment">//    reboot after it shows the "error" screen for 5s.</span></span><br><span class="line">    <span class="keyword">if</span> (just_exit) &#123;</span><br><span class="line">            after = Device::REBOOT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((status == INSTALL_NONE) &amp;&amp; !sideload_auto_reboot) || ui-&gt;IsTextVisible()) &#123;</span><br><span class="line">        Device::BuiltinAction temp = prompt_and_wait(device, status);</span><br><span class="line">        <span class="keyword">if</span> (temp != Device::NO_ACTION) &#123;</span><br><span class="line">        after = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Reocvery的main函数代码中UI相关的语句中的工作很简单：首先新建了一个Device类的对象， Device类封装了一些操作，包括UI的操作。</p><h1 id="device-h-Device-class"><a href="#device-h-Device-class" class="headerlink" title="device.h Device class"></a>device.h Device class</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* device.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    explicit Device(RecoveryUI* ui) : ui_(ui) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Device() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called to obtain the UI object that should be used to display the recovery user interface for</span></span><br><span class="line">    <span class="comment">// this device. You should not have called Init() on the UI object already, the caller will do</span></span><br><span class="line">    <span class="comment">// that after this method returns.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> RecoveryUI* <span class="title">GetUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ui_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ..... */</span></span><br><span class="line">    <span class="comment">// The device-specific library must define this function (or the default one will be used, if there</span></span><br><span class="line">    <span class="comment">// is no device-specific library). It returns the Device object that recovery should use.</span></span><br><span class="line">    <span class="function">Device* <span class="title">make_device</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;make_device()函数的说明在device.h中有提及。</p><h1 id="三个类的继承关系"><a href="#三个类的继承关系" class="headerlink" title="三个类的继承关系"></a>三个类的继承关系</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./ui.h(RecoveryUI)-&gt;./screen_ui.h(ScreenRecoveryUI)-&gt;./device.h(DefaultUI) */</span></span><br><span class="line">./ui.h</span><br><span class="line">    RecoveryUI</span><br><span class="line">        ./screen_ui.h</span><br><span class="line">            ScreenRecoveryUI</span><br><span class="line">                ./device.h</span><br><span class="line">                    DefaultUI</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用Device类的GetUI()返回一个DefaultUI对象，recovery中涉及到三个UI类，三个类之间为继承关系，分别为DefaultUI、ScreenRecoveryUI、RecoveryUI</p><h1 id="screen-ui-cpp-Init-function"><a href="#screen-ui-cpp-Init-function" class="headerlink" title="screen_ui.cpp Init function"></a>screen_ui.cpp Init function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="comment">/* ..... */</span></span><br><span class="line"><span class="keyword">bool</span> ScreenRecoveryUI::Init(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; locale) &#123;</span><br><span class="line">  RecoveryUI::Init(locale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!InitTextParams()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Are we portrait or landscape?</span></span><br><span class="line">  layout_ = (gr_fb_width() &gt; gr_fb_height()) ? LANDSCAPE : PORTRAIT;</span><br><span class="line">  <span class="comment">// Are we the large variant of our base layout?</span></span><br><span class="line">  <span class="keyword">if</span> (gr_fb_height() &gt; PixelsFromDp(<span class="number">800</span>)) ++layout_;</span><br><span class="line"></span><br><span class="line">  text_ = Alloc2d(text_rows_, text_cols_ + <span class="number">1</span>);</span><br><span class="line">  file_viewer_text_ = Alloc2d(text_rows_, text_cols_ + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  text_col_ = text_row_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the locale info.</span></span><br><span class="line">  SetLocale(locale);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"icon_error"</span>, &amp;error_icon);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"progress_empty"</span>, &amp;progressBarEmpty);</span><br><span class="line">  LoadBitmap(<span class="string">"progress_fill"</span>, &amp;progressBarFill);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"stage_empty"</span>, &amp;stageMarkerEmpty);</span><br><span class="line">  LoadBitmap(<span class="string">"stage_fill"</span>, &amp;stageMarkerFill);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Background text for "installing_update" could be "installing update"</span></span><br><span class="line">  <span class="comment">// or "installing security update". It will be set after UI init according</span></span><br><span class="line">  <span class="comment">// to commands in BCB.</span></span><br><span class="line">  installing_text = <span class="literal">nullptr</span>;</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"erasing_text"</span>, &amp;erasing_text);</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"no_command_text"</span>, &amp;no_command_text);</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"error_text"</span>, &amp;error_text);</span><br><span class="line"></span><br><span class="line">  LoadAnimation();</span><br><span class="line"></span><br><span class="line">  pthread_create(&amp;progress_thread_, <span class="literal">nullptr</span>, ProgressThreadStartRoutine, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ..... */</span></span><br></pre></td></tr></table></figure><ol><li>调用RecoveryUI的Init()，初始化输入事件处理。</li><li>InitTextParams()用于初始化图形设备和字体显示的环境。</li><li>调用DefaultUI类的Init()，由于DefaultUI类没有Init()方法，因此将调用它的父类ScreenRecoveryUI的Init()：</li><li>同理可得，调用ScreenRecoveryUI类的SetLocale()来标识几个比较特别的区域</li><li>同理可得，调用ScreenRecoveryUI类的SetBackground()设置初始状态的背景图</li><li>最后显示recovery的主界面，即平时所见的刷机界面。</li><li>LoadBitmap()  将png生成surface, 每个png图片对应一个surface, 所有surface存放在一个数组中</li><li>LoadLocalizedBitmap()  将区域文字所在的图片中的text信息根据当前的locale提取出来，生成对应的surface, 所以surface也存放在一个数组中</li><li>pthread_create(&amp;progress_t, NULL, progress_thread, NULL) 创建一个线程，该线程的任务是一个死循环，在该循环中不停地检测currentIcon以及progressBarType来决定是不是要更新进度条。</li></ol><h2 id="screen-ui-cpp-InitTextParams-function"><a href="#screen-ui-cpp-InitTextParams-function" class="headerlink" title="screen_ui.cpp InitTextParams function"></a>screen_ui.cpp InitTextParams function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="comment">/* ..... */</span></span><br><span class="line"><span class="keyword">bool</span> ScreenRecoveryUI::InitTextParams() &#123;</span><br><span class="line">  <span class="keyword">if</span> (gr_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gr_font_size(gr_sys_font(), &amp;char_width_, &amp;char_height_);</span><br><span class="line">  text_rows_ = (ScreenHeight() - kMarginHeight * <span class="number">2</span>) / char_height_;</span><br><span class="line">  text_cols_ = (ScreenWidth() - kMarginWidth * <span class="number">2</span>) / char_width_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ..... */</span></span><br></pre></td></tr></table></figure><p>&emsp;gr_init()  初始化图形设备，分配Pixelflinger库渲染的内存<br>&emsp;gr_font_size()  将字体对应的surface长宽赋值给char_width和char_height</p><h2 id="screen-ui-cpp-SetLocale-function"><a href="#screen-ui-cpp-SetLocale-function" class="headerlink" title="screen_ui.cpp SetLocale function"></a>screen_ui.cpp SetLocale function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::SetLocale(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; new_locale) &#123;</span><br><span class="line">  locale_ = new_locale;</span><br><span class="line">  rtl_locale_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!new_locale.empty()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> underscore = new_locale.find(<span class="string">'_'</span>);</span><br><span class="line">    <span class="comment">// lang has the language prefix prior to '_', or full string if '_' doesn't exist.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lang = new_locale.substr(<span class="number">0</span>, underscore);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A bit cheesy: keep an explicit list of supported RTL languages.</span></span><br><span class="line">    <span class="keyword">if</span> (lang == <span class="string">"ar"</span> ||  <span class="comment">// Arabic</span></span><br><span class="line">        lang == <span class="string">"fa"</span> ||  <span class="comment">// Persian (Farsi)</span></span><br><span class="line">        lang == <span class="string">"he"</span> ||  <span class="comment">// Hebrew (new language code)</span></span><br><span class="line">        lang == <span class="string">"iw"</span> ||  <span class="comment">// Hebrew (old language code)</span></span><br><span class="line">        lang == <span class="string">"ur"</span>) &#123;  <span class="comment">// Urdu</span></span><br><span class="line">      rtl_locale_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ScreenRecoveryUI类的SetLocale， 该函数根据locale判断所用的字体是否属于阿拉伯语系，阿拉伯语的书写习惯是从右到左，如果是阿拉伯语系的话，就设置一个标志，后面根据这个标志决定从右到左显示文字或进度条。<br>&emsp;SetLocale的参数locale赋值逻辑是这样的，先从command文件中读取, command文件中设置locale的命令如”–locale=zh_CN“，如果没有传入locale,初始化过程中会尝试从/cache/recovery/last_locale中读取locale, 如果该文件也没有，则locale不会被赋值，就默认用English。</p><h2 id="screen-ui-cpp-SetBackground-function"><a href="#screen-ui-cpp-SetBackground-function" class="headerlink" title="screen_ui.cpp SetBackground function"></a>screen_ui.cpp SetBackground function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::SetBackground(Icon icon) &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;updateMutex);</span><br><span class="line"></span><br><span class="line">  currentIcon = icon;</span><br><span class="line">  update_screen_locked();</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;updateMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update_screen_locked包含两个操作，一是更新screen, 二是切换前后buffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::update_screen_locked() &#123;</span><br><span class="line">  draw_screen_locked();</span><br><span class="line">  gr_flip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;SetBackground函数比较简洁，关键部分在update_screen_locked，下面重点分析一下:<br>&emsp;update_screen_locked和update_progress_locked是recovery的UI部分的关键函数，update_screen_locked用来更新背景, update_progress_locked用来更新进度条，因为显示的画面会一直在更新，所以这两个函数会在不同的地方被反复调用。</p><h2 id="screen-ui-cpp-draw-background-locked-function"><a href="#screen-ui-cpp-draw-background-locked-function" class="headerlink" title="screen_ui.cpp draw_background_locked function"></a>screen_ui.cpp draw_background_locked function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::draw_background_locked() &#123;</span><br><span class="line">  pagesIdentical = <span class="literal">false</span>;</span><br><span class="line">  gr_color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  gr_clear();</span><br><span class="line">  <span class="keyword">if</span> (currentIcon != NONE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_stage != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> stage_height = gr_get_height(stageMarkerEmpty);</span><br><span class="line">      <span class="keyword">int</span> stage_width = gr_get_width(stageMarkerEmpty);</span><br><span class="line">      <span class="keyword">int</span> x = (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> y = ScreenHeight() - stage_height - kMarginHeight;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_stage; ++i) &#123;</span><br><span class="line">        GRSurface* stage_surface = (i &lt; stage) ? stageMarkerFill : stageMarkerEmpty;</span><br><span class="line">        DrawSurface(stage_surface, <span class="number">0</span>, <span class="number">0</span>, stage_width, stage_height, x, y);</span><br><span class="line">        x += stage_width;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GRSurface* text_surface = GetCurrentText();</span><br><span class="line">    <span class="keyword">int</span> text_x = (ScreenWidth() - gr_get_width(text_surface)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> text_y = GetTextBaseline();</span><br><span class="line">    gr_color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    DrawTextIcon(text_x, text_y, text_surface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;draw_background_locked函数的实现代码中又出现了几个以gr_开头的函数，以gr_开头的函数来自minui库，minui库的代码在recovery源码下的minui目录下，minui提供的接口实现了图形的描绘以及固定大小的文字显示。</p><ul><li>gr_color(unsigned char r, unsigned char g, unsigned char b, unsigned char a);  /* 设置字体颜色 */  </li><li>gr_fill(int x, int y, int w, int h);  /* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */  </li><li>gr_blit(gr_surface source, int sx, int sy, int w, int h, int dx, int dy);  /* 填充由source指定的图片 */  </li></ul><p>&emsp;&emsp;draw_background_locked函数先将整个渲染buffer填充为黑色，然后计算背景surface的长宽，文字surface的长宽，再结合fb的长宽计算出背景surface以及文字surface显示的坐标，有长宽和坐标就可以调用Pixelflinger的接口在渲染buffer上进行渲染。</p><h2 id="screen-ui-cpp-update-progress-locked-function"><a href="#screen-ui-cpp-update-progress-locked-function" class="headerlink" title="screen_ui.cpp update_progress_locked function"></a>screen_ui.cpp update_progress_locked function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::update_progress_locked() &#123;</span><br><span class="line">  <span class="keyword">if</span> (show_text || !pagesIdentical) &#123;</span><br><span class="line">    draw_screen_locked();  <span class="comment">// Must redraw the whole screen</span></span><br><span class="line">    pagesIdentical = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    draw_foreground_locked();  <span class="comment">// Draw only the progress bar and overlays</span></span><br><span class="line">  &#125;</span><br><span class="line">  gr_flip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::draw_foreground_locked() &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentIcon != NONE) &#123;</span><br><span class="line">    GRSurface* frame = GetCurrentFrame();</span><br><span class="line">    <span class="keyword">int</span> frame_width = gr_get_width(frame);</span><br><span class="line">    <span class="keyword">int</span> frame_height = gr_get_height(frame);</span><br><span class="line">    <span class="keyword">int</span> frame_x = (ScreenWidth() - frame_width) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> frame_y = GetAnimationBaseline();</span><br><span class="line">    DrawSurface(frame, <span class="number">0</span>, <span class="number">0</span>, frame_width, frame_height, frame_x, frame_y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (progressBarType != EMPTY) &#123;</span><br><span class="line">    <span class="keyword">int</span> width = gr_get_width(progressBarEmpty);</span><br><span class="line">    <span class="keyword">int</span> height = gr_get_height(progressBarEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> progress_x = (ScreenWidth() - width) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> progress_y = GetProgressBaseline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Erase behind the progress bar (in case this was a progress-only update)</span></span><br><span class="line">    gr_color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    DrawFill(progress_x, progress_y, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (progressBarType == DETERMINATE) &#123;</span><br><span class="line">      <span class="keyword">float</span> p = progressScopeStart + progress * progressScopeSize;</span><br><span class="line">      <span class="keyword">int</span> pos = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(p * width);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rtl_locale_) &#123;</span><br><span class="line">        <span class="comment">// Fill the progress bar from right to left.</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarFill, width - pos, <span class="number">0</span>, pos, height, progress_x + width - pos,</span><br><span class="line">                      progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; width - <span class="number">1</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarEmpty, <span class="number">0</span>, <span class="number">0</span>, width - pos, height, progress_x, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fill the progress bar from left to right.</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarFill, <span class="number">0</span>, <span class="number">0</span>, pos, height, progress_x, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; width - <span class="number">1</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarEmpty, pos, <span class="number">0</span>, width - pos, height, progress_x + pos, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;update_progress_locked函数的原理与 update_screen_locked函数类似， 最终是将进度条的surface输出到渲染buffer,<br>&emsp;recovery中各个场景的画面，就是由背景、文字、进度条的重叠，不同的是所用的surface 以及surface的坐标。</p><p>&emsp;recovery main函数中的UI代码基本上已经分析过了，最后一点主菜单的显示，就是通过上面介绍的这些接口将文字图片显示出来，因此就不再多讲。总的来说，recovery的UI显示部分难度不大，应用层调用minui库实现了图形的描绘以及固定大小的文字显示，minui库调用了Pixelflinger库来进行渲染。</p><h1 id="minui部分接口说明"><a href="#minui部分接口说明" class="headerlink" title="minui部分接口说明"></a>minui部分接口说明</h1><p>&emsp;&emsp;仅供参考</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">/* 初始化图形显示,主要是打开设备、分配内存、初始化一些参数 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">/* 注销图形显示,关闭设备并释放内存 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_fb_width</span><span class="params">(<span class="keyword">void</span>)</span></span>;         <span class="comment">/* 获取屏幕的宽度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_fb_height</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">/* 获取屏幕的高度 */</span>  </span><br><span class="line"><span class="function">gr_pixel *<span class="title">gr_fb_data</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">/* 获取显示数据缓存的地址 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_flip</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">/* 刷新显示内容 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_fb_blank</span><span class="params">(<span class="keyword">bool</span> blank)</span></span>;  <span class="comment">/* 清屏 */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_color</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> r, <span class="keyword">unsigned</span> <span class="keyword">char</span> g, <span class="keyword">unsigned</span> <span class="keyword">char</span> b, <span class="keyword">unsigned</span> <span class="keyword">char</span> a)</span></span>;  <span class="comment">/* 设置字体颜色 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span>;  <span class="comment">/* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_text</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;  <span class="comment">/* 显示字符串 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_measure</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;             <span class="comment">/* 获取字符串在默认字库中占用的像素长度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_font_size</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;         <span class="comment">/* 获取当前字库一个字符所占的长宽 */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_blit</span><span class="params">(gr_surface source, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>;  <span class="comment">/* 填充由source指定的图片 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gr_get_width</span><span class="params">(gr_surface surface)</span></span>;   <span class="comment">/* 获取图片宽度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gr_get_height</span><span class="params">(gr_surface surface)</span></span>;  <span class="comment">/* 获取图片高度 */</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">res_create_surface</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, gr_surface* pSurface)</span></span>;  <span class="comment">/* 根据图片创建显示资源数据,name为图片在mk文件指定的相对路径 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">res_free_surface</span><span class="params">(gr_surface surface)</span></span>;       <span class="comment">/* 释放资源数据 */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/Android_Recovery_UI.jpg&quot; alt=&quot;Android_Recovery_UI&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的升级流程</title>
    <link href="https://zhouyuebiao.cn/2019/10/09/0037-Android%E7%9A%84%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://zhouyuebiao.cn/2019/10/09/0037-Android的升级流程分析/</id>
    <published>2019-10-09T07:44:13.000Z</published>
    <updated>2019-10-11T09:39:12.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/upgrade.jpg" alt="upgrade"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;以Android P原生代码作为分析材料。</p><h1 id="从Android的启动模式说起"><a href="#从Android的启动模式说起" class="headerlink" title="从Android的启动模式说起"></a>从Android的启动模式说起</h1><p>&emsp;&emsp;Android系统一般有三种启动模式：Fastboot、Recovery system、Main system。这三种启动模式对应不同的启动场景需求：</p><ul><li>Fastboot：在这种模式下，可以修改手机的硬件，并且允许我们发送一些命令给Bootloader。如使用电脑刷机，则需要进入fastboot模式，通过电脑执行命令将系统镜像刷到通过USB刷到Android设备中中。</li><li>Recovery：Recovery是一个小型的操作系统，并且会加载部分文件系统，这样才能从sdcard中读取升级包。</li><li>Main System: 即我们平时正常开机后所使用的手机操作系统模式。</li></ul><p>&emsp;&emsp;但是我们一般经常用到的是recovery system和main system这两种启动模式。下面主要区分下recovery system和main system：<br><img src="/images/Android/%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5recovery%E8%BF%98%E6%98%AFAndroid%E7%B3%BB%E7%BB%9F.png" alt="开机进入recovery还是Android系统"></p><p>&emsp;&emsp;启动经过bootloader之后，系统的启动方式有两种选择，这个选择有两个方式可以决定：一个是操作bootloader，一个是根据recovery的command文件。<br>&emsp;&emsp;上半部分是mian system（正常启动模式），下半部分为Recovery模式。正常的启动模式是从boot.img启动系统（Main System），而recovery模式则是从reovery.img启动系统；（reovery.img只包含内核、简单的文件管理系统和图形系统）</p><h1 id="升级流程之升级方式"><a href="#升级流程之升级方式" class="headerlink" title="升级流程之升级方式"></a>升级流程之升级方式</h1><h2 id="应用层ota升级流程："><a href="#应用层ota升级流程：" class="headerlink" title="应用层ota升级流程："></a>应用层ota升级流程：</h2><p>&emsp;&emsp;应用层层面的 ota升级包的下载、校验以及最后的发起安装过程：<br><img src="/images/Android/Android%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.jpg" alt="Android应用层升级流程"></p><h2 id="Recovery模式下的OTA升级流程"><a href="#Recovery模式下的OTA升级流程" class="headerlink" title="Recovery模式下的OTA升级流程"></a>Recovery模式下的OTA升级流程</h2><p>&emsp;&emsp;进入Recovery模式之后，根据相应的指令指示开始对下载的升级包进行升级，整体的流程图如下所示：<br><img src="/images/Android/Recovery%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84OTA%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.jpg" alt="Recovery模式下的OTA升级流程"></p><h1 id="升级流程之升级包"><a href="#升级流程之升级包" class="headerlink" title="升级流程之升级包"></a>升级流程之升级包</h1><h2 id="升级包的制作"><a href="#升级包的制作" class="headerlink" title="升级包的制作"></a>升级包的制作</h2><p>&emsp;&emsp;升级包是通过脚本ota_from_target_files进行制作的。（在Android SDK源码中的位置：build/make/tools/releasetools/ota_from_target_files）</p><ol><li>WriteFullOTAPackage 执行目的<ul><li>使用 edify_generator 生成升级脚本 updater-script</li><li>使用 **target-xxx.zip 中的内容生成最终的升级包<blockquote><p>整体通过ota_from_target_files脚本，进行了升级包的制作，Android是使用 make otapackage 命令进行制作，制作出升级脚本后，会连带着系统相关信息进行打包。</p></blockquote></li></ul></li></ol><h2 id="升级包的架构"><a href="#升级包的架构" class="headerlink" title="升级包的架构"></a>升级包的架构</h2><p>&emsp;&emsp;下面是升级包的基本的架构，是以hisi 3798mv300举例不同平台升级包略有不同，单架构没什么差异裸分区镜像就使用boot.img loader.bin这种方式。<br>&emsp;&emsp;META 目录下是system的权限信息和misc标记信息。<br>&emsp;&emsp;META-INF中的metadata是系统信息，我们的apk会先去校验这个文件与我们的系统是否一致，信息举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post-build=xxxxxxxx/xxxxxxxx/xxxxxxxx:4.4.2/xxxxxxxx/817109000126:eng/test-keys</span><br><span class="line">post-timestamp=1553223178</span><br><span class="line">pre-device=xxxxxxxx</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;updater-script是升级脚本，update-binary是升级脚本执行的执行程序，Recovery下面是升级recovery用的。<br>update-script升级脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(!less_than_int(1569489228, getprop("ro.build.date.utc"))) || abort("E3003: Can't install this package (2019年 00月 00日 星期x xx:xx:xx CST) over newer build (" + getprop("ro.build.date") + ").");</span><br><span class="line">getprop("ro.product.device") == "franklin" || abort("E3004: This package is for \"franklin\" devices; this is a \"" + getprop("ro.product.device") + "\".");</span><br><span class="line">if ota_zip_check() == "1" then</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">backup_update_package("/dev/block/mmcblk0", "1894");</span><br><span class="line">set_bootloader_env("upgrade_step", "2");</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">reboot_recovery();</span><br><span class="line">else</span><br><span class="line">ui_print("Target: Android/xxxxx/xxxxxx:9.0.0/xxxxx/0000.00000.001:eng/test-keys");</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">show_progress(0.750000, 0);</span><br><span class="line">ui_print("Patching system image unconditionally...");</span><br><span class="line">block_image_update("/dev/block/system", package_extract_file("system.transfer.list"), "system.new.dat.br", "system.patch.dat") ||</span><br><span class="line">  abort("E1001: Failed to update system image.");</span><br><span class="line">show_progress(0.050000, 5);</span><br><span class="line">package_extract_file("boot.img", "/dev/block/boot");</span><br><span class="line">show_progress(0.200000, 10);</span><br><span class="line">if get_update_stage() == "2" then</span><br><span class="line">format("ext4", "EMMC", "/dev/block/metadata", "0", "/metadata");</span><br><span class="line">format("ext4", "EMMC", "/dev/block/tee", "0", "/tee");</span><br><span class="line">wipe_cache();</span><br><span class="line">set_update_stage("0");</span><br><span class="line">endif;</span><br><span class="line">set_bootloader_env("upgrade_step", "1");</span><br><span class="line">set_bootloader_env("force_auto_update", "false");</span><br><span class="line">endif;</span><br><span class="line">set_progress(1.000000);</span><br></pre></td></tr></table></figure><h1 id="升级流程之升级脚本"><a href="#升级流程之升级脚本" class="headerlink" title="升级流程之升级脚本"></a>升级流程之升级脚本</h1><p>&emsp;&emsp;升级脚本在recovery中执行，执行的每一步骤，是使用update-binary这个二进制文件里面的程序执行，代码见： bootable/recovery/updater/install.cpp 这里面编译会生成updater文件，这个文件就是制作update-binary的。<br>&emsp;&emsp;其中的脚本，通过文件中void RegisterInstallFunctions()  函数中的RegisterFunction(“mount”, MountFn);函数执行，前面是脚本，后面是脚本的函数。<br>执行完所有的脚本过程后，就完成了本次的升级</p><blockquote><p>注：整个升级过程是没有升级recovery自己的分区的</p></blockquote><h1 id="升级流程之启动升级"><a href="#升级流程之启动升级" class="headerlink" title="升级流程之启动升级"></a>升级流程之启动升级</h1><p>&emsp;&emsp;在recovery中，是怎样进行升级的呢？<br>&emsp;&emsp;Recovery的启动也是通过init执行recovery服务进行启动，执行recovery.cpp中的main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recovery.cpp */</span></span><br><span class="line"><span class="comment">/* ....... */</span></span><br><span class="line"><span class="keyword">if</span> (update_package != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    status = install_package(update_package, &amp;should_wipe_cache, TEMPORARY_INSTALL_FILE, <span class="literal">true</span>,</span><br><span class="line">                               retry_count);</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mian函数的入口参数是通过cache/recovery/command中得来。</p></blockquote><p>&emsp;&emsp;升级函数install_package（bootable/recovery/install.cpp）会调用 really_install_package，其中进行校验，之后开始执行升级update-binary调用updater-script开始根据进行升级，最终的升级过程在try_update_binary()函数中进行，其创建了两个管道并fork一个子进程，子进程管道的数据即升级指令，父进程读取其执行相应到处理（升级）工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* install.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_package</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, <span class="keyword">bool</span>* wipe_cache, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; install_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> needs_mount, <span class="keyword">int</span> retry_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; log_buffer;</span><br><span class="line">    <span class="keyword">if</span> (setup_install_mounts() != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"failed to set up expected mounts for install; aborting"</span>;</span><br><span class="line">        result = INSTALL_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = really_install_package(path, wipe_cache, needs_mount, &amp;log_buffer, retry_count,</span><br><span class="line">                                        &amp;max_temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_install_package</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, <span class="keyword">bool</span>* wipe_cache, <span class="keyword">bool</span> needs_mount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* log_buffer, <span class="keyword">int</span> retry_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span>* max_temperature)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="comment">// Verify package.</span></span><br><span class="line">    <span class="keyword">if</span> (!verify_package(<span class="built_in">map</span>.addr, <span class="built_in">map</span>.length)) &#123;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kZipVerificationFailure));</span><br><span class="line">    <span class="keyword">return</span> INSTALL_CORRUPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span>                            </span><br><span class="line">    <span class="comment">// Verify and install the contents of the package.</span></span><br><span class="line">    ui-&gt;Print(<span class="string">"Installing update...\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (retry_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ui-&gt;Print(<span class="string">"Retry attempt: %d\n"</span>, retry_count);</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;SetEnableReboot(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (update_flag == <span class="number">1</span>) &#123;</span><br><span class="line">        result = try_update_binary(new_path, zip, wipe_cache, log_buffer, retry_count, max_temperature);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line"><span class="comment">// If the package contains an update binary, extract it and run it.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_update_binary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; package, ZipArchiveHandle zip, <span class="keyword">bool</span>* wipe_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* log_buffer, <span class="keyword">int</span> retry_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span>* max_temperature)</span> </span>&#123;</span><br><span class="line">    read_source_target_build(zip, log_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> AB_OTA_UPDATER</span></span><br><span class="line">    <span class="keyword">int</span> ret = update_binary_command(package, zip, <span class="string">"/sbin/update_engine_sideload"</span>, retry_count,</span><br><span class="line">                                    pipefd[<span class="number">1</span>], &amp;args);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> ret = update_binary_command(package, zip, <span class="string">"/tmp/update-binary"</span>, retry_count, pipefd[<span class="number">1</span>],</span><br><span class="line">                                    &amp;args);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kUpdateBinaryCommandFailure));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="comment">// When executing the update binary contained in the package, the</span></span><br><span class="line">    <span class="comment">// arguments passed are:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - the version number for this interface</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - an FD to which the program can write in order to update the</span></span><br><span class="line">    <span class="comment">//     progress bar.  The program can write single-line commands:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        progress &lt;frac&gt; &lt;secs&gt;</span></span><br><span class="line">    <span class="comment">//            fill up the next &lt;frac&gt; part of of the progress bar</span></span><br><span class="line">    <span class="comment">//            over &lt;secs&gt; seconds.  If &lt;secs&gt; is zero, use</span></span><br><span class="line">    <span class="comment">//            set_progress commands to manually control the</span></span><br><span class="line">    <span class="comment">//            progress of this segment of the bar.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        set_progress &lt;frac&gt;</span></span><br><span class="line">    <span class="comment">//            &lt;frac&gt; should be between 0.0 and 1.0; sets the</span></span><br><span class="line">    <span class="comment">//            progress bar within the segment defined by the most</span></span><br><span class="line">    <span class="comment">//            recent progress command.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        ui_print &lt;string&gt;</span></span><br><span class="line">    <span class="comment">//            display &lt;string&gt; on the screen.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        wipe_cache</span></span><br><span class="line">    <span class="comment">//            a wipe of cache will be performed following a successful</span></span><br><span class="line">    <span class="comment">//            installation.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        clear_display</span></span><br><span class="line">    <span class="comment">//            turn off the text display.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        enable_reboot</span></span><br><span class="line">    <span class="comment">//            packages can explicitly request that they want the user</span></span><br><span class="line">    <span class="comment">//            to be able to reboot during installation (useful for</span></span><br><span class="line">    <span class="comment">//            debugging packages that don't exit).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        retry_update</span></span><br><span class="line">    <span class="comment">//            updater encounters some issue during the update. It requests</span></span><br><span class="line">    <span class="comment">//            a reboot to retry the same package automatically.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        log &lt;string&gt;</span></span><br><span class="line">    <span class="comment">//            updater requests logging the string (e.g. cause of the</span></span><br><span class="line">    <span class="comment">//            failure).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - the name of the package zip file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - an optional argument "retry" if this update is a retry of a failed</span></span><br><span class="line">    <span class="comment">//   update attempt.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert the vector to a NULL-terminated char* array suitable for execv.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* chr_args[args.size() + <span class="number">1</span>];</span><br><span class="line">    chr_args[args.size()] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">    chr_args[i] = args[i].c_str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to fork update binary"</span>;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kForkUpdateBinaryFailure));</span><br><span class="line">    <span class="keyword">return</span> INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    execv(chr_args[<span class="number">0</span>], <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(chr_args));</span><br><span class="line">    <span class="comment">// Bug: 34769056</span></span><br><span class="line">    <span class="comment">// We shouldn't use LOG/PLOG in the forked process, since they may cause</span></span><br><span class="line">    <span class="comment">// the child process to hang. This deadlock results from an improperly</span></span><br><span class="line">    <span class="comment">// copied mutex in the ui functions.</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"E:Can't run %s (%s)\n"</span>, chr_args[<span class="number">0</span>], strerror(errno));</span><br><span class="line">    _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; logger_finished(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">temperature_logger</span><span class="params">(log_max_temperature, max_temperature, <span class="built_in">std</span>::ref(logger_finished))</span></span>;</span><br><span class="line"></span><br><span class="line">    *wipe_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> retry_update = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    FILE* from_child = fdopen(pipefd[<span class="number">0</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), from_child) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">line</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> space = line.find_first_of(<span class="string">" \n"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">command</span><span class="params">(line.substr(<span class="number">0</span>, space))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (command.empty()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of the leading and trailing space and/or newline.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> args = space == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ? <span class="string">""</span> : android::base::Trim(line.substr(space));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面代码的主要逻辑是，对接收到的命令执行相应的处理操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;try_update_binary 将升级包中的 META-INF/com/google/android/update-binary 拷贝到设备的/tmp 目录并 fork 出一个进程，执行 update-binary 脚本update-binary 脚本用于读取 META-INF/com/google/android/update-binary/updater-script解析执行升级脚本中的命令。父进程通过管道接收 update-binary 传来的命令，并执行相应的操作。<br>&emsp;&emsp;Recovery 在读取并解析升级脚本的过程中，会把升级包中 recovery 目录下的 etc/install-recovery.sh 和recovery.img 释放到设备的 system 目录下。当升级成功，在重启进入 Android 的过程中，系统会运行一个名为 flash_recovery 的 service ,该 service 会运行 install-recovery.sh 脚本，在脚本中会把 recovery.img 直接 dd到 recovery 分区。烧完后，删除 recovery.img 。</p><h1 id="【拓展】Bootloader、BCB、Recovery与Main-System之间的交互"><a href="#【拓展】Bootloader、BCB、Recovery与Main-System之间的交互" class="headerlink" title="【拓展】Bootloader、BCB、Recovery与Main System之间的交互"></a>【拓展】Bootloader、BCB、Recovery与Main System之间的交互</h1><p>&emsp;&emsp;Recovery System与Main System的交互，主要是通过/cache分区下的文件进行信息交互的。具体如下：</p><table><thead><tr><th align="center">/cache文件</th><th align="center">方向</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">/cache/recovery/command</td><td align="center">INPUT</td><td align="center">Main System传递给Recovery的命令行，比如update_package的存放路径等</td></tr><tr><td align="center">/cache/recovery/last_flag</td><td align="center">OUTPUT</td><td align="center">似乎Rockchip平台独有，用于记录自动升级结果</td></tr><tr><td align="center">/cache/recovery/intent</td><td align="center">OUTPUT</td><td align="center">Recovery给Main Syatem传递的信息</td></tr><tr><td align="center">/cache/recovery/last_install</td><td align="center">OUTPUT</td><td align="center">Recovery升级结果文件，主系统可以读取这个文件以便知道系统升级的结果，然后可以给用户相应的提示</td></tr><tr><td align="center">/cache/recovery/last_locale</td><td align="center">OUTPUT</td><td align="center">关系到Recovery模式下，UI文字的语言呈现形式，比如以英文显示，以中文显示等，如果进入recovery时获取不到&lt;-locale&gt;启动参数，则会尝试读取/cache下的</td></tr><tr><td align="center">/cache/recovery/log</td><td align="center">OUTPUT</td><td align="center">Recovery模式下的整个过程的日志，在系统进入Main Systen后，文件名不是以“last_”为前缀的文件会被删除</td></tr><tr><td align="center">/cache/recovery/last_log</td><td align="center">OUTPUT</td><td align="center">Recovery模式下的日志，取自上面所说的log（但可能完整性不及log），一般来说，分析Recovery问题的时候，经常会分析这份log</td></tr></tbody></table><blockquote><p>command的值一般有以下一个或多个。</p></blockquote><p>&emsp;&emsp;Bootloader与Recovery和Main System之间也是存在交互的： Bootloader会通过解析BCB模块，决定启动系统到Recovery或Main System。而Recovery或Main System也能够操作BCB，进而影响到Bootloader的行为。</p><p><img src="/images/Android/Bootloader%E3%80%81BCB%E3%80%81Recovery%E4%B8%8EMainSystem%E5%9B%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="Bootloader、BCB、Recovery与MainSystem四者之间的关系"></p><style>table th:nth-of-type(1){width: 30%;}table th:nth-of-type(2){width: 15%;}table th:nth-of-type(3){width: 55%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/upgrade.jpg&quot; alt=&quot;upgrade&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;em
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的系统架构、核心组件及源码结构</title>
    <link href="https://zhouyuebiao.cn/2019/09/19/0036-Android%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://zhouyuebiao.cn/2019/09/19/0036-Android的系统架构与核心组件及源码结构/</id>
    <published>2019-09-19T06:41:19.000Z</published>
    <updated>2019-09-25T06:32:09.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于Android 9.0<br><img src="/images/Android/android_training.jpg" alt="android_training"></p><h1 id="Android系统架构介绍"><a href="#Android系统架构介绍" class="headerlink" title="Android系统架构介绍"></a>Android系统架构介绍</h1><p>&emsp;&emsp;Android系统架构分为五层，从下到上依次是Linux内核层、硬件抽象层、系统运行库层、应用框架层和应用层。<br><img src="/images/Android/android-stack_2x%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="Android系统架构"></p><h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>&emsp;&emsp;Android站在巨人的肩膀之上，其基于Linux对Linux的依赖主要包括核心和驱动程序两部分。</p><h2 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h2><p>&emsp;&emsp;Android的硬件抽象层，简单来说，就是对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。也就是将Linux内核对硬件的支持分成了两层，一层放在用户空间（User Space），一层放在内核空间（Kernel Space），其中，硬件抽象层运行在用户空间，对应具体的驱动实现细节，而Linux内核驱动程序运行在内核空间，只提供简单的数据访问逻辑。</p><h3 id="Android系统为什么要把对硬件的支持划分为两层来实现呢？"><a href="#Android系统为什么要把对硬件的支持划分为两层来实现呢？" class="headerlink" title="Android系统为什么要把对硬件的支持划分为两层来实现呢？"></a>Android系统为什么要把对硬件的支持划分为两层来实现呢？</h3><p>&emsp;&emsp;Linux内核代码遵循GPL1协议，如果在Android系统所使用的Linux内核中添加或者修改了代码，那么就必须将它们公开。因此，如果Android系统像其他的Linux系统一样，把对硬件的支持完全实现在硬件驱动模块中，那么就必须将这些硬件驱动模块源代码公开，这样就可能会损害移动设备厂商的利益，因为这相当于暴露了硬件的实现细节和参数。</p><h3 id="为什么将其抽象到硬件抽象层就可以规避这个问题呢？"><a href="#为什么将其抽象到硬件抽象层就可以规避这个问题呢？" class="headerlink" title="为什么将其抽象到硬件抽象层就可以规避这个问题呢？"></a>为什么将其抽象到硬件抽象层就可以规避这个问题呢？</h3><p>&emsp;&emsp;Android 系统代码是遵循Apache License2协议的，它允许移动设备厂商添加或者修改Android系统源代码，而又不必公开这些代码。因此，如果把对硬件的支持完全实现在Android系统的用户空间中，那么就可以隐藏硬件的实现细节和参数。然而，这是无法做到的，因为只有内核空间才有特权操作硬件设备。一个折中的解决方案便是将对硬件的支持分别实现在内核空间和用户空间中，其中，内核空间仍然是以硬件驱动模块的形式来支持，不过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现细节和参数。这样就可以保护移动设备厂商的利益了。</p><h2 id="系统运行层（库Libraries和运行环境Runtime）"><a href="#系统运行层（库Libraries和运行环境Runtime）" class="headerlink" title="系统运行层（库Libraries和运行环境Runtime）"></a>系统运行层（库Libraries和运行环境Runtime）</h2><p>&emsp;&emsp;本层次对应一般的嵌入式系统，相当于中间件层次。Android的本层次分成两个部分，一个是各种库，另一个是Android运行环境。本层的内容大多是使用C语言实现。<br>&emsp;&emsp;在一般情况下，Android的各种库是以系统中间件的形式提供的，它们的显著特点是与移动设备平台的应用密切相关。<br>另外，Android的运行环境主要是基于Dalvik（虚拟机）技术的。而Dalvik与一般的Java虚拟机（Java Virtual Machine，JVM）有如下区别：</p><ul><li>Java虚拟机：执行的是Java标准的字节码（Bytecode）。</li><li>Dalvik：执行的是Dalyik可执行格式（.dex）的文件。在执行的过程中，每一个应用程序即一个进程（Linux的一个Process）。</li></ul><p>&emsp;&emsp;二者最大的区别在于，JVM是基于栈的虚拟机（Stack-based），而Dalvik是基于寄存器的虚拟机（Register-based）。显然，后者最大的好处在于可以依据硬件实现更大的优化，这更适合移动设备的特点。</p><h2 id="应用框架层（Application-Framework）"><a href="#应用框架层（Application-Framework）" class="headerlink" title="应用框架层（Application Framework）"></a>应用框架层（Application Framework）</h2><p>&emsp;&emsp;在整个Android系统中，与应用开发最相关的是Application Framework，在这一层，Android为应用程序层的开发者提供了各种功能强大的APIs，这实际上是一个应用程序的框架。由于上层的应用程序是以Java构建的。在本层提供了程序中所需要的各种控件，例如：Views（视图组件）、List（列表）、Grid（栅格）、Text Box（文本框）、Button（按钮），甚至还有一个嵌入式的Web浏览器。<br>&emsp;&emsp;这一层提供的主要组件有：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Activity Manager(活动管理器)</td><td align="center">管理各个应用程序生命周期以及通常的导航回退功能</td></tr><tr><td align="center">Location Manager(位置管理器)</td><td align="center">提供地理位置以及定位功能服务</td></tr><tr><td align="center">Package Manager(包管理器)</td><td align="center">管理所有安装在Android系统中的应用程序</td></tr><tr><td align="center">Notification Manager(通知管理器)</td><td align="center">使得应用程序可以在状态栏中显示自定义的提示信息</td></tr><tr><td align="center">Resource Manager（资源管理器）</td><td align="center">提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td></tr><tr><td align="center">Telephony Manager(电话管理器)</td><td align="center">管理所有的移动设备功能</td></tr><tr><td align="center">Window Manager（窗口管理器）</td><td align="center">管理所有开启的窗口程序</td></tr><tr><td align="center">Content Providers（内容提供器）</td><td align="center">使得不同应用程序之间可以共享数据</td></tr><tr><td align="center">View System（视图系统）</td><td align="center">构建应用程序的基本组件</td></tr></tbody></table><h2 id="应用层（Application）"><a href="#应用层（Application）" class="headerlink" title="应用层（Application）"></a>应用层（Application）</h2><p>&emsp;&emsp;系统内置的应用程序以及非系统级的应用程序都是属于应用层。Android的应用程序负责与用户进行直接交互（GUI），通常基于Java进行开发，有时候还包含各种被放置在“res”目录中的资源文件。Java源码和相关资源在经过编译后会生成一个APK包。此外应用程序的开发者还可以使用应用程序框架层的API实现自己的程序。应用层是Android巨大潜力的体现。</p><h1 id="Android源码结构"><a href="#Android源码结构" class="headerlink" title="Android源码结构"></a>Android源码结构</h1><p>&emsp;&emsp;源码的全部工程可以分为三个部分：</p><ol><li>Core Project：核心工程部分，这是建立Android系统的基础，保存在根目录的各个文件夹中。</li><li>External Project：扩展工程部分，可以使其他开源项目具有扩展功能，保存在external文件夹中。</li><li>Package：包部分，提供了Android的应用程序、内容提供者、输入法和服务，保存在package文件夹中。</li></ol><p>&emsp;&emsp;源码中包含了原始的Android的目标机器代码、主机编译工具和仿真环境。第一级别目录结构如下：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abi</td><td align="center">应用程序二进制接口</td></tr><tr><td align="center">art</td><td align="center">全新的ART运行环境</td></tr><tr><td align="center">bionic</td><td align="center">系统C库</td></tr><tr><td align="center">bootable</td><td align="center">启动引导相关代码</td></tr><tr><td align="center">build</td><td align="center">存放系统编译规则及generic等基础开发包配置</td></tr><tr><td align="center">cts</td><td align="center">Android兼容性测试套件标准</td></tr><tr><td align="center">dalvik</td><td align="center">dalvik虚拟机</td></tr><tr><td align="center">developers</td><td align="center">开发者目录</td></tr><tr><td align="center">development</td><td align="center">应用程序开发相关代码</td></tr><tr><td align="center">device</td><td align="center">设备相关配置</td></tr><tr><td align="center">docs</td><td align="center">参考文档目录</td></tr><tr><td align="center">external</td><td align="center">开源模组相关文件</td></tr><tr><td align="center">frameworks</td><td align="center">应用程序框架，Android系统核心部分，由Java和C++编写</td></tr><tr><td align="center">hardware</td><td align="center">主要是硬件抽象层的代码</td></tr><tr><td align="center">libcore</td><td align="center">核心库相关文件</td></tr><tr><td align="center">libnativehelper</td><td align="center">动态库，实现JNI库的基础</td></tr><tr><td align="center">ndk</td><td align="center">NDK相关代码。Android NDK（Android Native Development Kit）是一系列的开发工具，允许程序开发人员在Android应用程序中嵌入C/C++语言编写的非托管代码</td></tr><tr><td align="center">out</td><td align="center">编译完成后代码输出在此目录</td></tr><tr><td align="center">packages</td><td align="center">应用程序包</td></tr><tr><td align="center">pdk</td><td align="center">Plug Development Kit 的缩写，本地开发套件</td></tr><tr><td align="center">platform_testing</td><td align="center">平台测试</td></tr><tr><td align="center">prebuilts</td><td align="center">x86和arm架构下预编译的一些资源</td></tr><tr><td align="center">sdk</td><td align="center">sdk和模拟器</td></tr><tr><td align="center">system</td><td align="center">底层文件系统库、应用和组件，C语言实现</td></tr><tr><td align="center">toolchain</td><td align="center">工具链文件</td></tr><tr><td align="center">tools</td><td align="center">工具文件</td></tr><tr><td align="center">Makefile</td><td align="center">全局Makefile文件，用来定义编译规则</td></tr></tbody></table><p><img src="/images/Android/Android9.0.0%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Android9.0.0源码目录结构"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://androidxref.com/" target="_blank" rel="noopener">Android系统源码阅读</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5c0f7b90f265da613b6f9e97" target="_blank" rel="noopener">https://juejin.im/post/5c0f7b90f265da613b6f9e97</a></p><style>table th:nth-of-type(1){width:35%;}table th:nth-of-type(2){width: 65%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;基于Android 9.0&lt;br&gt;&lt;img src=&quot;/images/Android/android_training.jpg&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式软件开发工程师知识点</title>
    <link href="https://zhouyuebiao.cn/2019/09/16/0035-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zhouyuebiao.cn/2019/09/16/0035-嵌入式软件开发工程师知识点/</id>
    <published>2019-09-16T12:18:29.000Z</published>
    <updated>2019-09-19T08:48:52.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover/learn_dog.jpg" alt="cover"></p><h1 id="什么是预编译，何时需要预编译？"><a href="#什么是预编译，何时需要预编译？" class="headerlink" title="什么是预编译，何时需要预编译？"></a>什么是预编译，何时需要预编译？</h1><p>&emsp;&emsp;预编译又称预处理，是做一些代码文本的替换工作，处理‘#’开头的指令 , 比如拷贝 #include包含的文件代码， #define 宏定义的替换 , 条件编译等就是为编译做的预备工作的阶段预编译指令指示了在程序正式编译前就由编译器进行了操作，可以放在程序的任何位置。<br>&emsp;&emsp;何时使用：当大部分文件代码基本上不会更改时，比如 MFC的一些头文件以及一些必要的API 使用代码，也可以把你自己的一部分代码封装起来到一个 C或 C++文件中，（比如在其中包含一些头文件或必要的代码什么的， 然后在 VC-C/C++–PreCompiled Headers 里选择第三项 Create compiled Header file ）来指定为预编译头文件，这样就在以后的程序修改中编译时不会反复编译这部分。</p><blockquote><p>注意：过多的使用预编译头文件会大大降低编译的速度。</p></blockquote><h1 id="左定值右定向"><a href="#左定值右定向" class="headerlink" title="左定值右定向"></a>左定值右定向</h1><p>&emsp;&emsp;深入理解 char &#42;  const p,char const &#42; p,const char &#42; p 的区别</p><ol><li>关键看 const 修饰的是谁</li><li>由于没有 const &#42;  的运算，若出现 const &#42;  的形式，则 const 实际上是修饰前面的。</li></ol><p>&emsp;&emsp;char &#42; const p （const 修饰的是 p）：只能对“某个固定的位置” 进 行读写操作，并且在定义 p 时就必须初始化 （因为在后面不能执行“ p=.. ”的操作， 因此就不能在后面初始化，因此只能在定义时初始化） 。</p><blockquote><p>“某个固定的位 置”是相对于 char &#42; p 来说所限定的内容。</p></blockquote><p>&emsp;&emsp;char const&#42; p, 由于没有const&#42;运算，则const实际上是修饰前面的char，因此char const&#42; p等价于const char&#42; p。const char&#42; p 或者char const &#42; p （因为没有 const&#42; p 运算，因此const修饰的还是前面的char，可以对任意位置 （非系统敏感区域） 进行“只读” 操作。</p><blockquote><p>“只读”是相对于 char &#42; p 来说所限定的内容。</p></blockquote><h1 id="指针的长度？"><a href="#指针的长度？" class="headerlink" title="指针的长度？"></a>指针的长度？</h1><p>&emsp;&emsp;一个 32 位的机器 , 该机器的指针是多少位?：<br>&emsp;&emsp;指针是多少位只要看地址总线的位数就行了。 80386 以后的机子都是 32 的数据总线。所以指针的位数就是 4 个字节了。 </p><h1 id="进程的同步机制"><a href="#进程的同步机制" class="headerlink" title="进程的同步机制"></a>进程的同步机制</h1><p>&emsp;&emsp;列举几种进程的同步机制，并比较其优缺点 。</p><ul><li>原子操作</li><li>信号量机制</li><li>自旋锁</li><li>管程</li><li>会合</li><li>分布式系统</li></ul><h1 id="进程之间通信的途径"><a href="#进程之间通信的途径" class="headerlink" title="进程之间通信的途径"></a>进程之间通信的途径</h1><p>&emsp;&emsp;途径归纳而言如下：</p><ol><li>数据传输：一个进程向另一个进程传输数据，一般在一个字节和几 M字节之间。</li><li>共享数据</li><li>资源共享： 多个进程之间共享同样的资源， 为了做到这一点需要内核提供锁和同步机制。</li><li>通知事件 : 一个进程向另一个进程或一组进程发送消息， 通知他梦发生了某种事件 （如进程终止样通知付进程）</li><li>进程控制：有些进程希望完全控制另一个进程（ Debug进程），此时控制进程希望能够拦截另一个进程的所有的陷入和异常，并能够及时知道他的状态改变。</li></ol><h2 id="管道-pipe-："><a href="#管道-pipe-：" class="headerlink" title="管道 ( pipe ) ："></a>管道 ( pipe ) ：</h2><p>&emsp;&emsp;管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>&emsp;&emsp;创建一个简单的管道，可以使用系统调用 pipe() 。它接受一个参数，也就是一个包括两个整数的数组。 如果系统调用成功， 此数组将包括管道使用的两个文件描述符。 创建一个管道之后，一般情况下进程将产生一个新的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">系统调用： pipe();</span></span><br><span class="line"><span class="comment">原型： int pipe(int fd[2]);</span></span><br><span class="line"><span class="comment">返回值：如果系统调用成功，返回 0。如果系统调用失败返回 -1 ：</span></span><br><span class="line"><span class="comment">errno=EMFILE( 没有空亲的文件描述符）</span></span><br><span class="line"><span class="comment">EMFILE （系统文件表已满）</span></span><br><span class="line"><span class="comment">EFAULT （fd 数组无效）</span></span><br><span class="line"><span class="comment">注意： fd[0] 用于读取管道， fd[1] 用于写入管道。</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"><span class="comment">/*管道的创建*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create success\n"</span>);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管道的读写管道主要用于不同进程间通信。实际上，通常先创建一个管道，再通过 fork 函数创建一个<br>子进程。</p><p>子进程写入和父进程读的命名管道：</p><h3 id="管道读写注意事项："><a href="#管道读写注意事项：" class="headerlink" title="管道读写注意事项："></a>管道读写注意事项：</h3><p>&emsp;&emsp;可以通过打开两个管道来创建一个双向的管道。但需要在子理程中正确地设置文件描述符。<br>&emsp;&emsp;必须在系统调用 fork() 中调用 pipe() ，否则子进程将不会继承文件描述符。当使用半双工管道时，任何关联的进程都必须共享一个相关的祖先进程。因为管道存在于系统内核之中，所以任何不在创建管道的进程的祖先进程之中的进程都将无法寻址它。 而在命名管道中却不是这样。<br>&emsp;&emsp;管道实例见： pipe_rw.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf_r[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span>* p_wbuf;</span><br><span class="line">    <span class="keyword">int</span> r_num;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf_r,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf_r)); 数组中的数据清 <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((r_num=read(pipe_fd[<span class="number">0</span>],buf_r,<span class="number">100</span>))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d numbers read from be pipe is %s\n"</span>,r_num,buf_r);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">"Hello"</span>,<span class="number">5</span>)!=<span class="number">-1</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent write success!\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">" Pipe"</span>,<span class="number">5</span>)!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent wirte2 succes!\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有名管道-named-pipe"><a href="#有名管道-named-pipe" class="headerlink" title="有名管道(named pipe)"></a>有名管道(named pipe)</h2><p>&emsp;&emsp;有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><h2 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h2><p>&emsp;&emsp;信号量是一个计数器，可以用来控制多个进程对共享资源的访问。 它常作为一种锁机制， 防止某进程正在访问共享资源时， 其他进程也访问该资源。 因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h2 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列(message queue)"></a>消息队列(message queue)</h2><p>&emsp;&emsp;消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。 消息队列克服了信号传递信息少、 管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h2 id="信号-sinal"><a href="#信号-sinal" class="headerlink" title="信号(sinal)"></a>信号(sinal)</h2><p>&emsp;&emsp;信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。信号是软件中断。信号（ signal ）机制是 Unix 系统中最为古老的进程之间的能信机制。它用于在一个或多个进程之间传递异步信号。很多条件可以产生一个信号。</p><h2 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存(shared memory)"></a>共享内存(shared memory)</h2><p>&emsp;&emsp;共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。 它往往与其他通信机制， 如信号两， 配合使用，来实现进程间的同步和通信。</p><h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><p>&emsp;&emsp;套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>&emsp;&emsp;死锁产生的原因及四个必要条件:</p><h2 id="产生死锁的原因："><a href="#产生死锁的原因：" class="headerlink" title="产生死锁的原因："></a>产生死锁的原因：</h2><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当等。<blockquote><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 其次， 进程运行推进顺序与速度不同， 也可能产生死锁。</p></blockquote></li></ol><h2 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h2><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。</p><blockquote><p>这四个条件是死锁的必要条件， 只要系统发生死锁， 这些条件必然成立， 而只要上述条件之一不满足，就不会发生死锁 。</p></blockquote><h2 id="死锁的解除与预防："><a href="#死锁的解除与预防：" class="headerlink" title="死锁的解除与预防："></a>死锁的解除与预防：</h2><p>&emsp;&emsp;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 所以，在系统设计、 进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法， 避免进程永久占据系统资源。 此外， 也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h2 id="操作系统中进程调度策略有哪几种？"><a href="#操作系统中进程调度策略有哪几种？" class="headerlink" title="操作系统中进程调度策略有哪几种？"></a>操作系统中进程调度策略有哪几种？</h2><ol><li>FCFS(先来先服务 ) </li><li>优先级</li><li>时间片轮转</li><li>多级反馈</li></ol><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>&emsp;&emsp;纯虚函数如何定义？使用时应注意什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void f()=0; 是接口，子类必须要实现</span><br></pre></td></tr></table></figure><h1 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>&emsp;&emsp;数据顺序存储，固定大小。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>&emsp;&emsp;数据可以随机存储，大小可动态改变</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="ISO-的七层模型是什么？"><a href="#ISO-的七层模型是什么？" class="headerlink" title="ISO 的七层模型是什么？"></a>ISO 的七层模型是什么？</h2><p>&emsp;&emsp;OSI（Open System Interconnection ）参考模型是国际标准化组织（ ISO）制定的一个用于计算机或通信系统间互联的标准体系， 一般称为 OSI 参考模型或七层模型。 它是一个七层的、抽象的模型，不仅包括一系列抽象的术语或概念，也包括具体的协议<br><img src="/images/network/OSI_Mode.png" alt="ISO七层模型"></p><p>&emsp;&emsp;网卡、集线器、hub工作在物理层<br>&emsp;&emsp;路由器(router)工作在网络层<br>&emsp;&emsp;交换机(switch)工作在数据链路层<br>&emsp;&emsp;常见的网络层协议： IP 协议、 ICMP、 IGMP、 MPLS、 ARP<br>&emsp;&emsp;常见的传输层协议： TCP、 UDP<br>&emsp;&emsp;常见的应用层协议： TELNET、 SMTP、 HTTP、 FTP、 DHCP、 SNMP</p><h2 id="tcp-udp-是属于哪一层？"><a href="#tcp-udp-是属于哪一层？" class="headerlink" title="tcp/udp 是属于哪一层？"></a>tcp/udp 是属于哪一层？</h2><p>&emsp;&emsp;tcp /udp 属于传输层<br>&emsp;&emsp;TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等<br>&emsp;&emsp;与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、 流控制以及错误恢复功能等。由于 UDP 比 较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。</p><blockquote><p>tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好，开销大，实时性较差。<br>udp: 包头小，开销小 , 占用资源少，实时性较好，缺点是不可靠。 tcp 是面向连接的可靠字节流</p></blockquote><h2 id="tcp-udp-有何优缺点？"><a href="#tcp-udp-有何优缺点？" class="headerlink" title="tcp/udp 有何优缺点？"></a>tcp/udp 有何优缺点？</h2><p>&emsp;&emsp;udp 是无连接的不可靠报文传递。<br>&emsp;&emsp;TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须在双方之间建立一个 TCP连接，之后才能传输数据， TCP提供超时重发、丢弃重复数据、检验数据、流控制等功能，保证数据能从一端传输到另一端。<br>&emsp;&emsp;UDP是用户数据报协议，是一个简单的面向数据报的运输层的协议。 UDP不提供可靠性，他只是把应用程序传给 IP 层的数据报发送出去。但是并不保证它们到达目的地，由于 UDP在传输前不需要在客户端与服务器端之间建立一个连接， 且没有超时重发机制， 故而传输速度很快。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr=(<span class="keyword">int</span> *)(&amp;a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="已知一个数组-table-，用一个宏定义，求出数据的元素个数"><a href="#已知一个数组-table-，用一个宏定义，求出数据的元素个数" class="headerlink" title="已知一个数组 table ，用一个宏定义，求出数据的元素个数"></a>已知一个数组 table ，用一个宏定义，求出数据的元素个数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIBL （sizeof(table)/sizfof(table[0]) ）</span></span><br></pre></td></tr></table></figure><h1 id="对于一个频繁使用的短小函数-在-C语言中应用什么实现-在-C-中应用什么实现"><a href="#对于一个频繁使用的短小函数-在-C语言中应用什么实现-在-C-中应用什么实现" class="headerlink" title="对于一个频繁使用的短小函数 , 在 C语言中应用什么实现 , 在 C++中应用什么实现 ?"></a>对于一个频繁使用的短小函数 , 在 C语言中应用什么实现 , 在 C++中应用什么实现 ?</h1><p>答案： c 用宏定义， c++用 inline</p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p>&emsp;&emsp;软件测试都有那些种类 ?</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h2 id="黑盒测试-1"><a href="#黑盒测试-1" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>&emsp;&emsp;指的是把被测的软件看作是一个黑盒子， 我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。它只检查程序功能是否按照需求规格说明书的规定正常使用， 程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>&emsp;&emsp;白盒测试， 指的是把盒子盖子打开， 去研究里面的源代码和程序结果。 它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作</p><h2 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h2><p>&emsp;&emsp;灰盒测试介于黑盒测试与白盒测试之间。<br>&emsp;&emsp;可以这样理解， 灰盒测试关注输出对于输入的正确性， 同时也关注内部表现， 但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p><h1 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumstring &#123; x1, x2, x3=<span class="number">10</span>, x4, x5, &#125;x;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;问 x；<br>&emsp;&emsp;枚举元素的值不可以改变 但是你可以在定义时对其进行初始化 若都不赋值依次为 0 1 2 3 4 5 。。。若赋了一个值则后面的值为前面的一次加一对其进行赋值如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">string</span></span><br><span class="line">&#123;</span><br><span class="line">    x1=<span class="number">1</span>,</span><br><span class="line">    x2,</span><br><span class="line">    x3=<span class="number">10</span>,</span><br><span class="line">    x4=<span class="number">12</span>,</span><br><span class="line">    x5,</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么现在元素的值依次为：1 2 10 12 13</p><h1 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p2; </span><br><span class="line">p1=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="number">0x801000</span>; </span><br><span class="line">p2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)<span class="number">0x810000</span>;</span><br></pre></td></tr></table></figure><p>请问： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1+5=?;</span><br><span class="line">p2+5=?;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;答案： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1+5=801005;</span><br><span class="line">p2+5=810014;</span><br></pre></td></tr></table></figure><blockquote><p>不要忘记了这个是 16 进制的数字， p2 要加 20 变为 16 进制就是 14</p></blockquote><h1 id="TCP-IP-通信建立的过程怎样，端口有什么作用？"><a href="#TCP-IP-通信建立的过程怎样，端口有什么作用？" class="headerlink" title="TCP/IP 通信建立的过程怎样，端口有什么作用？"></a>TCP/IP 通信建立的过程怎样，端口有什么作用？</h1><p>&emsp;&emsp;三次握手，确定是哪个应用程序使用该协议<br>&emsp;&emsp;TCP/IP 的三次握手</p><ul><li>第一次握手： 客户端发送 syn 包(syn=j) 到服务器， 并进入 SYN_SEND状态， 等待服务器确认 ;</li><li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN(ack=j+1) ，同时自己也发送一个SYN包(syn=k) ，即 SYN+ACK包，此时服务器进入 SYN_RECV状态 ;</li><li>第三次握手：客户端收到服务器的 SYN+ACK包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。</li></ul><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><p>&emsp;&emsp;理想状态下， TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP连接的请求，断开过程需要经过“四次握手” ( 过程就不细写了，就是服务器和客户端交互，最终确定断开 )</p><h1 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h1><p>&emsp;&emsp;TCP-传输控制协议， 提供的是面向连接、 可靠的字节流服务。 但客户端和服务器端彼此交换数据前，必须现在双方建立 TCP连接，然后才能传输数据。TCP提供方超时重发，丢弃重复的数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>&emsp;&emsp;UDP：用户数据报协议，是一个简单的面向数据报的运输层协议， UDP不提供平可靠性，他只是负者吧应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能够到达目的地，<br>&emsp;&emsp;由于 UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度快</p><h1 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a>局部变量能否和全局变量重名？</h1><p>&emsp;&emsp;能， 局部会屏蔽全局。 要用全局变量， 需要使用 “::” 局部变量可以与全局变量同名，在函数内引用这个变量时， 会用到同名的局部变量， 而不会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多个同名的局部变量， 比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p><h1 id="如何引用一个已经定义过的全局变量？"><a href="#如何引用一个已经定义过的全局变量？" class="headerlink" title="如何引用一个已经定义过的全局变量？"></a>如何引用一个已经定义过的全局变量？</h1><p>extern 可以用引用头文件的方式， 也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错</p><h1 id="全局变量可不可以定义在可被多个-C-文件包含的头文件中？为什么？"><a href="#全局变量可不可以定义在可被多个-C-文件包含的头文件中？为什么？" class="headerlink" title="全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？"></a>全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？</h1><p>&emsp;&emsp;可以，在不同的 C文件中以 static 形式来声明同名全局变量。可以在不同的 C文件中声明同名的全局变量， 前提是其中只能有一个 C文件中对此变量赋初值， 此时连接不会出错</p><h1 id="无限循环的表示方式"><a href="#无限循环的表示方式" class="headerlink" title="无限循环的表示方式"></a>无限循环的表示方式</h1><h2 id="for-1"><a href="#for-1" class="headerlink" title="for( ; 1 ; )"></a>for( ; 1 ; )</h2><p>&emsp;&emsp;语句 for( ; 1 ; ) 有什么问题？它是什么意思？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和while(1) 相同。</span><br></pre></td></tr></table></figure><h1 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h1><h2 id="队列和栈有什么区别-？"><a href="#队列和栈有什么区别-？" class="headerlink" title="队列和栈有什么区别 ？"></a>队列和栈有什么区别 ？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列先进先出，栈后进先出</span><br></pre></td></tr></table></figure><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>&emsp;&emsp;内存分配应该注意什么问题？</p><ol><li>检查内存是否分配成功</li><li>内存生命周期，程序结束时记得 free ，避免内存的泄露</li><li>使用过程中，避免指针的越界访问，会导致不必要的错误。</li></ol><h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。</li><li>线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</li></ol><blockquote><p>两者都可以提高程序的并发度，提高程序运行效率和响应时间。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>&emsp;&emsp;线程和进程在使用上各有优缺点： </p><ol><li>线程执行开销小， 但不利于资源管理和保护，而进程正相反。</li><li>同时，线程适合于在 SMP机器上运行，而进程则可以跨机器迁移。</li></ol><p>&emsp;&emsp;根本区别就一点：用多进程每个进程有自己的地址空间 (address space) ，线程则共享地址空间。所有其它区别都是由此而来的：</p><ul><li>速度： 线程产生的速度快， 线程间的通讯快、 切换快等， 因为他们在同一个地址空间内。</li><li>资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。</li><li>同步问题： 线程使用公共变量 / 内存时需要使用同步机制还是因为他们在同一个地址空间内。</li></ul><blockquote><p>实时操作系统 ： 所谓实时操作系统， 实际上是指操作系统工作时， 其资源可以根据需要随时进行动态分配，由于各种资源可以进行动态分配，因此其处理事务的能力较强、速度较快。其主要的特点是提供及时的响应和高可靠性。</p></blockquote><h1 id="堆栈溢出的主要原因是没有回收垃圾资源。"><a href="#堆栈溢出的主要原因是没有回收垃圾资源。" class="headerlink" title="堆栈溢出的主要原因是没有回收垃圾资源。"></a>堆栈溢出的主要原因是没有回收垃圾资源。</h1><h1 id="C语言的定义和声明"><a href="#C语言的定义和声明" class="headerlink" title="C语言的定义和声明"></a>C语言的定义和声明</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;编译器在创建一个对象时， 为该对象申请开辟的内存空间， 这个空间的的名字就是变量名或者对象名。同一个变量名在摸个区域内只能定义一次，重复定义会出现错误的。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>&emsp;&emsp;声明有两种作用：</p><ol><li>告诉编译器， 这个变量或者函数， 我已经定义了 （开辟空间了） ， 但是在别的地方，我先说明一下，免得编译器报错。当然，声明可以多次出现。</li><li>告诉编译器，这个变量名或者对象名，我先预定了， 其他地方不可以用了。和在饭馆吃饭（人多）要提前预约一样的道理。</li></ol><blockquote><p>定义和声明最本质的区别在于， 声明没开辟空间， 而定义则创建对象 （变量） 并开辟了空间。这是最重要的一点。</p></blockquote><h1 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h1><p>&emsp;&emsp;这个结构体的大小多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">int</span> Num ；</span><br><span class="line"><span class="keyword">char</span>*Pc ；</span><br><span class="line"><span class="keyword">short</span> sDtate ；</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">short</span> S[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;int：占 4 个字节（ 32 系统）。<br>&emsp;&emsp;char <em>pc：指针相当于地址，地址就是你当前操作系统的位数。如果是指针数组即存放指针的数组，占用的空间是 4</em>数组的个数。<br>&emsp;&emsp;如果是数组指针即指向数组的指针，指针指向的是数组的地址，占用 4 个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short sDtate：2 个</span><br><span class="line">char ch[2]：2 个</span><br><span class="line">short S[4]：2*4=8 short 型数组</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以一起占用：4+4+2+2+8=20 字节。</p><h1 id="在C-中引用C"><a href="#在C-中引用C" class="headerlink" title="在C++中引用C"></a>在C++中引用C</h1><p>&emsp;&emsp;如何在 C++中引用 C？<br>&emsp;&emsp;C++和 C是两种完全不同的编译连接处理方式，如果直接在 C++里面调用 C函数，会找不到函数体， 报连接错误， 就要在 C++文件中面申明哪些函数是 C写的， 要用 C的处理方式处理。<br>&emsp;&emsp;1、 引用头文件前需要加上 extern “C”如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"S.h"</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2、 C++调用 C函数的方法，将用到的函数全部重新声明一遍，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Extern <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Externa <span class="keyword">void</span> <span class="title">A_app</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C++语言支持函数的重载， C语言不支持函数的重载。函数被 C++编译后在库中的名字与 C语言的不同， 所以 C++程序不能直接调用 C函数， C++提供一个 C连接交换指定符号 extern ” C”来解决这个问题。</p><h1 id="C语言中嵌入汇编"><a href="#C语言中嵌入汇编" class="headerlink" title="C语言中嵌入汇编"></a>C语言中嵌入汇编</h1><p>&emsp;&emsp;C语言中嵌入汇编？<br>&emsp;&emsp;为什么需要嵌入汇编： C语言是一种中级语言，可以实现高级语言的模块化编程，又可以实现对底层的操作。但是，与汇编相比， C语言的效率还是比较低的。因此，在对效率与硬件操作要求比较高的地方，可以采用将部分汇编语句嵌入到 C语言中的方式。<br>&emsp;&emsp;在 gcc 中，可以使用 <em>asm_表示后面代码为内嵌汇编代码， _volatile</em> 表示编译器不要优化代码。语法 <em>asm</em> <em>volatile</em>( 汇编语句模板：输出部分：输入部分：破坏描述部分 )<br>&emsp;&emsp;汇编语句模板是汇编命令的字符串， 输出部分是需要输出到 C变量参数列表， 输入部分是需要从 C变量输入到 ASM汇编的参数列表， 破坏描述部分是执行汇编指令会破坏的寄存器描述。</p><h1 id="预处理指令-error"><a href="#预处理指令-error" class="headerlink" title="预处理指令#error"></a>预处理指令#error</h1><p>&emsp;&emsp;#error 预处理指令的作用是 ，编译程序时，只要遇到 #error 就会生成一个编译错误提示消息，并停止编译。其语法格式为： #error error-message</p><h1 id="Linux的内存管理"><a href="#Linux的内存管理" class="headerlink" title="Linux的内存管理"></a>Linux的内存管理</h1><p>&emsp;&emsp;早期的计算机中，程序直接运行在物理内存上。但是不适合现在的系统，这些支持多任务，多进程的。 这个时候我们就要考虑将系统的有限的物理内存如何及时有效的分配给多个程序，这个事情本身我们称之为内存管理。<br>&emsp;&emsp;内存管理想要解决的问题： </p><ol><li>进程地址空间不能分割，由于程序直接访问的是物理内存，这个时候程序锁使用的内存空间不是隔离的。</li><li>内存使用的效率低， </li><li>程序运行的地址不能确定， 程序每次运行的时候， 都要在内存中开辟一块足够大的空闲区域， 而这个空闲区域位置是不确定的，这会带来重定位的问题。</li></ol><p>&emsp;&emsp;内存管理无非就是想办法解决上面三个问题， 如何使进程的地址空间隔离， 如何提高内存的使用效率，如何解决程序运行时的重定位问题？<br>&emsp;&emsp;这里引用计算机界一句无从考证的名言： “计算机系统里的任何问题都可以靠引入一个中间层来解决。”<br>&emsp;&emsp;内存管理的几种方式：</p><ol><li>页式管理。 </li><li>段式管理。 </li><li>断页式管理</li></ol><h1 id="X86与X64"><a href="#X86与X64" class="headerlink" title="X86与X64"></a>X86与X64</h1><p>&emsp;&emsp;Intel 曾用 8086,80286,80386 等作为其PC用 CPU的型号表示法：</p><ul><li>X86 是 Intel 制造的普通CPU；</li><li>X64是 X86_64的缩写，是 X86 的改进版，加入了 64 位地址扩展等性能。</li></ul><h1 id="linux系统的Socket-网络编程"><a href="#linux系统的Socket-网络编程" class="headerlink" title="linux系统的Socket 网络编程"></a>linux系统的Socket 网络编程</h1><p>&emsp;&emsp;socket 相当于进行网络通信两端的插座， 只要对方的 socket 和自己的 socket 有通信连接，双方就可以通信。<br>&emsp;&emsp;服务器端的程序编写：</p><ol><li>调用 ServerSocket （int port ）创建一个服务器端的套接字，并绑定到指定的端口号。</li><li>调用 accept （），监听连接请求，则接收连接，返回通信套接字。</li><li>调用 Socket 类的 getOutStream （）和 getinputStream() 获取输出流和输入流，开始网络的输出与输入。</li><li>关闭通信套接字 Socket.close （）</li></ol><p>&emsp;&emsp;客户端的程序编写：</p><ol><li>调用 Socket 创建一个流套接字，并连接到服务器。</li><li>调用 Socket 类的 getoutputstream() 和 fetInputStream 获取输出流和输入流，开始网络的数据的发送和接收。</li><li>关闭通信套接字 socket.close().</li></ol><h1 id="网络中常见的-ping-命令是什么协议"><a href="#网络中常见的-ping-命令是什么协议" class="headerlink" title="网络中常见的 ping 命令是什么协议 ?"></a>网络中常见的 ping 命令是什么协议 ?</h1><p>&emsp;&emsp;Ping 的原理是，向指定的 ip 地址发送一定长度的数据包，按照约定，若指定的 IP 地址存在，会返回同样大小的数据包。在特定的时间没有返回，就是超时，一般认为指定的 IP 地址不存在。 Ping 使用的是 ICMP（Internet Control message protocol Internet 控制消息协议）。<br>&emsp;&emsp;有些防火墙会屏蔽 ICMP协议，所以有时候 ping 的结果只能做参考， ping 不同并不表示对方的 IP 不存在。 他是一把双刃剑， 别人使用 ping 命令可能会探测到你的计算机上的许多消息。可以安装防火墙，或创建一个禁止所有计算机 ping 本机地址的安全策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/cover/learn_dog.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是预编译，何时需要预编译？&quot;&gt;&lt;a href=&quot;#什么是预编译，何时需要预编译？&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式常见经典考点总结</title>
    <link href="https://zhouyuebiao.cn/2019/09/09/0034-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://zhouyuebiao.cn/2019/09/09/0034-嵌入式常见经典考点总结/</id>
    <published>2019-09-09T10:13:13.000Z</published>
    <updated>2019-09-19T08:48:46.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover/learn.jpg" alt="learn"></p><h1 id="一、预处理器（Preprocessor）"><a href="#一、预处理器（Preprocessor）" class="headerlink" title="一、预处理器（Preprocessor）"></a>一、预处理器（Preprocessor）</h1><h2 id="用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"><a href="#用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）" class="headerlink" title="用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"></a>用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我在这想看到几件事情：</p><ul><li>#define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）</li><li>懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</li><li>意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。</li><li>如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</li></ul><h2 id="写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个。"><a href="#写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个。" class="headerlink" title="写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。"></a>写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MIN(A,B) （（A） &lt;= (B) ? (A) : (B))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个测试是为下面的目的而设的：</p><ul><li>标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</li><li>三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。</li><li>懂得在宏中小心地把参数用括号括起来</li><li>我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">least = MIN(*p++, b);</span><br></pre></td></tr></table></figure></li></ul><h2 id="预处理器标识-error的目的是什么？"><a href="#预处理器标识-error的目的是什么？" class="headerlink" title="预处理器标识#error的目的是什么？"></a>预处理器标识#error的目的是什么？</h2><p>&emsp;&emsp;如果你不知道答案，请看参考[附录]。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p><h1 id="二、死循环（Infinite-loops）"><a href="#二、死循环（Infinite-loops）" class="headerlink" title="二、死循环（Infinite loops）"></a>二、死循环（Infinite loops）</h1><p>&emsp;&emsp;嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？<br>这个问题用几个解决方案。我首选的方案是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一些程序员更喜欢如下方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是：”我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。</p></blockquote><p>&emsp;&emsp;第三个方案是用 goto</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure><blockquote><p>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p></blockquote><h1 id="三、数据声明（Data-declarations）"><a href="#三、数据声明（Data-declarations）" class="headerlink" title="三、数据声明（Data declarations）"></a>三、数据声明（Data declarations）</h1><p>&emsp;&emsp;用变量a给出下面的定义：</p><ul><li>a) 一个整型数（An integer） </li><li>b)一个指向整型数的指针（ A pointer to an integer） </li><li>c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r </li><li>d)一个有10个整型数的数组（ An array of 10 integers） </li><li>e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） </li><li>f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） </li><li>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） </li><li>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）</li></ul><p>&emsp;&emsp;答案是：</p><ul><li>a) int a; // An integer </li><li>b) int *a; // A pointer to an integer </li><li>c) int **a; // A pointer to a pointer to an integer </li><li>d) int a[10]; // An array of 10 integers </li><li>e) int *a[10]; // An array of 10 pointers to integers </li><li>f) int (*a)[10]; // A pointer to an array of 10 integers </li><li>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer </li><li>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer </li></ul><blockquote><p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？</p></blockquote><h1 id="四、Static"><a href="#四、Static" class="headerlink" title="四、Static"></a>四、Static</h1><p>&emsp;&emsp;关键字static的作用是什么？<br>&emsp;&emsp;这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：</p><ul><li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li><li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li><li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>  大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。</li></ul><h1 id="五、Const"><a href="#五、Const" class="headerlink" title="五、Const"></a>五、Const</h1><p>&emsp;&emsp;关键字const有什么含意？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于限定一个变量为只读</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我只要一听到被面试者说：”const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着”只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）<br>&emsp;&emsp;如果应试者能正确回答这个问题，我将问他一个附加的问题：<br>&emsp;&emsp;下面的声明都是什么意思？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><ul><li>前两个的作用是一样，a是一个常整型数。</li><li>第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。</li><li>第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。</li><li>最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</li></ul><blockquote><p>如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：</p></blockquote><ul><li>关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</li><li>通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</li><li>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</li></ul><h1 id="六、Volatile"><a href="#六、Volatile" class="headerlink" title="六、Volatile"></a>六、Volatile</h1><p>&emsp;&emsp;关键字volatile有什么含意?并给出三个不同的例子。<br>&emsp;&emsp;一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><ul><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li><li>多线程应用中被几个任务共享的变量<br>&emsp;&emsp;回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。<br>&emsp;&emsp;假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。</li><li>一个参数既可以是const还可以是volatile吗？解释为什么。</li><li>一个指针可以是volatile 吗？解释为什么。</li><li>下面的函数有什么错误：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;下面是答案：</p><ul><li>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</li><li>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</li><li>这段代码有点变态。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    b = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、位操作（Bit-manipulation）"><a href="#七、位操作（Bit-manipulation）" class="headerlink" title="七、位操作（Bit manipulation）"></a>七、位操作（Bit manipulation）</h1><p>&emsp;&emsp;嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。<br>&emsp;&emsp;对这个问题有三种基本的反应:</p><ul><li>不知道如何下手。该被面者从没做过任何嵌入式系统的工作。</li><li>用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。</li><li>用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。<br>最佳的解决方案如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1 &lt;&lt; 3)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a |= BIT3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。</p><h1 id="八、访问固定的内存位置（Accessing-fixed-memory-locations）"><a href="#八、访问固定的内存位置（Accessing-fixed-memory-locations）" class="headerlink" title="八、访问固定的内存位置（Accessing fixed memory locations）"></a>八、访问固定的内存位置（Accessing fixed memory locations）</h1><p>&emsp;&emsp;嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span>;</span><br><span class="line">*ptr = <span class="number">0xaa55</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;A more obscure approach is:<br>&emsp;&emsp;一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><h1 id="九、中断（Interrupts）"><a href="#九、中断（Interrupts）" class="headerlink" title="九、中断（Interrupts）"></a>九、中断（Interrupts）</h1><p>&emsp;&emsp;中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nArea = %f"</span>, area);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数有太多的错误了，以至让人不知从何说起了：</p><ul><li>ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。</li><li>ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</li><li>在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。</li><li>与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</li></ul><blockquote><p>重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这 样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。</p></blockquote><h1 id="十、代码例子（Code-examples）"><a href="#十、代码例子（Code-examples）" class="headerlink" title="十、代码例子（Code examples）"></a>十、代码例子（Code examples）</h1><p>12 . 下面的代码输出是什么，为什么？</p><pre><code>void foo(void){    unsigned int a = 6;    int b = -20;    (a+b &gt; 6) ? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;);}</code></pre><p>&emsp;&emsp;这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p><ol start="13"><li>评价下面的代码片断：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = <span class="number">0xFFFF</span>; </span><br><span class="line"><span class="comment">/*1's complement of zero */</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = ~<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。<br>&emsp;&emsp;到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…</p><h1 id="十一、动态内存分配（Dynamic-memory-allocation）"><a href="#十一、动态内存分配（Dynamic-memory-allocation）" class="headerlink" title="十一、动态内存分配（Dynamic memory allocation）"></a>十一、动态内存分配（Dynamic memory allocation）</h1><p>&emsp;&emsp;尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所以回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> ((ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a null pointer"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a valid pointer"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p><h1 id="十二、Typedef"><a href="#十二、Typedef" class="headerlink" title="十二、Typedef"></a>十二、Typedef</h1><p>&emsp;&emsp;Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dPS struct s *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">tPS</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？<br>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dPS p1,p2;</span><br><span class="line">tPS p3,p4;</span><br></pre></td></tr></table></figure><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span>  <span class="comment">//宏定义的只对就近的那个生效</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。</p><h1 id="十三、晦涩的语法"><a href="#十三、晦涩的语法" class="headerlink" title="十三、晦涩的语法"></a>十三、晦涩的语法</h1><p>&emsp;&emsp;C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是，它会做些什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>, c;</span><br><span class="line">c = a+++b;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a++ + b;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此, 这段代码持行后a = 6, b = 7, c = 12。<br>&emsp;&emsp;如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。</p><h1 id="十四、递增-amp-减运算符：-amp-–"><a href="#十四、递增-amp-减运算符：-amp-–" class="headerlink" title="十四、递增&amp;减运算符：++ &amp; –"></a>十四、递增&amp;减运算符：++ &amp; –</h1><p>&emsp;&emsp;紧凑的代码让程序更为整洁，通常其生成的机器代码效率更高。<br>&emsp;&emsp;递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)：</p><h2 id="出现在其作用的变量前面—前缀模式-a"><a href="#出现在其作用的变量前面—前缀模式-a" class="headerlink" title="++出现在其作用的变量前面—前缀模式(++a)"></a>++出现在其作用的变量前面—前缀模式(++a)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = <span class="number">2</span>*++a;</span><br></pre></td></tr></table></figure><ul><li>首先，a递增1；</li><li>然后，2乘以a，并将结果赋给q</li></ul><h2 id="出现在其作用的变量后面—后缀模式-a"><a href="#出现在其作用的变量后面—后缀模式-a" class="headerlink" title="++出现在其作用的变量后面—后缀模式(a++)"></a>++出现在其作用的变量后面—后缀模式(a++)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = <span class="number">2</span>*a++;</span><br></pre></td></tr></table></figure><ul><li>首先，2乘以a，并将结果赋给q；</li><li>然后，a递增1</li></ul><blockquote><p>出现在其作用的变量前面—前缀模式(–a)<br>出现在其作用的变量后面—后缀模式(a–)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/cover/learn.jpg&quot; alt=&quot;learn&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、预处理器（Preprocessor）&quot;&gt;&lt;a href=&quot;#一、预处理器（Preprocessor）&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之shell</title>
    <link href="https://zhouyuebiao.cn/2019/08/29/0033-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bshell/"/>
    <id>https://zhouyuebiao.cn/2019/08/29/0033-Linux搬砖三剑客之shell/</id>
    <published>2019-08-29T03:22:02.000Z</published>
    <updated>2019-08-29T06:14:48.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/shell/shell-logo.jpg" alt="linux-shell"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;这里讨论的shell，基于Bourne shell（默认shell）</p><h1 id="shell的特殊变量"><a href="#shell的特殊变量" class="headerlink" title="shell的特殊变量"></a>shell的特殊变量</h1><table><thead><tr><th align="center">特殊变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">$0</td><td align="center">当前脚本的文件名。</td></tr><tr><td align="center">$n</td><td align="center">这些变量对应于调用脚本的参数。这里n是对应于参数位置的正十进制数（第一个参数是$ 1，第二个参数是$ 2，依此类推）。</td></tr><tr><td align="center">$#</td><td align="center">提供给脚本的参数数量。</td></tr><tr><td align="center">$*</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ *相当于$ 1 $ 2。</td></tr><tr><td align="center">$@</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ @相当于$ 1 $ 2。</td></tr><tr><td align="center">$?</td><td align="center">执行最后一个命令的退出状态。退出状态是每个命令完成后返回的数值。通常，大多数命令如果成功则返回退出状态0，如果不成功则返回1。</td></tr><tr><td align="center">$$</td><td align="center">当前shell的进程号。对于shell脚本，这是它们执行的进程ID。</td></tr><tr><td align="center">$!</td><td align="center">最后一个后台命令的进程号。</td></tr></tbody></table><blockquote><p>$ *和$ @两者的行为相同，除非它们用双引号括起来，“”。这两个参数都指定命令行参数。但是，“$ *”特殊参数将整个列表作为一个参数，其间带有空格，“$ @”特殊参数获取整个列表并将其分隔为单独的参数。</p></blockquote><h1 id="shell的运算符"><a href="#shell的运算符" class="headerlink" title="shell的运算符"></a>shell的运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">（加法）在运算符的任一侧添加值</td><td align="center"><code>expr $a + $b</code> 将给出30</td></tr><tr><td align="center">-</td><td align="center">（减法）从左手操作数中减去右手操作数</td><td align="center"><code>expr $a - $b</code> 将给-10</td></tr><tr><td align="center">*</td><td align="center">（乘法）将运算符两侧的值相乘</td><td align="center"><code>expr $a \* $b</code> 将给出200</td></tr><tr><td align="center">/</td><td align="center">（除法）用左手操作数除左手操作数</td><td align="center"><code>expr $b / $a</code> 将给出2</td></tr><tr><td align="center">%</td><td align="center">（取模）用左手操作数除左手操作数并返回余数</td><td align="center"><code>expr $b ％ $a</code> 将给出0</td></tr><tr><td align="center">=</td><td align="center">（赋值）在左操作数中指定右操作数</td><td align="center">a = $b 会将b的值赋给a</td></tr><tr><td align="center">==</td><td align="center">（等于）比较两个数字，如果两个数字相同则返回true。</td><td align="center">[ $a == $b ] 会返回false。</td></tr><tr><td align="center">!=</td><td align="center">（不等于）比较两个数字，如果两个数字不同则返回true。</td><td align="center">[ $a != $b ] 会返回true。</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a -eq $b ] is not true.</td></tr><tr><td align="center">-ne</td><td align="center">检查两个操作数的值是否相等; 如果值不相等，则条件成立。</td><td align="center">[ $a -ne $b ] is true.</td></tr><tr><td align="center">-gt</td><td align="center">检查左操作数的值是否大于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -gt $b ] is not true.</td></tr><tr><td align="center">-lt</td><td align="center">检查左操作数的值是否小于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -lt $b ] is true.</td></tr><tr><td align="center">-ge</td><td align="center">检查左操作数的值是否大于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -ge $b ] is not true.</td></tr><tr><td align="center">-le</td><td align="center">检查左操作数的值是否小于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">$a -le $b ] is true.</td></tr></tbody></table><blockquote><p>所有条件表达式应放在方括号内并且周围有空格是非常重要的。例如，[ $a &lt;= $b ]是正确的，而[$a&lt;=$b]是不正确的。</p></blockquote><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">这是合乎逻辑的否定。这将真实条件反转为假，反之亦然。</td><td align="center">[ ! false ] is true.</td></tr><tr><td align="center">-o</td><td align="center">这是合乎逻辑的OR。如果其中一个操作数为true，则条件成立。</td><td align="center">[ $a -lt 20 -o $b -gt 100 ] is true.</td></tr><tr><td align="center">-a</td><td align="center">这是合乎逻辑的和。如果两个操作数都为真，则条件变为true，否则为false。</td><td align="center">[ $a -lt 20 -a $b -gt 100 ] is false.</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>&emsp;&emsp;示例中,假设变量a为“abc”，而变量b为“efg”。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a = $b ] is not true.</td></tr><tr><td align="center">!=</td><td align="center">检查两个操作数的值是否相等; 如果值不相等则条件变为真。</td><td align="center">[ $a != $b ] is true.</td></tr><tr><td align="center">-z</td><td align="center">检查给定的字符串操作数大小是否为零; 如果长度为零，则返回true。</td><td align="center">[ -z $a ] is not true.</td></tr><tr><td align="center">-n</td><td align="center">检查给定的字符串操作数大小是否为非零; 如果它是非零长度，则返回true。</td><td align="center">[ -n $a ] is not false.</td></tr><tr><td align="center">str</td><td align="center">检查str是否不是空字符串; 如果它是空的，则返回false。</td><td align="center">[ $a ] is not false.</td></tr></tbody></table><h2 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h2><p>&emsp;&emsp;这些运算符可用于测试与Unix文件相关的各种属性。<br>&emsp;&emsp;示例中，假设变量文件包含现有文件名“test”，其大小为100字节，并具有读取，写入和执行权限。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="center">检查文件是否是块特殊文件; 如果是，则条件成立。</td><td align="center">[ -b $file ] is false</td></tr><tr><td align="center">-c file</td><td align="center">检查文件是否是字符特殊文件; 如果是，则条件成立。</td><td align="center">[ -c $file ] is false.</td></tr><tr><td align="center">-d file</td><td align="center">检查文件是否是目录; 如果是，则条件成立。</td><td align="center">[ -d $file ] is not true.</td></tr><tr><td align="center">-f file</td><td align="center">检查文件是普通文件而不是目录或特殊文件; 如果是，则条件成立。</td><td align="center">[ -f $file ] is true.</td></tr><tr><td align="center">-g file</td><td align="center">检查文件是否设置了组ID（SGID）位; 如果是，则条件成立。</td><td align="center">[ -g $file ] is false.</td></tr><tr><td align="center">-k file</td><td align="center">检查文件是否设置了粘滞位; 如果是，则条件成立。</td><td align="center">[ -k $file ] is false.</td></tr><tr><td align="center">-p file</td><td align="center">检查文件是否是命名管道; 如果是，则条件成立。</td><td align="center">[ -p $file ] is false.</td></tr><tr><td align="center">-t file</td><td align="center">检查文件描述符是否打开并与终端关联; 如果是，则条件成立。</td><td align="center">[ -t $file ] is false.</td></tr><tr><td align="center">-u file</td><td align="center">检查文件是否设置了其用户ID（SUID）位; 如果是，则条件成立。</td><td align="center">[ -u $file ] is false.</td></tr><tr><td align="center">-r file</td><td align="center">检查文件是否可读; 如果是，则条件成立。</td><td align="center">[ -r $file ] is true.</td></tr><tr><td align="center">-w file</td><td align="center">检查文件是否可写; 如果是，则条件成立。</td><td align="center">[ -w $file ] is true.</td></tr><tr><td align="center">-x file</td><td align="center">检查文件是否可执行; 如果是，则条件成立。</td><td align="center">[ -x $file ] is true.</td></tr><tr><td align="center">-s file</td><td align="center">检查文件的大小是否大于0; 如果是，则条件成立。</td><td align="center">[ -s $file ] is true.</td></tr><tr><td align="center">-e file</td><td align="center">检查文件是否存在; 即使file是目录但存在，也是如此。</td><td align="center">[ -e $file ] is true.</td></tr></tbody></table><h1 id="shell修炼秘籍"><a href="#shell修炼秘籍" class="headerlink" title="shell修炼秘籍"></a>shell修炼秘籍</h1><h2 id="shell命令图谱"><a href="#shell命令图谱" class="headerlink" title="shell命令图谱"></a>shell命令图谱</h2><p><img src="/images/shell/Linux-shell-commands.png" alt="Linux-shell-commands"></p><h1 id="shell的种类"><a href="#shell的种类" class="headerlink" title="shell的种类"></a>shell的种类</h1><p><img src="/images/shell/shells.svg" alt="shells"></p><p>&emsp;&emsp;shell是一个用户终端，是内核与用户之间的翻译官。内核解释shell翻译过来的用户命令从而指挥CPU和其他计算机硬件如何执行特定任务。<br>每次用户登录时，都会启动shell。shell的类型取决于用户的选择，在大多数情况下默认设置为bash。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>&emsp;&emsp;Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell，它是用户帐户最常见的默认shell。</p><h2 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h2><p>&emsp;&emsp;C Shell被创造的Bill Joy在加州大学伯克利分校。他的主要目的是使用类似C语言的语法创建一个shell。因此，它包括控制结构和表达式语法之类的功能。<br>&emsp;&emsp;其他功能包括历史记录和编辑机制，别名，目录堆栈，代字符表示法，cdpath，作业控制和路径哈希等等。</p><h2 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h2><p>&emsp;&emsp;将tcsh被开发成为与C shell兼容。t in tcsh来自TENEX，这是一个操作系统。<br>&emsp;&emsp;tcsh与csh命令行编辑和其他功能等扩展非常接近。Mac OS X以前是tcsh默认配置，但在版本10.3中切换为bash。</p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>&emsp;&emsp;Z shell是专为交互式使用而设计的。<br>&emsp;&emsp;Z shell的一些功能包括拼写检查，在单个缓冲区中编辑多行命令，改进的变量和数组处理，自定义，可编程命令行完成和可主题提示。</p><h2 id="还有很多甚至更多"><a href="#还有很多甚至更多" class="headerlink" title="还有很多甚至更多"></a>还有很多甚至更多</h2><p>&emsp;&emsp;还有很多shell可供选择！当我们了解有关终端和shell的更多信息时，可能希望升级到另一个shell。但是一般而言，bash已经很好地满足我们的需求了。</p><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 90%;}</style><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 65%;}table th:nth-of-type(3){width: 25%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/shell/shell-logo.jpg&quot; alt=&quot;linux-shell&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="shell" scheme="https://zhouyuebiao.cn/categories/shell/"/>
    
    
      <category term="shell" scheme="https://zhouyuebiao.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之vi&amp;vim</title>
    <link href="https://zhouyuebiao.cn/2019/08/28/0032-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bvi&amp;vim/"/>
    <id>https://zhouyuebiao.cn/2019/08/28/0032-Linux搬砖三剑客之vi&amp;vim/</id>
    <published>2019-08-28T03:40:30.000Z</published>
    <updated>2019-09-19T08:52:53.783Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vi&vim/vi&vimlog.png" alt="vi&amp;vimlog"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不可不知的两大编辑器：</p><ul><li>编辑器之神——Vim</li><li>神之编辑器——Emacs</li></ul><p>&emsp;&emsp;有趣的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a>。</p><p>&emsp;&emsp;vim与神的编辑器emacs的争论从来没有停止过。两种编辑器的设计哲学完全不同，风格迥异。vim的特点是Composability（组合性），Emacs的特点是Extensibility（可扩展性）。vim使用键序列输入，Emacs则经常使用组合键（同时按）输入，所以Emacs有个绰号Esc + Meta + Alt + Ctrl + Shift。正因为各种显著的差异各种争论在所难免，对此我们应该端正自己的心态：提高自己的格局，少一些争论。</p><h1 id="磨刀不误砍柴工"><a href="#磨刀不误砍柴工" class="headerlink" title="磨刀不误砍柴工"></a>磨刀不误砍柴工</h1><p>&emsp;&emsp;不做无谓的争论，工欲善其事必先利其器，我们只管选择一种自己顺手的工具（我选择vi&amp;vim）来学习，不断深入学习，提高自己的同时，不断与工具磨合，早日达到人剑合一的境界，笑看江湖。<br><img src="/images/vi&vim/huaji.jpg" alt="huaji"></p><h2 id="进入vim的姿势"><a href="#进入vim的姿势" class="headerlink" title="进入vim的姿势"></a>进入vim的姿势</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">vim filename</td><td align="center">打开或新建文件，并将光标置于第一行首</td></tr><tr><td align="center">vim +num filename</td><td align="center">打开文件，并将光标置于第n行首</td></tr><tr><td align="center">vim + filename</td><td align="center">打开文件，并将光标置于最后一行首</td></tr><tr><td align="center">vim +/pattern filename</td><td align="center">打开文件，并将光标置于第一个与pattern匹配的串处</td></tr><tr><td align="center">vim -r filename</td><td align="center">在上次正用vim编辑时发生系统崩溃，恢复filename</td></tr><tr><td align="center">vim filenae1…filenamen</td><td align="center">打开多个文件，依次编辑</td></tr></tbody></table><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">列出所有选项设置情况</td></tr><tr><td align="center">term</td><td align="center">设置终端类型</td></tr><tr><td align="center">ignorance</td><td align="center">在搜索中忽略大小写</td></tr><tr><td align="center">list</td><td align="center">显示制表位（Ctrl+1）和行尾标志（$）显示行号</td></tr><tr><td align="center">number</td><td align="center">显示由面向行的命令修改过的数目</td></tr><tr><td align="center">report</td><td align="center">显示简短的警告信息</td></tr><tr><td align="center">terse</td><td align="center">在转到别的文件时若没保存当前文件则显示NO write信息</td></tr><tr><td align="center">nomagic</td><td align="center">允许在搜索模式中，使用前面不带“V的特殊字符</td></tr><tr><td align="center">nowrapscan</td><td align="center">禁止vi在搜索到达文件两端时，又从另一端开始</td></tr><tr><td align="center">mesg</td><td align="center">允许vi显示其他用户用write写到自己终端上的信息</td></tr><tr><td align="center">:set number</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonumber</td><td align="center">不显示行号</td></tr><tr><td align="center">set ruler</td><td align="center">显示标尺</td></tr><tr><td align="center">set noruler</td><td align="center">不显示标尺</td></tr><tr><td align="center">:set hlsearch</td><td align="center">高亮显示查找到的单词</td></tr><tr><td align="center">:set nohlsearch</td><td align="center">关闭高亮显示</td></tr><tr><td align="center">:syntax on</td><td align="center">语法高亮显示行号</td></tr><tr><td align="center">:set tabstop=8</td><td align="center">设置tab大小，8为最常用最普遍的设置4.4个空格，8.正常的制表符，12:一个制表符4个空格，16.两个制表符</td></tr><tr><td align="center">:set autoindent</td><td align="center">自动缩进</td></tr><tr><td align="center">:set cindent</td><td align="center">C语言格式里面的自动缩进</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">k</td><td align="center">向上移动</td></tr><tr><td align="center">j</td><td align="center">向下移动</td></tr><tr><td align="center">h</td><td align="center">向左移动</td></tr><tr><td align="center">l</td><td align="center">向右移动</td></tr><tr><td align="center">k nk</td><td align="center">向上移动n行</td></tr><tr><td align="center">j nk</td><td align="center">向下移动n行</td></tr><tr><td align="center">h nh</td><td align="center">向左移动n行</td></tr><tr><td align="center">l nl</td><td align="center">向右移动n行</td></tr><tr><td align="center">Spach</td><td align="center">光标右移一个字符</td></tr><tr><td align="center">Backspace</td><td align="center">光标左移一个字符</td></tr><tr><td align="center">Enter</td><td align="center">光标下移一行</td></tr><tr><td align="center">w/W</td><td align="center">光标右移一个字至字首</td></tr><tr><td align="center">b/B</td><td align="center">光标左移一个字至字首</td></tr><tr><td align="center">e/e</td><td align="center">光标右移一个字至字尾</td></tr><tr><td align="center">)</td><td align="center">光标移至句尾</td></tr><tr><td align="center">(</td><td align="center">光标移至句首</td></tr><tr><td align="center">}</td><td align="center">光标移至段落开头</td></tr><tr><td align="center">{</td><td align="center">光标移至段落结尾</td></tr><tr><td align="center">n$</td><td align="center">光标移至第n行尾</td></tr><tr><td align="center">H</td><td align="center">光标移至屏幕顶行</td></tr><tr><td align="center">M</td><td align="center">光标移至屏幕中间行</td></tr><tr><td align="center">L</td><td align="center">光标移至屏幕最后行</td></tr><tr><td align="center">0</td><td align="center">（注意是数字零）光标移至当前行首</td></tr><tr><td align="center">^</td><td align="center">移动光标到行首第一个非空字符上去</td></tr><tr><td align="center">$</td><td align="center">光标移至当前行尾</td></tr><tr><td align="center">gg</td><td align="center">移到第一行</td></tr><tr><td align="center">G</td><td align="center">移到最后一行</td></tr><tr><td align="center">f</td><td align="center">移动光标到当前行的字符a上</td></tr><tr><td align="center">F</td><td align="center">与f相反</td></tr><tr><td align="center">%</td><td align="center">移动到与制匹配的括号上去（），}，Ⅱ，&lt;&gt;等</td></tr><tr><td align="center">nG</td><td align="center">移动到第n行上</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr></tbody></table><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+u</td><td align="center">向文件首翻半屏</td></tr><tr><td align="center">Ctrl+d</td><td align="center">向文件尾翻半屏</td></tr><tr><td align="center">Ctrl+f</td><td align="center">向文件尾翻一屏</td></tr><tr><td align="center">Ctrl+b</td><td align="center">向文件首翻一屏</td></tr><tr><td align="center">nz</td><td align="center">将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</td></tr></tbody></table><h2 id="插入文本类"><a href="#插入文本类" class="headerlink" title="插入文本类"></a>插入文本类</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">在光标前</td></tr><tr><td align="center">I</td><td align="center">在当前行首</td></tr><tr><td align="center">a</td><td align="center">光标后</td></tr><tr><td align="center">A</td><td align="center">在当前行尾</td></tr><tr><td align="center">o</td><td align="center">在当前行之下新开一行</td></tr><tr><td align="center">O</td><td align="center">在当前行之上新开一行</td></tr><tr><td align="center">r</td><td align="center">替换当前字符</td></tr><tr><td align="center">R</td><td align="center">替换当前字符及其后的字符，直至按ESC键</td></tr><tr><td align="center">s</td><td align="center">从当前光标位置处开始，以输入的文本替代指定数目的字符</td></tr><tr><td align="center">S</td><td align="center">删除指定数目的行，并以所输入文本代替之</td></tr><tr><td align="center">ncw/nCW</td><td align="center">修改指定数目的字</td></tr><tr><td align="center">nCC</td><td align="center">修改指定数目的行</td></tr></tbody></table><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x/X</td><td align="center">删除一个字符，x删除光标后的，而X删除光标前的</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词（删除光标位置到下一个单词开始的位置）</td></tr><tr><td align="center">dnw</td><td align="center">删除n个单词</td></tr><tr><td align="center">dne</td><td align="center">也可，只是删除到单词尾</td></tr><tr><td align="center">do</td><td align="center">删至行首</td></tr><tr><td align="center">d$</td><td align="center">删至行尾</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">ndd</td><td align="center">删除当前行及其后n-1行</td></tr><tr><td align="center">dnl</td><td align="center">向右删除n个字母</td></tr><tr><td align="center">dnh</td><td align="center">向左删除n个字母</td></tr><tr><td align="center">dnj</td><td align="center">向下删除n行，当前行+其上n行</td></tr><tr><td align="center">dnk</td><td align="center">向上删除n行，当期行+其下n行</td></tr><tr><td align="center">cnw[word]</td><td align="center">将n个word改变为word</td></tr><tr><td align="center">C$</td><td align="center">改变到行尾</td></tr><tr><td align="center">cc</td><td align="center">改变整行</td></tr><tr><td align="center">shift+j</td><td align="center">删除行尾的换行符，下一行接上来了</td></tr></tbody></table><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">粘贴用x或d删除的文本</td></tr><tr><td align="center">ynw</td><td align="center">复制n个单词</td></tr><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">ynl</td><td align="center">复制n个字符</td></tr><tr><td align="center">y$</td><td align="center">复制当前光标至行尾处</td></tr><tr><td align="center">nyy</td><td align="center">拷贝n行</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>|u          |撤销前一次的操作<br>|shif+u(U)  |撤销对该行的所有操作</p><h2 id="搜索及替换"><a href="#搜索及替换" class="headerlink" title="搜索及替换"></a>搜索及替换</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">/pattern</td><td align="center">从光标开始处向文件尾搜索pattern</td></tr><tr><td align="center">?pattern</td><td align="center">从光标开始处向文件首搜索pattern</td></tr><tr><td align="center">n</td><td align="center">在同一方向重复上一次搜索命令</td></tr><tr><td align="center">N</td><td align="center">在反方向上重复上一次搜索命令</td></tr><tr><td align="center">cw newword</td><td align="center">替换为newword</td></tr><tr><td align="center">n</td><td align="center">继续查找</td></tr><tr><td align="center">.</td><td align="center">执行替换</td></tr><tr><td align="center">:s/p1/p2/g</td><td align="center">将当前行中所有p1均用p2替代，g表示执行用c表示需要确认</td></tr><tr><td align="center">:n1,n2 s/p1/p2/g</td><td align="center">将第n1至n2行中所有p1均用p2替代</td></tr><tr><td align="center">:g/p1/s//p2/g</td><td align="center">将文件中所有p1均用p2替换</td></tr><tr><td align="center">:1,$ s/string1/string2/g</td><td align="center">在全文中将string1替换为string2</td></tr></tbody></table><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">,[a-z]</td><td align="center">在文中做标记，标记号可为a-z的26个字母</td></tr><tr><td align="center">`a</td><td align="center">移动到标记a处</td></tr></tbody></table><h2 id="visual模式"><a href="#visual模式" class="headerlink" title="visual模式"></a>visual模式</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">v</td><td align="center">进入visual模式</td></tr><tr><td align="center">V</td><td align="center">进入行的visual模式</td></tr><tr><td align="center">ctrl+V</td><td align="center">进如块操作模式用o和O改变选择的边的大小</td></tr><tr><td align="center">在所有行插入相同的内容如include&lt;</td><td align="center">将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按1（shit+），后插入要插入的文本，按IESC]完成</td></tr></tbody></table><h2 id="行方式命令"><a href="#行方式命令" class="headerlink" title="行方式命令"></a>行方式命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:n1,n2 co n3</td><td align="center">将n1行到n2行之间的内容拷贝到第n3行下</td></tr><tr><td align="center">:n1,n2 m n3</td><td align="center">将n1行到n2行之间的内容移至到第n3行下</td></tr><tr><td align="center">:n1,n2 d</td><td align="center">将n1行到n2行之间的内容删除</td></tr><tr><td align="center">:n1,n2 wlcommand</td><td align="center">将文件中n1行至n2行的内容作为command的输入并执行之</td></tr></tbody></table><blockquote><p>若不指定n1，n2，则表示将整个文件内容作为command的输入 |</p></blockquote><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">q[a-z]</td><td align="center">开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏</td></tr><tr><td align="center">reg</td><td align="center">显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]</td></tr></tbody></table><h2 id="操作窗口"><a href="#操作窗口" class="headerlink" title="操作窗口"></a>操作窗口</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:split</td><td align="center">分割一个窗口</td></tr><tr><td align="center">:split file.c</td><td align="center">为另一个文件fle.c分隔窗口</td></tr><tr><td align="center">:nsplit file.c</td><td align="center">为另一个文件file.c分隔窗口，并指定其行数</td></tr><tr><td align="center">ctrl + W</td><td align="center">在窗口中切换</td></tr><tr><td align="center">:close</td><td align="center">关闭当前窗口</td></tr></tbody></table><h2 id="文件及其他"><a href="#文件及其他" class="headerlink" title="文件及其他"></a>文件及其他</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:q退出vi</td><td align="center"></td></tr><tr><td align="center">:q!</td><td align="center">不保存文件并退出vi/vim</td></tr><tr><td align="center">:e filename</td><td align="center">打开文件filename进行编辑</td></tr><tr><td align="center">:e!</td><td align="center">放弃修改文件内容，重新载入该文件编辑</td></tr><tr><td align="center">:W</td><td align="center">保存当前文件</td></tr><tr><td align="center">:wq</td><td align="center">存盘后再退出</td></tr><tr><td align="center">:ZZ</td><td align="center">保存当前文档并退出vi/vim</td></tr><tr><td align="center">:!command</td><td align="center">执行shell命令command</td></tr><tr><td align="center">:r!command</td><td align="center">将命令command的输出结果放到当前行</td></tr><tr><td align="center">:n1,n2 write temp.c</td><td align="center"></td></tr><tr><td align="center">:read file.c</td><td align="center">将文件file.c的内容插入到当前光标所在的下面</td></tr></tbody></table><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><h2 id="寓教于乐"><a href="#寓教于乐" class="headerlink" title="寓教于乐"></a>寓教于乐</h2><p>&emsp;&emsp;<a href="https://vim-adventures.com/" target="_blank" rel="noopener">非常有趣的VIM学习小游戏。</a></p><h2 id="修炼秘籍-1"><a href="#修炼秘籍-1" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h2><h2 id="vim命令图解（中文版）"><a href="#vim命令图解（中文版）" class="headerlink" title="vim命令图解（中文版）"></a>vim命令图解（中文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-cn.png" alt="vim命令图解cn"></p><h2 id="vim命令图解（英文版）"><a href="#vim命令图解（英文版）" class="headerlink" title="vim命令图解（英文版）"></a>vim命令图解（英文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-en.png" alt="vim命令图解en"></p><h2 id="vim命令图解大全"><a href="#vim命令图解大全" class="headerlink" title="vim命令图解大全"></a>vim命令图解大全</h2><p>&emsp;&emsp;此图内容比较繁多，窃以为入门学习上面两个图足矣。<br><img src="/images/vi&vim/vim_cheat_sheet_for_programmers_screen.png" alt="vim命令图解大全"></p><p>&emsp;&emsp;当然，如果对此资源感兴趣，可前往<a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="noopener">此处获取</a>更全面的资源。</p><h2 id="其他未分类资源"><a href="#其他未分类资源" class="headerlink" title="其他未分类资源"></a>其他未分类资源</h2><p><img src="/images/vi&vim/preview.webp" alt="vim-preview"></p><p><img src="/images/vi&vim/vim-movement-commands-cheatsheet.png" alt="vim-movement-commands-cheatsheet"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>&emsp;&emsp;<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a></p><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vi&amp;vim/vi&amp;vimlog.png&quot; alt=&quot;vi&amp;amp;vimlog&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不可
      
    
    </summary>
    
      <category term="tools" scheme="https://zhouyuebiao.cn/categories/tools/"/>
    
    
      <category term="tools" scheme="https://zhouyuebiao.cn/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之git</title>
    <link href="https://zhouyuebiao.cn/2019/08/21/0031-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BGit/"/>
    <id>https://zhouyuebiao.cn/2019/08/21/0031-Linux搬砖三剑客之Git/</id>
    <published>2019-08-21T11:49:00.000Z</published>
    <updated>2019-08-29T07:53:42.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git/gswg-git-solid-choice.png" alt="gswg-git-solid-choice"></p><h1 id="git指令速查表"><a href="#git指令速查表" class="headerlink" title="git指令速查表"></a>git指令速查表</h1><p><img src="/images/git/git-cheat-sheet-large01-cn.png" alt="git指令速查表"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="复制一个已创建的仓库"><a href="#复制一个已创建的仓库" class="headerlink" title="复制一个已创建的仓库"></a>复制一个已创建的仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span></span><br></pre></td></tr></table></figure><h3 id="创建一个新的本地仓库"><a href="#创建一个新的本地仓库" class="headerlink" title="创建一个新的本地仓库"></a>创建一个新的本地仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><h3 id="显示工作路径下全部已修改的文件"><a href="#显示工作路径下全部已修改的文件" class="headerlink" title="显示工作路径下全部已修改的文件"></a>显示工作路径下全部已修改的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><h3 id="显示与上次提交版本文件的不同"><a href="#显示与上次提交版本文件的不同" class="headerlink" title="显示与上次提交版本文件的不同"></a>显示与上次提交版本文件的不同</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><h3 id="把当前所有修改添加到下次提交中"><a href="#把当前所有修改添加到下次提交中" class="headerlink" title="把当前所有修改添加到下次提交中"></a>把当前所有修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><h3 id="指定某个文件的修改添加到下次提交中"><a href="#指定某个文件的修改添加到下次提交中" class="headerlink" title="指定某个文件的修改添加到下次提交中"></a>指定某个文件的修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="提交本地的所有修改"><a href="#提交本地的所有修改" class="headerlink" title="提交本地的所有修改"></a>提交本地的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><h3 id="提交之前已标记的变化"><a href="#提交之前已标记的变化" class="headerlink" title="提交之前已标记的变化"></a>提交之前已标记的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br></pre></td></tr></table></figure><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><h3 id="从最新提交开始显示所有的提交记录"><a href="#从最新提交开始显示所有的提交记录" class="headerlink" title="从最新提交开始显示所有的提交记录"></a>从最新提交开始显示所有的提交记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><h3 id="显示指定文件的所有修改"><a href="#显示指定文件的所有修改" class="headerlink" title="显示指定文件的所有修改"></a>显示指定文件的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="谁，在什么时间，修改了文件的什么内容？"><a href="#谁，在什么时间，修改了文件的什么内容？" class="headerlink" title="谁，在什么时间，修改了文件的什么内容？"></a>谁，在什么时间，修改了文件的什么内容？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><h3 id="显示所有分支"><a href="#显示所有分支" class="headerlink" title="显示所有分支"></a>显示所有分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -av</span></span><br></pre></td></tr></table></figure><h3 id="切换当前分支"><a href="#切换当前分支" class="headerlink" title="切换当前分支"></a>切换当前分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于当前分支，创建新分支"><a href="#基于当前分支，创建新分支" class="headerlink" title="基于当前分支，创建新分支"></a>基于当前分支，创建新分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;new-branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于远端分支，创建新的可追溯的分支"><a href="#基于远端分支，创建新的可追溯的分支" class="headerlink" title="基于远端分支，创建新的可追溯的分支"></a>基于远端分支，创建新的可追溯的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="给当前的提交打标签"><a href="#给当前的提交打标签" class="headerlink" title="给当前的提交打标签"></a>给当前的提交打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h2><h3 id="列出当前配置的远端"><a href="#列出当前配置的远端" class="headerlink" title="列出当前配置的远端"></a>列出当前配置的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><h3 id="显示远端信息"><a href="#显示远端信息" class="headerlink" title="显示远端信息"></a>显示远端信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加新的远端"><a href="#添加新的远端" class="headerlink" title="添加新的远端"></a>添加新的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载远端的所有改动到本地，不会自动合并到当前"><a href="#下载远端的所有改动到本地，不会自动合并到当前" class="headerlink" title="下载远端的所有改动到本地，不会自动合并到当前"></a>下载远端的所有改动到本地，不会自动合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将本地版本发布到远端"><a href="#将本地版本发布到远端" class="headerlink" title="将本地版本发布到远端"></a>将本地版本发布到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除远端分支"><a href="#删除远端分支" class="headerlink" title="删除远端分支"></a>删除远端分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签"></a>发布标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><h2 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h2><h3 id="将分支合并到当前"><a href="#将分支合并到当前" class="headerlink" title="将分支合并到当前"></a>将分支合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将当前版本充值到分支中"><a href="#将当前版本充值到分支中" class="headerlink" title="将当前版本充值到分支中"></a>将当前版本充值到分支中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebse &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请勿重置已发布的提交！</p></blockquote><h3 id="退出重置"><a href="#退出重置" class="headerlink" title="退出重置"></a>退出重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突后继续重置"><a href="#解决冲突后继续重置" class="headerlink" title="解决冲突后继续重置"></a>解决冲突后继续重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><h3 id="使用配置好的合并工具去解决冲突"><a href="#使用配置好的合并工具去解决冲突" class="headerlink" title="使用配置好的合并工具去解决冲突"></a>使用配置好的合并工具去解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure><h3 id="在编辑器中手动解决冲去后，标记文件未已解决冲突"><a href="#在编辑器中手动解决冲去后，标记文件未已解决冲突" class="headerlink" title="在编辑器中手动解决冲去后，标记文件未已解决冲突"></a>在编辑器中手动解决冲去后，标记文件未已解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;resolved-file&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;resolved-file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="放弃工作目录下的所有修改"><a href="#放弃工作目录下的所有修改" class="headerlink" title="放弃工作目录下的所有修改"></a>放弃工作目录下的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD</span></span><br></pre></td></tr></table></figure><h3 id="放弃某个文件的所有本地修改"><a href="#放弃某个文件的所有本地修改" class="headerlink" title="放弃某个文件的所有本地修改"></a>放弃某个文件的所有本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过创建一个截然不同的新的提交重置一个提交"><a href="#通过创建一个截然不同的新的提交重置一个提交" class="headerlink" title="通过创建一个截然不同的新的提交重置一个提交"></a>通过创建一个截然不同的新的提交重置一个提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"><a href="#将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"></a>将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"><a href="#将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"></a>将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"><a href="#将HEAD重置到上一次提交的版本，并保留未提交的本地修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"></a>将HEAD重置到上一次提交的版本，并保留未提交的本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h1 id="git信条"><a href="#git信条" class="headerlink" title="git信条"></a>git信条</h1><p><img src="/images/git/git-cheat-sheet-large02-cn.png" alt="git信条"></p><h2 id="提交要对应修改"><a href="#提交要对应修改" class="headerlink" title="提交要对应修改"></a>提交要对应修改</h2><p>&emsp;&emsp;一次提交应该对应一个相关的改动，例如，两个不同的错误应该对应两次不同的提交、使它更容易让其他开发人员明白这个改动，如果这次改动存在问题，也可以方便的回滚到改动之前的状态，通过需存区标记功能。Git可以轻松打造非常精确的提交。</p><h2 id="经常性地提交修改"><a href="#经常性地提交修改" class="headerlink" title="经常性地提交修改"></a>经常性地提交修改</h2><p>&emsp;&emsp;经常的提交改动可以更方便为它作注释。从而更容易确保提交的注释和改动的一致性，通过频繁快速的提交来与其他的开发人员共享这些改动。那样就会避免或减少代码整合时带来的冲突、反之，非常庞大的提交将会增大整合时出现冲突的风险。</p><h2 id="不提交不完整地改动"><a href="#不提交不完整地改动" class="headerlink" title="不提交不完整地改动"></a>不提交不完整地改动</h2><p>&emsp;&emsp;对于一个很大的功能模块来说.完成后再提交并不意味若必须整体完成后才可以，而是要把它正确分割成小的完整的逻辑模块进行经常性的提变，一定不要提交一些不完整的改动。仅仅是因为下班。<br>&emsp;&emsp;同祥，如果只是为了得到一个干净的工作区城也不需要立即提交，可以通过Git的&lt;<stash>&gt;命令把这些改动移到另外的分支。</stash></p><h2 id="提交前进行代码测试"><a href="#提交前进行代码测试" class="headerlink" title="提交前进行代码测试"></a>提交前进行代码测试</h2><p>&emsp;&emsp;不要提交还没有经过完整测试的改动。只有经过测试，并确定无误的改动才能提交。把改动发送给开发团队其他成员前，必须确定所有修改已经完整测试过。这样才算是真正的完成。</p><h2 id="高质量地提交注释"><a href="#高质量地提交注释" class="headerlink" title="高质量地提交注释"></a>高质量地提交注释</h2><p>&emsp;&emsp;提交注释的开头需要一个少于50个字的简短说明.在一个空白的分割行之后要写出一个详细的提交细节.比如回答如下的两个问题；</p><ul><li>出于什么理由需要这个修改？</li><li>基于当前版本.具体改动了什么？</li></ul><p>&emsp;&emsp;为了和自动生成的注释保持一致（例如：git merge），一定要使用现在时态祈使句（比如使用change 而不要使用changed和changes）.</p><h2 id="版本控制不是备份"><a href="#版本控制不是备份" class="headerlink" title="版本控制不是备份"></a>版本控制不是备份</h2><p>&emsp;&emsp;版本控制系统具有一个很强大的附带功能，那就是服务器端的备份功能，但是不要把VCS当成一个备份系统。一定要注意.只需要提交那些有意义的改动而不要仅仅作为文件存储系统来使用。</p><h2 id="使用分支功能"><a href="#使用分支功能" class="headerlink" title="使用分支功能"></a>使用分支功能</h2><p>&emsp;&emsp;自始至终Git的核心就是提供一个快速，简单和灵活的分支功能，分支是一个非常优秀的工具，用来帮助开发人员解决在日常团队开发中存在的代码冲突的问题。因此分支功能应该广泛的运用在不同的开发流程中，比如：开发新的功能、修错等等。</p><h2 id="合理的工作流程"><a href="#合理的工作流程" class="headerlink" title="合理的工作流程"></a>合理的工作流程</h2><p>&emsp;&emsp;Git可以支持很多不同流程；长期分支.特性分支，合并或是重置，git-flow等等选择哪一种流程要取决于如下一些因素；什么项目，什么样的开发，部署模式和（可能是量重要的）开发团队人员的个人习惯.不管怎样。选择什么样的流程都要得到所用开发人员的认同并且一直遭循它</p><h2 id="使用帮助文档"><a href="#使用帮助文档" class="headerlink" title="使用帮助文档"></a>使用帮助文档</h2><p>&emsp;&emsp;显示给定git指令的帮助文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><p><a href="http://www.git-tower.com/learn" target="_blank" rel="noopener">http://www.git-tower.com/learn</a><br><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/</a><br><a href="http://www.git-scm.org/" target="_blank" rel="noopener">http://www.git-scm.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/git/gswg-git-solid-choice.png&quot; alt=&quot;gswg-git-solid-choice&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;git指令速查表&quot;&gt;&lt;a href=&quot;#git指令速查表&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="tools" scheme="https://zhouyuebiao.cn/categories/tools/"/>
    
    
      <category term="git" scheme="https://zhouyuebiao.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android系统的编译</title>
    <link href="https://zhouyuebiao.cn/2019/08/16/0030-Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E8%AF%91/"/>
    <id>https://zhouyuebiao.cn/2019/08/16/0030-Android系统的编译/</id>
    <published>2019-08-16T01:16:12.000Z</published>
    <updated>2019-09-04T01:36:20.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_m_marshmallow.jpg" alt="android_m_marshmallow"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="noopener">http://source.android.com/source/initializing.html</a></p><h1 id="Android模块编译流程"><a href="#Android模块编译流程" class="headerlink" title="Android模块编译流程"></a>Android模块编译流程</h1><p>&emsp;&emsp;在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易。</p><h2 id="第一步使build-envsetup-sh生效"><a href="#第一步使build-envsetup-sh生效" class="headerlink" title="第一步使build/envsetup.sh生效"></a>第一步使build/envsetup.sh生效</h2><p>&emsp;&emsp;命令“source build/envsetup.sh”引入了 build/envsetup.sh脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> . build/envsetup.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> build/envsetup.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>envsetup.sh脚本文件里包含vendorsetup.sh 、lunch、 m mm mmm的定义</p></blockquote><h2 id="第二步选择编译类型"><a href="#第二步选择编译类型" class="headerlink" title="第二步选择编译类型"></a>第二步选择编译类型</h2><p>&emsp;&emsp;lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。编译类型会影响最终系统中包含的模块。<br>&emsp;&emsp;如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，此时可以通过输入编号或者名称进行选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lunch full</span><br><span class="line"># 或者</span><br><span class="line">$ lunch &lt;选择一个特定的编译类型&gt;</span><br></pre></td></tr></table></figure><h2 id="最后一步make"><a href="#最后一步make" class="headerlink" title="最后一步make"></a>最后一步make</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里，make的选择有多种，具体内容分到下小节讨论。</p><blockquote><p>make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。</p></blockquote><h2 id="最最后一步清理编译结果"><a href="#最最后一步清理编译结果" class="headerlink" title="最最后一步清理编译结果"></a>最最后一步清理编译结果</h2><h3 id="清理所有编译结果"><a href="#清理所有编译结果" class="headerlink" title="清理所有编译结果"></a>清理所有编译结果</h3><p>&emsp;&emsp;执行清理，相当于：rm -rf out/。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean</span></span><br></pre></td></tr></table></figure><h3 id="清理一个指定模块的编译结果。"><a href="#清理一个指定模块的编译结果。" class="headerlink" title="清理一个指定模块的编译结果。"></a>清理一个指定模块的编译结果。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean-&lt;local_target&gt;</span></span><br></pre></td></tr></table></figure><h1 id="关于make的更多选项"><a href="#关于make的更多选项" class="headerlink" title="关于make的更多选项"></a>关于make的更多选项</h1><p>&emsp;&emsp;以下编译的编译选项可加上 “-j &lt;线程数&gt;”来启动多线程编译，加快编译的速度。</p><h2 id="编译当前选定产品的OTA全量包"><a href="#编译当前选定产品的OTA全量包" class="headerlink" title="编译当前选定产品的OTA全量包"></a>编译当前选定产品的OTA全量包</h2><p>&emsp;&emsp;也叫整包编译(all partitions)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make otapackage</span></span><br></pre></td></tr></table></figure><h2 id="编译所有内容"><a href="#编译所有内容" class="headerlink" title="编译所有内容"></a>编译所有内容</h2><p>&emsp;&emsp;编译所有内容，不管当前产品的定义中是否会包含。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure><h2 id="编译boot-img"><a href="#编译boot-img" class="headerlink" title="编译boot.img"></a>编译boot.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make bootimage</span></span><br></pre></td></tr></table></figure><h2 id="编译uboot-bin"><a href="#编译uboot-bin" class="headerlink" title="编译uboot.bin"></a>编译uboot.bin</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./mk &lt;uboot对应的版本&gt;  --systemroot</span></span><br></pre></td></tr></table></figure><h2 id="编译-recovery-img-ramdisk-recovery-img"><a href="#编译-recovery-img-ramdisk-recovery-img" class="headerlink" title="编译 recovery.img(ramdisk-recovery.img)"></a>编译 recovery.img(ramdisk-recovery.img)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make recoveryimage</span></span><br></pre></td></tr></table></figure><h2 id="编译vendor-img"><a href="#编译vendor-img" class="headerlink" title="编译vendor.img"></a>编译vendor.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make vendorimage</span></span><br></pre></td></tr></table></figure><h2 id="编译system-img"><a href="#编译system-img" class="headerlink" title="编译system.img"></a>编译system.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make systemimage</span></span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img"><a href="#编译-userdata-img" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make odm_image</span></span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img-1"><a href="#编译-userdata-img-1" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make userdataimage</span></span><br></pre></td></tr></table></figure><h2 id="编译ramdisk-img"><a href="#编译ramdisk-img" class="headerlink" title="编译ramdisk.img"></a>编译ramdisk.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make ramdisk</span></span><br></pre></td></tr></table></figure><h2 id="编译logo-img"><a href="#编译logo-img" class="headerlink" title="编译logo.img"></a>编译logo.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make logoimage</span></span><br></pre></td></tr></table></figure><h2 id="快速重建系统镜像"><a href="#快速重建系统镜像" class="headerlink" title="快速重建系统镜像"></a>快速重建系统镜像</h2><p>&emsp;&emsp;从已经编译出的包快速重建系统镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make snod</span></span><br></pre></td></tr></table></figure><h2 id="编译-dtb"><a href="#编译-dtb" class="headerlink" title="编译 dtb"></a>编译 dtb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make dtbimage</span></span><br></pre></td></tr></table></figure><h2 id="编译出-Android-的-SDK"><a href="#编译出-Android-的-SDK" class="headerlink" title="编译出 Android 的 SDK"></a>编译出 Android 的 SDK</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make sdk</span></span><br></pre></td></tr></table></figure><h2 id="编译所有-JNI-framework"><a href="#编译所有-JNI-framework" class="headerlink" title="编译所有 JNI framework"></a>编译所有 JNI framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make libandroid_runtime</span></span><br></pre></td></tr></table></figure><h2 id="编译所有-Java-framework"><a href="#编译所有-Java-framework" class="headerlink" title="编译所有 Java framework"></a>编译所有 Java framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make framework</span></span><br></pre></td></tr></table></figure><h2 id="编译系统服务和相关内容"><a href="#编译系统服务和相关内容" class="headerlink" title="编译系统服务和相关内容"></a>编译系统服务和相关内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make services</span></span><br></pre></td></tr></table></figure><h2 id="编译指定模块"><a href="#编译指定模块" class="headerlink" title="编译指定模块"></a>编译指定模块</h2><p>&emsp;&emsp;编译一个指定的模块，local_target 为模块的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make &lt;local_target&gt;</span></span><br></pre></td></tr></table></figure><h2 id="获取所有产品的编译配置信息"><a href="#获取所有产品的编译配置信息" class="headerlink" title="获取所有产品的编译配置信息"></a>获取所有产品的编译配置信息</h2><p>&emsp;&emsp;显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make dump-products</span></span><br></pre></td></tr></table></figure><h2 id="编译指定产品"><a href="#编译指定产品" class="headerlink" title="编译指定产品"></a>编译指定产品</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make PRODUCT-xxx-yyy</span></span><br></pre></td></tr></table></figure><h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><p>&emsp;&emsp;显示帮助信息，显示主要的make目标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="其他编译选项"><a href="#其他编译选项" class="headerlink" title="其他编译选项"></a>其他编译选项</h2><h3 id="m编译"><a href="#m编译" class="headerlink" title="m编译"></a>m编译</h3><p>m：编译整个安卓系统。（makes from the of the tree）</p><h3 id="mm编译"><a href="#mm编译" class="headerlink" title="mm编译"></a>mm编译</h3><p>mm：编译当前目录下的模块，当前目录下需要有Android.mk这个makefile文件，否则就往上找最近的Android.mk文件。（builds all of the moudles in the current directory）<br>mma：当前目录新增或删除文件后，可以用mma重新编译。</p><h3 id="mmm编译"><a href="#mmm编译" class="headerlink" title="mmm编译"></a>mmm编译</h3><p>mmm：编译指定路径下的模块，指定的路径下面需要有Android.mk这个makefile文件。（builds all of the moudles in the supplies directory）<br>mmma：指定目录下新增或删除文件后，可以用mmma重新编译。 // 未全编译的情况下，可以使用该命令单编译模块</p><h4 id="mmm命令的编译过程"><a href="#mmm命令的编译过程" class="headerlink" title="mmm命令的编译过程"></a>mmm命令的编译过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── build/core/main.mk（是Android编译系统的入口文件）</span><br><span class="line">    ├── build/core/config.mk（会定好编译类型和目标文件）</span><br><span class="line">        ├── build/core/definitions.mk（定义在编译过程中用到的宏）</span><br><span class="line">        ├── ONE_SHOT_MAKEFILE-&gt;build/core/package.mk（编译Apk库文件）</span><br><span class="line">            ├── build/core/java_library.mk（编译Java库文件）</span><br><span class="line">            ├── build/core/static_java_library.mk（编译Java静态库文件）</span><br><span class="line">            ├── build/core/shared_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/dynamic_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/binary.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/base_rules.mk （ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">                ├── build/core/static_library.mk（编译.a静态库文件）</span><br><span class="line">                ├── build/core/executable.mk（编译可执行文件）</span><br><span class="line">                ├── build/core/prebuilt.mk（编译已经预编译好的第三方库文件）</span><br><span class="line">            ├── build/core/Makfile（有system.img、boot.img、recovery.img等镜像文件生成规则）</span><br></pre></td></tr></table></figure><blockquote><p>环境变量ONE_SHOT_MAKEFILE中存放要编译模块的Android.mk的文件路径，如果环境变量值为空，表示执行的是m或者make命令，会对Android源代码中的所有模块进行编译。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_m_marshmallow.jpg&quot; alt=&quot;android_m_marshmallow&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的分区和启动流程</title>
    <link href="https://zhouyuebiao.cn/2019/08/15/0029-Android%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%98%A0%E5%83%8F/"/>
    <id>https://zhouyuebiao.cn/2019/08/15/0029-Android的分区和映像/</id>
    <published>2019-08-15T01:18:03.000Z</published>
    <updated>2019-09-23T01:49:23.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/andioid_happy.jpg" alt="android"></p><h1 id="Android分区"><a href="#Android分区" class="headerlink" title="Android分区"></a>Android分区</h1><h2 id="什么是分区"><a href="#什么是分区" class="headerlink" title="什么是分区"></a>什么是分区</h2><p>&emsp;&emsp;Android的分区就像是盖房子那样一块块砖块垒起来的，每块砖块放在合适的位置，遇到特特殊的需求，我们就将砖块修正一下（增加或裁减分区），这样我们的房子（Android系统）就慢慢起来了。盖房子需要很多砖头，但是我们Android的大楼主要是由几块砖块组成，这样我们学习起来就简单很多了，毕竟我们不用学习怎么盖一栋楼那么难（手动滑鸡）。<br>&emsp;&emsp;分区的重要性我们可以总结起来：分划决定发展，大小决定成败</p><blockquote><p>分划决定我们要划分不同的大小不同的分区，这个决定了整个平台的规划分区的大小，影响了我们存储的数据量</p></blockquote><p><img src="/images/Android/Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%8C%BA.jpg" alt="Android系统的分区"></p><h2 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h2><p>&emsp;&emsp;分区类型有裸分区和文件系统分区两部分。</p><h3 id="裸分区"><a href="#裸分区" class="headerlink" title="裸分区"></a>裸分区</h3><p>&emsp;&emsp;裸分区是指二进制存储到flash中的数据分区：如fashboot、boot、recovery、misc等</p><h3 id="文件系统分区"><a href="#文件系统分区" class="headerlink" title="文件系统分区"></a>文件系统分区</h3><p>&emsp;&emsp;文件系统分区是指通过挂载进行文件操作的分区，如cache、system、data等</p><h2 id="各个分区的作用"><a href="#各个分区的作用" class="headerlink" title="各个分区的作用"></a>各个分区的作用</h2><p>&emsp;&emsp;通过以上的介绍我们初步了解了分区，也知道了分区的类型，下面对常见分区进行简要的介绍，这些分区在启动过程中发挥不同的作用：</p><ul><li>boot：boot 分区包含通过 mkbootimg 组合在一起的内核映像和 RAM 磁盘。为了直接刷写内核而不刷写新的 boot 分区，可以使用虚拟分区：</li></ul><ul><li>kernel：kernel 虚拟分区仅覆盖内核（zImage、zImage-dtb、Image.gz-dtb），方法是写入新的映像来覆盖旧的映像。为此，它会确定 eMMC 中现有内核映像的起始位置并将新内核映像复制到该位置。请记住，新内核映像可能会大于现有内核映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。如果提供的开发内核不兼容，则可能需要使用相关的内核模块更新 dtb 分区（如果存在）、vendor 分区或 system 分区。</li><li>ramdisk：ramdisk 虚拟分区通过将新映像写入旧磁盘来仅覆盖 RAM 磁盘。为此，它会确定 eMMC 中现有 ramdisk.img 的起始位置并将新 RAM 磁盘映像复制到该位置。请记住，新 RAM 磁盘映像可能会大于现有 RAM 磁盘映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。</li></ul><ul><li>system：system 分区主要包含 Android 框架。</li><li>recovery：recovery 分区用于存储在 OTA 过程中启动的恢复映像。如果设备支持 A/B 更新，则恢复映像可以是启动映像中包含的 RAM 磁盘，而不是单独的映像。</li><li>cache：cache 分区用于存储临时数据，如果设备使用 A/B 更新，则可以不要此分区。cache 分区不需要可从引导加载程序写入，而只需要可清空。大小取决于设备类型和 userdata 分区的可用空间。目前，50MB 至 100MB 应该没问题。</li><li>misc：misc 分区供恢复映像使用，存储空间不能小于 4KB。</li><li>userdata：userdata 分区包含用户安装的应用和数据，包括自定义数据。</li><li>metadata：如果设备被加密，则需要使用 metadata 分区，该分区的存储空间不能小于 16MB。</li><li>vendor：vendor 分区包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，则可以省略此分区。</li><li>radio：radio 分区包含无线装置映像。只有包含无线装置且在专用分区中包含无线装置专用软件的设备才需要此分区。</li><li>tos：tos 分区用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用。</li></ul><blockquote><p>摘自：<a href="https://source.android.google.cn/devices/bootloader/partitions-images" target="_blank" rel="noopener">source.android.google</a></p></blockquote><p>&emsp;&emsp;<em>注：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。</em></p><h1 id="通用的Android系统分区"><a href="#通用的Android系统分区" class="headerlink" title="通用的Android系统分区"></a>通用的Android系统分区</h1><p>&emsp;&emsp;安卓手机和平板一般包括以下分区：</p><table><thead><tr><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">/u-boot</td><td align="center">启动分区，引导加载kernel和烧录的作用</td></tr><tr><td align="center">/partition</td><td align="center">partition/parameter.txt存储分区表信息</td></tr><tr><td align="center">/misc</td><td align="center">存储标记升级存储的一些升级信息</td></tr><tr><td align="center">/logo</td><td align="center">开机画面</td></tr><tr><td align="center">/recovery</td><td align="center">升级模块</td></tr><tr><td align="center">/boot</td><td align="center">内核分区（启动Android系统）</td></tr><tr><td align="center">/system</td><td align="center">系统分区</td></tr><tr><td align="center">/cache</td><td align="center">缓存临时文件，和下载升级包存储升级</td></tr><tr><td align="center">/data</td><td align="center">用户数据分区，安装的apk，缓存文件，系统启动的必要文件，数据库等用户相关信息。</td></tr></tbody></table><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p>&emsp;&emsp;此分区包含了一些系统设置和系统功能启用禁用的相关设置。这些设置包括CID(运营商或区域识别码）、USB设置和一些硬件设置等等。这是一个很重要的分区，如果此分区损坏或者部分数据丢失，手机的一些特定功能可能不能正常工作。</p><h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><p>&emsp;&emsp;在正常分区或内核分区被破坏，不能正常启动时，可以进入此分区进行恢复，他相当与一个简易的OS或blos，可以认为是一个boot分区的替代品，通过他可以让我们在这一分区进行备份维护和恢复，我们通常说的刷机便指的是此分区。<br><img src="/images/Android/android_recovery.jpg" alt="android_recovery"><br>&emsp;&emsp;进入此分区方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、通过 adb reboot recovery</span><br><span class="line">2、通过组合键，电源键+音量键</span><br></pre></td></tr></table></figure><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>&emsp;&emsp;此分区可以保证设备正常启动，它包含了kernel（内核）、ramdisk（虚拟内存盘：通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，可以极大的提高在其上进行的文件访问的速度)，如果没有此分区，设备通常不能正常启动。只有必要的时候，才去通过Recovery软件擦除（format）这个分区，一旦擦除，设备只有再重新安装一个新的boot分区，可以通过安装一个包含boot分区的ROM来实现，否则无法启动安卓系统。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>&emsp;&emsp;此分区用来存放除kernel和ramdisk以外的系统相关配置，他包括了用户界面、手机预装的软件等。擦除这个分区将会删除整个系统，但不会导致不能启动。可以通过进入Recovery程序或者bootloader程序中，安装一个新ROM(安卓系统)。</p><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>&emsp;&emsp;此分区包含了用户的数据信息，如：联系人、短信、设置、用户安装的程序的，擦除此分区，相当于手机恢复出厂设置，可以在Recovery模式中选择“data/factory reset ”擦除此分区。</p><p>&emsp;&emsp;此分区下的一些常见目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data/[packagename]/files 文件缓存目录,一般存小的文件缓存，如果是图片，不建议放这里，一般放到外置卡;</span><br><span class="line">/data/data/[packagename]/cache目录，存放一些其他缓存;</span><br><span class="line">/data/data/[packagename]/databases，存放数据库;</span><br><span class="line">/data/data/[packagename]/lib，应用的so目录;</span><br><span class="line">/data/data/[packagename]/shared_prefs 应用的SharedPreferences保存;</span><br></pre></td></tr></table></figure><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>&emsp;&emsp;此分区是安卓系统缓存区，他保存系统最常访问的数据和应用程序。擦除这个分区，不会影响个人数据，只是删除了这个分区中已经保存的缓存内容，缓存内容会在后续手机使用过程中重新自动生成。</p><h1 id="Android的启动流程"><a href="#Android的启动流程" class="headerlink" title="Android的启动流程"></a>Android的启动流程</h1><p>&emsp;&emsp;Android 从 Linux 系统启动有 4 个步骤；</p><ul><li>init 进程启动</li><li>Native 服务启动</li><li>System Server，Android 服务启动</li><li>Home 启动</li></ul><p><img src="/images/Android/Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="Android的启动流程"></p><h2 id="init-initial-进程启动-system-core-init"><a href="#init-initial-进程启动-system-core-init" class="headerlink" title="init(initial)进程启动(system\core\init)"></a>init(initial)进程启动(system\core\init)</h2><p>&emsp;&emsp;init 进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序 init 的方式，完成引导进程。init 始终是第一个进程.<br>&emsp;&emsp;init 进程一起来就根据 init.rc 和 init.xxx.rc 脚本文件建立了几个基本的服<br>务：</p><ul><li>servicemanamger</li><li>zygote</li></ul><p>&emsp;&emsp;最后 init 并不退出，而是担当起 property service 的功能。<br>Property service 就是属性设置</p><h3 id="通过init-rc启动服务"><a href="#通过init-rc启动服务" class="headerlink" title="通过init.rc启动服务"></a>通过init.rc启动服务</h3><p>&emsp;&emsp;system/core/init/init.c 中parse_config_file(Init.rc)<br>&emsp;&emsp;解析脚本文件：init.rc 和 init.xxxx.rc(硬件平台相关)init.rc 是 Android自己规定的初始化脚本(Android Init Language,<br>System/Core/Init/readme.txt)<br>&emsp;&emsp;该脚本包含四个类型的声明：</p><ul><li>Action(动作)</li><li>Commands(命令)</li><li>Services(服务)</li><li>Options(选项)</li></ul><h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>&emsp;&emsp;Servicemanager和zygote进程就奠定了Android的基础。Zygote 这个进程起来才会建立起真正的Android运行空间，初始化建立的 Service 都是 Navtive<br>&emsp;&emsp;service.在.rc 脚本文件中zygote的描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以 Zygote 从 main(…)    frameworks/base/cmds/app_main.cpp 开始</p><ol><li>main(…)     frameworks/base/cmds/app_main.cpp</li></ol><ul><li>建立 Java Runtime</li><li>runtime.start(“com.android.internal.os.ZygoteInit”, startSystemServer);</li></ul><ol start="2"><li>runtime.start    AndroidRuntime.cpp</li></ol><ul><li>建立虚拟机</li><li>运行：com.android.internal.os.ZygoteInit：main 函数。</li></ul><ol start="3"><li>main()   com.android.internal.os.ZygoteInit//正真的 Zygote。</li></ol><ul><li>registerZygoteSocket();//登记 Listen 端口</li><li>startSystemServer();</li><li>进入 Zygote 服务框架。</li></ul><p>&emsp;&emsp;经过这几个步骤，Zygote就建立好了，利用Socket通讯，接收ActivityManangerService的请求，Fork应用程序。<br>&emsp;&emsp;startSystemServer com.android.internal.os.ZygoteInit在Zygote上 fork了一个进程:com.android.server.SystemServer. 于是SystemServer (SystemServer.java）就建立了。Android的所有服务循环框架都是建SystemServer(SystemServer.java)上。在SystemServer.java中看不到循环结构，只是可以看到建立了init2的实现函数，建立了一大堆服务，并 AddService到service Manager。</p><h2 id="Home启动"><a href="#Home启动" class="headerlink" title="Home启动"></a>Home启动</h2><p>&emsp;&emsp;在<a href="mailto:ServerThread@SystemServer.java" target="_blank" rel="noopener">ServerThread@SystemServer.java</a>后半段，我们可以看到系统在启动完所有的Android服务后，做了这样一些动作：</p><ul><li>使用xxx.systemReady()通知各个服务，系统已经就绪。</li><li>特别对于ActivityManagerService.systemReady(回调)</li></ul><p>&emsp;&emsp;Widget.wallpaper,imm(输入法)等ready通知。</p><p>&emsp;&emsp;Home就是在ActivityManagerService.systemReady()通知的过程中建立的。下面是ActivityManagerService.systemReady()的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemReady()@ActivityManagerService.java</span><br><span class="line">resumeTopActivityLocked()</span><br><span class="line">startHomeActivityLocked();<span class="comment">//如果是第一个则启动HomeActivity。</span></span><br><span class="line">startActivityLocked（。。。）CATEGORY_HOME</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/andioid_happy.jpg&quot; alt=&quot;android&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android分区&quot;&gt;&lt;a href=&quot;#Android分区&quot; class=&quot;headerlink&quot; title=&quot;Android
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android之源起</title>
    <link href="https://zhouyuebiao.cn/2019/08/14/0028-Android%E4%B9%8B%E6%BA%90%E8%B5%B7/"/>
    <id>https://zhouyuebiao.cn/2019/08/14/0028-Android之源起/</id>
    <published>2019-08-14T03:38:25.000Z</published>
    <updated>2019-08-15T01:21:34.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_in_google.jpg" alt="android_in_google"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android（读音：英：[‘ændrɔɪd]，美：[ˈænˌdrɔɪd]），常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。</p><h1 id="Android的成立"><a href="#Android的成立" class="headerlink" title="Android的成立"></a>Android的成立</h1><p>&emsp;&emsp;2003年10月，有“Android之父”之称的安迪·鲁宾（Andy Rubin）、利奇·米纳尔（Rich Miner）、尼克·席尔斯（Nick Sears）、克里斯·怀特（Chris White）在美国加利福尼亚州帕罗奥图共同成立了Android科技公司（Android Inc.），鲁宾把Android项目描述为“有极大的潜能以开发更智能的移动设备，以更了解其用家的位置及偏好。”该公司早期的方向是为数字相机开发先进的操作系统，此亦是2004年4月该公司向投资者介绍的基础。尽管Android科技公司的创始人和员工过去都具有各自的科技成就，但是Android科技公司的经营只显露出它在智能手机软件的方面，该公司随后认为相机市场不足以实现其目标，并且在5个月之后努力把Android转移到一款可跟Symbian及微软Windows Mobile互相媲美的手机操作系统。</p><p>Android的后续发展：</p><ul><li>2005年7月11日Android Inc.被美国科技企业Google收购。</li><li>2007年11月，Google与84家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良Android，随后，Google以Apache免费开放源代码许可证的授权方式，发布了Android的源代码，开放源代码加速了Android普及，让生产商推出搭载Android的智能手机，Android后来更逐渐拓展到平板电脑及其他领域上。</li><li>2010年末数据显示，Andrioid超越称霸逾十年的诺基亚Symbian系统，成为全球第一大智能手机操作系统。</li><li>2013年6月最高曾有5.38亿台活跃的安卓设备；2013年6月最高曾有10亿台活跃的安卓设备</li><li>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</li><li>2018年8月6日，Android 9宣布发行。</li></ul><h1 id="Android命名由来"><a href="#Android命名由来" class="headerlink" title="Android命名由来"></a>Android命名由来</h1><p>&emsp;&emsp;Android一词最早出现于法国作家维利耶·德·利尔－阿达姆·利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃（L’Ève future）》中。他把外表像人的机器人取名为Android。</p><h1 id="Android标志"><a href="#Android标志" class="headerlink" title="Android标志"></a>Android标志</h1><p>&emsp;&emsp;Android是一个全身绿色的机器人，半圆形的头部，有两支天线和空白的点作为眼睛。它的头部与身体之间有空白的区域，相似于一枚有平底的鸡蛋，两侧各有两个圆角矩形，作为它的双臂。Android的标志是由Ascender公司设计，颜色采用了PMS 376C和RGB中十六进制的#A4C639来绘制，这是Android操作系统的品牌象征。当中的文字使用了Ascender公司专门制作的称之为“Google Droid”的字体有时候，它会以纯文字的标志展示。</p><h2 id="Android机器人"><a href="#Android机器人" class="headerlink" title="Android机器人"></a>Android机器人</h2><p><img src="/images/Android/Android_Robot.png" alt="Android_Robot"></p><h2 id="Android字标"><a href="#Android字标" class="headerlink" title="Android字标"></a>Android字标</h2><p><img src="/images/Android/android_logo_no_2x.png" alt="android_logo"></p><h1 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h1><p>&emsp;&emsp;Android系统架构包含以下组件：<br><img src="/images/Android/ape_fwk_all.png" alt="ape_fwk_all"></p><ul><li>应用框架。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息，因此如果作为硬件开发者，需要非常了解其中的 API。</li><li>Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。</li><li>系统服务。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。 应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。</li><li>硬件抽象层 (HAL)。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。</li><li>Linux 内核。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含几个特殊的补充功能，例如：Low Memory Killer（一种内存管理系统，可更主动地保留内存）、唤醒锁定（一种 PowerManager 系统服务）、Binder IPC 驱动程序以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。</li></ul><h1 id="Android堆栈"><a href="#Android堆栈" class="headerlink" title="Android堆栈"></a>Android堆栈</h1><p>&emsp;&emsp;Android 是一个针对多种不同设备类型打造的开放源代码软件堆栈。Android 的主要目的是为运营商、OEM 和开发者打造一个开放的软件平台，使他们能够将创新理念变为现实，并推出能够卓有成效地改善用户移动体验的真实产品。<br>&emsp;&emsp;Android 平台的设计可确保不存在一个集中瓶颈，即没有任何行业参与者可一手限制或控制其他参与者的创新。这样，我们不但可以打造功能完善的高品质消费类产品，而且可以完全开放源代码，供第三方自由定制和移植。<br><img src="/images/Android/Android%E5%A0%86%E6%A0%88.png" alt="Android 堆栈"></p><h1 id="Android更新时间表"><a href="#Android更新时间表" class="headerlink" title="Android更新时间表"></a>Android更新时间表</h1><table><thead><tr><th align="center">名称</th><th align="center">版本号</th><th align="center">发行日期</th><th align="center">API等级</th><th align="center">安全性更新状态</th></tr></thead><tbody><tr><td align="center">Android 1.0</td><td align="center">1.0</td><td align="center">2008年9月23日</td><td align="center">1</td><td align="center">不支持</td></tr><tr><td align="center">Android Petit Four</td><td align="center">1.1</td><td align="center">2009年2月9日</td><td align="center">2</td><td align="center">不支持</td></tr><tr><td align="center">Android Cupcake</td><td align="center">1.5</td><td align="center">2009年4月27日</td><td align="center">3</td><td align="center">不支持</td></tr><tr><td align="center">Android Donut</td><td align="center">1.6</td><td align="center">2009年9月15日</td><td align="center">4</td><td align="center">不支持</td></tr><tr><td align="center">Android Eclair</td><td align="center">2.0 – 2.1</td><td align="center">2009年10月26日</td><td align="center">5 – 7</td><td align="center">不支持</td></tr><tr><td align="center">Android Froyo</td><td align="center">2.2 – 2.2.3</td><td align="center">2010年5月20日</td><td align="center">8</td><td align="center">不支持</td></tr><tr><td align="center">Android Gingerbread</td><td align="center">2.3 – 2.3.7</td><td align="center">2010年12月6日</td><td align="center">9 – 10</td><td align="center">不支持</td></tr><tr><td align="center">Android Honeycomb</td><td align="center">3.0 – 3.2.6</td><td align="center">2011年2月22日</td><td align="center">11 – 13</td><td align="center">不支持</td></tr><tr><td align="center">Android Ice Cream Sandwich</td><td align="center">4.0 – 4.0.4</td><td align="center">2011年10月18日</td><td align="center">14 – 15</td><td align="center">不支持</td></tr><tr><td align="center">Android Jelly Bean</td><td align="center">4.1 – 4.3.1</td><td align="center">2012年7月9日</td><td align="center">16 – 18</td><td align="center">不支持</td></tr><tr><td align="center">Android KitKat</td><td align="center">4.4 – 4.4.4</td><td align="center">2013年10月31日</td><td align="center">19 – 20</td><td align="center">不支持</td></tr><tr><td align="center">Android Lollipop</td><td align="center">5.0 – 5.1.1</td><td align="center">2014年11月12日</td><td align="center">21 – 22</td><td align="center">不支持</td></tr><tr><td align="center">Android Marshmallow</td><td align="center">6.0 – 6.0.1</td><td align="center">2015年10月5日</td><td align="center">23</td><td align="center">支持</td></tr><tr><td align="center">Android Nougat</td><td align="center">7.0 – 7.1.2</td><td align="center">2016年8月22日</td><td align="center">24 – 25</td><td align="center">支持</td></tr><tr><td align="center">Android Oreo</td><td align="center">8.0 – 8.1</td><td align="center">2017年8月21日</td><td align="center">26 – 27</td><td align="center">支持</td></tr><tr><td align="center">Android Pie</td><td align="center">9.0.0</td><td align="center">2018年8月6日</td><td align="center">28</td><td align="center">支持</td></tr><tr><td align="center">Android Q</td><td align="center">未知</td><td align="center">2019年3月13日</td><td align="center">29</td><td align="center">测试中</td></tr></tbody></table><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">wiki</a><br><a href="https://source.android.google.cn/setup/community" target="_blank" rel="noopener">Android社区</a></p></blockquote><style>table th:nth-of-type(1){width: 35%;}table th:nth-of-type(2){width: 16%;}table th:nth-of-type(3){width: 25%;}table th:nth-of-type(4){width: 16%;}table th:nth-of-type(5){width: 18%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_in_google.jpg&quot; alt=&quot;android_in_google&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C语言操作符优先级</title>
    <link href="https://zhouyuebiao.cn/2019/08/09/0027-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://zhouyuebiao.cn/2019/08/09/0027-C语言操作符优先级/</id>
    <published>2019-08-09T06:32:01.000Z</published>
    <updated>2019-08-26T01:24:41.911Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/C&C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="C语言操作符优先级"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;表达式的求值顺序是由3个因素决定的：操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序。两个相邻的操作符哪个先执行取决于他们的优先级，如果两者的由优先级相同，那么它们的执行顺序由他们的结核性决定。</p><h1 id="C语言操作符的优先级"><a href="#C语言操作符的优先级" class="headerlink" title="C语言操作符的优先级"></a>C语言操作符的优先级</h1><p>表 5.1 列出了C语言中每个操作符的所有属性：</p><table><thead><tr><th align="center">操作符</th><th align="left">描述</th><th align="center">用法示例</th><th align="left">结果类型</th><th align="center">结合性</th><th align="left">控制求值顺序?</th></tr></thead><tbody><tr><td align="center">()</td><td align="left">聚组</td><td align="center">(表达式)</td><td align="left">与表达式同</td><td align="center">N/A</td><td align="left">否</td></tr><tr><td align="center">()</td><td align="left">函数调用</td><td align="center">rexp(rexp,…,rexp)</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">[]</td><td align="left">下标引用</td><td align="center">rexp[rexp]</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">.</td><td align="left">访问结构成员</td><td align="center">lexp.member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">-&gt;</td><td align="left">访问结构指针成员</td><td align="center">rexp-&gt;member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">后缀自增</td><td align="center">lexp++</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">后缀自减</td><td align="center">lexp–</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!</td><td align="left">逻辑反</td><td align="center">!rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">~</td><td align="left">按位取反</td><td align="center">~rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">单目，表示正值</td><td align="center">+rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">单目，表示负值</td><td align="center">-rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">前缀自增</td><td align="center">++lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">前缀自减</td><td align="center">–lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">间接访问</td><td align="center">*rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">取地址</td><td align="center">&amp;lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">sizeof</td><td align="left">取其长度</td><td align="center">sizeof rexp; sizeof(类型)</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">(类型)</td><td align="left">类型转换</td><td align="center">(类型)rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">乘法</td><td align="center">rexp*rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">/</td><td align="left">除法</td><td align="center">rexp/rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">%</td><td align="left">整数取余</td><td align="center">rexp%rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">加法</td><td align="center">rexp+rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">减法</td><td align="center">rexp&#45;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移位</td><td align="center">rexp&#60;&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移位</td><td align="center">rexp&gt;&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;</td><td align="left">大于</td><td align="center">rexp&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于</td><td align="center">rexp&gt;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;</td><td align="left">小于</td><td align="center">rexp&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于</td><td align="center">rexp&#60;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">==</td><td align="left">等于</td><td align="center">rexp==rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!=</td><td align="left">不等于</td><td align="center">rexp!=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">位于</td><td align="center">rexp&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">^</td><td align="left">位异或</td><td align="center">rexp^rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;</td><td align="left">位或</td><td align="center">rexp&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;&amp;</td><td align="left">逻辑与</td><td align="center">rexp&amp;&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;&#124;</td><td align="left">逻辑或</td><td align="center">rexpre&#124;&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr><tr><td align="center">?:</td><td align="left">条件操作符</td><td align="center">rexp?rexp:rexp</td><td align="left">rexp</td><td align="center">N/A</td><td align="left">是</td></tr><tr><td align="center">=</td><td align="left">赋值</td><td align="center">lexp=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+=</td><td align="left">以…加</td><td align="center">lexp+=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">-=</td><td align="left">以…减</td><td align="center">lexp-=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#42;=</td><td align="left">以…乘</td><td align="center">lexp &#42;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">/=</td><td align="left">以…除</td><td align="center">lexp/=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">%=</td><td align="left">以…取模</td><td align="center">lexp%=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">以…左移</td><td align="center">lexp&lt;&lt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">以…右移</td><td align="center">lexp&gt;&gt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;=</td><td align="left">以…与</td><td align="center">lexp&amp;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">^=</td><td align="left">以…异或</td><td align="center">lexp^=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#124;=</td><td align="left">以…或</td><td align="center">lexp&#124;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">,</td><td align="left">逗号</td><td align="center">rexp,rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr></tbody></table><h1 id="附：Markdown特殊字符转义"><a href="#附：Markdown特殊字符转义" class="headerlink" title="附：Markdown特殊字符转义"></a>附：Markdown特殊字符转义</h1><p>&emsp;&emsp;虽然hexo的语法是Markdown格式的，但是在书写时对于特殊字符使用“\“转义是不严谨的做法，最好的方式是使用特殊字符对应的编码，对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &amp;emsp;          --&gt; 空格(Space)</span><br><span class="line">!   &amp;#33;           --&gt; 惊叹号 (Exclamation mark) </span><br><span class="line">”   &amp;#34; &amp;quot;    --&gt; 双引号 (Quotation mark)</span><br><span class="line">#   &amp;#35;           --&gt; 数字标志 (Number sign)</span><br><span class="line">$   &amp;#36;           --&gt; 美元标志(Dollar sign)</span><br><span class="line">%   &amp;#37;           --&gt; 百分号(Percent sign)</span><br><span class="line">&amp;   &amp;#38; &amp;amp;     --&gt; 和号(Ampersand)</span><br><span class="line">|   &amp;#124;          --&gt; 竖线(Vertical bar) </span><br><span class="line">‘   &amp;#39;           --&gt; 单引号(Apostrophe) </span><br><span class="line">(   &amp;#40;           --&gt; 小括号左边部分(Left parenthesis) </span><br><span class="line">)   &amp;#41;           --&gt; 小括号右边部分(Right parenthesis) </span><br><span class="line">+   &amp;#43;           --&gt; 加号(Plus sign)</span><br><span class="line">-   &amp;#45; &amp;minus;   --&gt; 减号(Minus sign)</span><br><span class="line">*   &amp;#42;           --&gt; 星号(Asterisk)</span><br><span class="line">\   &amp;#92;           --&gt; 反斜杠(Reverse solidus (backslash)) </span><br><span class="line">&lt;   &amp;#60; &amp;lt;      --&gt; 小于号(Less than) </span><br><span class="line">=   &amp;#61;           --&gt; 等于符号(Equals sign)</span><br><span class="line">&gt;   &amp;#62;           --&gt; 大于号(Greater than)</span><br><span class="line">?   &amp;#63;           --&gt; 问号(Question mark)</span><br><span class="line">@   &amp;#64;           --&gt; 在标志(Commercial at)</span><br><span class="line">[   &amp;#91;           --&gt; 中括号左边部分(Left square bracket) </span><br><span class="line">]   &amp;#93;           --&gt; 中括号右边部分(Right square bracket)</span><br><span class="line">&#123;   &amp;#123;          --&gt; 大括号左边部分(Left curly brace) </span><br><span class="line">&#125;   &amp;#125;          --&gt; 大括号右边部分(Right curly brace)</span><br></pre></td></tr></table></figure><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 20%;}table th:nth-of-type(3){width: 30%;}table th:nth-of-type(4){width: 15%;}table th:nth-of-type(5){width: 10%;}table th:nth-of-type(6){width: 15%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/C&amp;C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg&quot; alt=&quot;C语言操作符优先级&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Repo入门</title>
    <link href="https://zhouyuebiao.cn/2019/08/08/0026-repo%E5%85%A5%E9%97%A8/"/>
    <id>https://zhouyuebiao.cn/2019/08/08/0026-repo入门/</id>
    <published>2019-08-08T09:49:55.000Z</published>
    <updated>2019-08-09T06:33:18.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>&emsp;&emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自动化部分开发工作流程。但是Repo并不是要取代Git，只是为了让Git更容易使用。repo命令只是一个可执行的Python脚本，我们可以将其放在路径中的任何位置。</p><h1 id="Repo、Git、Gerrit三者的区别"><a href="#Repo、Git、Gerrit三者的区别" class="headerlink" title="Repo、Git、Gerrit三者的区别"></a>Repo、Git、Gerrit三者的区别</h1><h2 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h2><p>&emsp;&emsp;Git 是一个开放源代码的版本控制系统，专用于处理分布在多个代码库上的大型项目。在 Android 环境中，我们会使用 Git 执行本地操作，例如建立本地分支、提交、查看更改、修改。</p><h2 id="1-2-Repo"><a href="#1-2-Repo" class="headerlink" title="1.2 Repo"></a>1.2 Repo</h2><p>&emsp;&emsp;Repo 是我们以 Git 为基础构建的代码库管理工具。Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到我们的修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让我们在 Android 环境中更轻松地使用 Git。Repo 命令是一段可执行的 Python 脚本，我们可以将其放在路径中的任何位置。使用 Android 源代码文件时，就可以使用 Repo 执行跨网络操作。例如，可以借助单个 Repo 命令，将文件从多个代码库下载到本地工作目录。</p><h2 id="1-3-Gerrit"><a href="#1-3-Gerrit" class="headerlink" title="1.3 Gerrit"></a>1.3 Gerrit</h2><p>&emsp;&emsp;Gerrit 是一个基于网页的代码审核系统，适用于使用 Git 的项目。Gerrit 允许所有授权用户提交更改（如果通过代码审核，这些更改会自动纳入项目中），以此鼓励其他人更集中地使用 Git。此外，Gerrit 可以在浏览器中并排显示更改，并支持代码内注释，使得审核工作变得更轻松！</p><h1 id="2-Repo的工作原理"><a href="#2-Repo的工作原理" class="headerlink" title="2. Repo的工作原理"></a>2. Repo的工作原理</h1><p>&emsp;&emsp;repo需要关注当前git库的数量、名称、路径等，有了这些基本信息，才能对这些git库进行操作。通过集中维护所有git库的清单，repo可以方便的从清单中获取git库的信息。 这份清单会随着版本演进升级而产生变化，同时也有一些本地的修改定制需求，所以，repo是通过一个git库来管理项目的清单文件的，这个git库名字叫manifests。<br>&emsp;&emsp;当打开repo这个可执行的python脚本后，发现代码量并不大(不超过1000行)，难道仅这一个脚本就完成了AOSP数百个git库的管理吗？并非如此。 repo是一系列脚本的集合，这些脚本也是通过git库来维护的，这个git库名字叫repo。<br>&emsp;&emsp;在客户端使用repo初始化一个项目时，就会从远程把manifests和repo这两个git库拷贝到本地，但这对于Android开发人员来说，又是近乎无形的(一般通过文件管理器，是无法看到这两个git库的)。 repo将自动化的管理信息都隐藏根目录的.repo子目录中。</p><h1 id="3-安装Repo"><a href="#3-安装Repo" class="headerlink" title="3. 安装Repo"></a>3. 安装Repo</h1><p>创建目录并修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h2 id="3-1-下载repo"><a href="#3-1-下载repo" class="headerlink" title="3.1 下载repo"></a>3.1 下载repo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x ~/bin/repo</span></span><br></pre></td></tr></table></figure><h2 id="3-3-获取帮助"><a href="#3-3-获取帮助" class="headerlink" title="3.3 获取帮助"></a>3.3 获取帮助</h2><p>&emsp;&emsp;安装 Repo 后，运行以下命令可以找到最新文档（开头是包含所有命令的摘要）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-查询具体命令的帮助"><a href="#3-4-查询具体命令的帮助" class="headerlink" title="3.4 查询具体命令的帮助"></a>3.4 查询具体命令的帮助</h2><p>&emsp;&emsp;在 Repo 树中运行以下命令来获取有关某个命令的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> &lt;COMMAND&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-查看Repo-init-参数的说明和选项列表"><a href="#3-5-查看Repo-init-参数的说明和选项列表" class="headerlink" title="3.5 查看Repo init 参数的说明和选项列表"></a>3.5 查看Repo init 参数的说明和选项列表</h2><p>&emsp;&emsp;此命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 <a href="https://source.android.com/source/using-repo.html#init" target="_blank" rel="noopener">init</a>。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> init</span></span><br></pre></td></tr></table></figure><h1 id="4-初始化仓库"><a href="#4-初始化仓库" class="headerlink" title="4. 初始化仓库"></a>4. 初始化仓库</h1><p>&emsp;&emsp;初始化仓库命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示范：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo init -u https://android.googlesource.com/platform/manifest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这将在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。<br>选项：</p><ul><li>-u：指定要从中检索清单代码库的网址。可以在 <a href="https://android.googlesource.com/platform/manifest" target="_blank" rel="noopener">https://android.googlesource.com/platform/manifest</a> 中找到常见清单</li><li>-m：在代码库中选择清单文件。如果未选择任何清单名称，则会默认选择 default.xml。</li><li>-b：指定修订版本，即特定的清单分支。</li></ul><blockquote><p>注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo/ 的父目录或相应父目录的子目录。</p></blockquote><h1 id="5-拉取仓库"><a href="#5-拉取仓库" class="headerlink" title="5. 拉取仓库"></a>5. 拉取仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo sync PROJECT0 PROJECT1 PROJECT2 ...</span></span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-j <numbers>： 多任务，一般8核心可以开到16任务,过多会起反作用</numbers></li><li>-c： 只下载当前分支代码</li><li>-d： 让工程回退到manifest指定的版本</li><li>-f： 如果某个工程同步失败，继续同步</li></ul><h1 id="6-修改仓库结构"><a href="#6-修改仓库结构" class="headerlink" title="6. 修改仓库结构"></a>6. 修改仓库结构</h1><p>&emsp;&emsp;如果想修改repo的结构，应该在 .repo/manifests 文件夹里面修改 default.xml 文件，然后用git命令提交。default.xml 文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">"git://git.mygit.com/"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"kk-shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">"1"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"packages/shift/VideoPlayer"</span> <span class="attr">name</span>=<span class="string">"platform/packages/shift/VideoPlayer"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"another_manifest.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>该文件内容的理解，请移步</p></blockquote><h1 id="7-理解repo-init后生成的-repo目录结构"><a href="#7-理解repo-init后生成的-repo目录结构" class="headerlink" title="7. 理解repo init后生成的.repo目录结构"></a>7. 理解repo init后生成的.repo目录结构</h1><p>&emsp;&emsp;当我们执行repo init命令之后会在当前目录下生成’.repo’目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree .repo -L 1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests</span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml -&gt; manifests/default.xml</span><br><span class="line">├── project.list</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br></pre></td></tr></table></figure><p>.repo目录理解：</p><ul><li>manifests：一个git库，包含default.xml文件，用于描述repo所管理的git库的信息</li><li>manifests.git：manifest这个git库的实体，manifest/.git目录下的所有文件都会链接到该目录</li><li>manifests/default.xml：工作树的主配置文件，一般不要编辑这个文件</li><li>projects/：每个git工程的 .git结构</li><li>manifest.xml：这是一个指向 .repo/manifests/ 目录中所选清单的符号链接</li><li>project.list：git库的所有仓库列表</li><li>repo/： 一个git库，包含repo运行的所有脚本</li></ul><h1 id="8-default-xml-文件解读"><a href="#8-default-xml-文件解读" class="headerlink" title="8. default.xml 文件解读"></a>8. default.xml 文件解读</h1><ul><li>manifest<br>&emsp;&emsp;这个是配置的顶层元素，即根标志</li><li>remote</li></ul><ul><li>name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。</li><li>alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url</li><li>fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径</li><li>review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果</li></ul><ul><li>default<br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</li></ul><ul><li>remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了）</li><li>revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch</li><li>sync_j ： 在repo sync中默认并行的数目</li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li></ul><ul><li>manifest-server<br>它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务，它要支持一下RPC方法：</li></ul><ul><li>GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。</li><li>target参数来自环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT，组成$TARGET_PRODUCT-$TARGET_BUILD_VARIANT</li><li>GetManifest(tag) ：返回指定tag的manifest</li></ul><ul><li>project<br>需要clone的单独git</li></ul><ul><li>name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name</li><li>path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样</li><li>remote ：定义remote name，如果没有定义的话就用default中定义的remote name</li><li>revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值</li><li>groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于</li><li>name:’name’ 和path:’path’组。例如<project name="monkeys" path="barrel-of">，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载</project></li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li><li>upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间</li><li>annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量</li></ul><ul><li>include<br>通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径)</li></ul><ul><li>name ：另一个需要导入的manifest文件名字<br>可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project</li></ul><ul><li>remove-project<br>&emsp;&emsp;从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义</li></ul><h1 id="9-Google提供的参考资源"><a href="#9-Google提供的参考资源" class="headerlink" title="9. Google提供的参考资源"></a>9. Google提供的参考资源</h1><p>&emsp;&emsp;主页：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;错误报告：<a href="https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo" target="_blank" rel="noopener">https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo</a><br>&emsp;&emsp;资料来源：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;概述：<a href="https://source.android.com/source/developing.html" target="_blank" rel="noopener">https://source.android.com/source/developing.html</a><br>&emsp;&emsp;文档：<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">https://source.android.com/source/using-repo.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自
      
    
    </summary>
    
      <category term="Git" scheme="https://zhouyuebiao.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://zhouyuebiao.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C语言显示数据处理进度条</title>
    <link href="https://zhouyuebiao.cn/2019/07/11/0025-C%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>https://zhouyuebiao.cn/2019/07/11/0025-C语言显示数据处理进度条/</id>
    <published>2019-07-11T07:03:41.000Z</published>
    <updated>2019-07-11T09:42:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。<br>&emsp;&emsp;我们见过比如使用git clone命令下载的时候显示的进度那样的效果，类似的还有很多，很多linux命令执行后一般都会有进度条显示，那么我们该怎样实现那样的效果呢？</p><blockquote><p>操作环境：linux；Linux+GCC</p></blockquote><h1 id="从C语言printf格式化控制台移动光标说起"><a href="#从C语言printf格式化控制台移动光标说起" class="headerlink" title="从C语言printf格式化控制台移动光标说起"></a>从C语言printf格式化控制台移动光标说起</h1><p>&emsp;&emsp;在Linux环境下，光标的移动、背景色和字体颜色的设置非常简单。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[47;31mhello world\033[5m"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;47是字背景颜色, 31是字体的颜色, hello world是字符串. 后面的\033[5m是控制码。字背景颜色范围: 40–49 字颜色: 30–39。<br>表2-1 字背景颜色及字颜色范围表</p><table><thead><tr><th align="center">数值</th><th align="left">背景颜色</th><th align="center">数值</th><th align="left">字颜色</th></tr></thead><tbody><tr><td align="center">40</td><td align="left">黑</td><td align="center">30</td><td align="left">黑</td></tr><tr><td align="center">41</td><td align="left">红</td><td align="center">31</td><td align="left">红</td></tr><tr><td align="center">42</td><td align="left">绿</td><td align="center">32</td><td align="left">绿</td></tr><tr><td align="center">43</td><td align="left">黄</td><td align="center">33</td><td align="left">黄</td></tr><tr><td align="center">44</td><td align="left">蓝</td><td align="center">34</td><td align="left">蓝</td></tr><tr><td align="center">45</td><td align="left">紫</td><td align="center">35</td><td align="left">紫</td></tr><tr><td align="center">46</td><td align="left">深绿</td><td align="center">36</td><td align="left">深绿</td></tr><tr><td align="center">47</td><td align="left">白色</td><td align="center">37</td><td align="left">白色</td></tr></tbody></table><p>表2-2 ANSI控制码表</p><table><thead><tr><th align="center">ANSI控制码</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">\033[0m</td><td align="left">关闭所有属性</td></tr><tr><td align="center">\033[1m</td><td align="left">设置高亮度</td></tr><tr><td align="center">\03[4m</td><td align="left">下划线</td></tr><tr><td align="center">\033[5m</td><td align="left">闪烁</td></tr><tr><td align="center">\033[7m</td><td align="left">反显</td></tr><tr><td align="center">\033[8m</td><td align="left">消隐</td></tr><tr><td align="center">\033[30m – \033[37m</td><td align="left">设置前景色</td></tr><tr><td align="center">\033[40m – \033[47m</td><td align="left">设置背景色</td></tr><tr><td align="center">\033[nA</td><td align="left">光标上移n行</td></tr><tr><td align="center">\03[nB</td><td align="left">光标下移n行</td></tr><tr><td align="center">\033[nC</td><td align="left">光标右移n行</td></tr><tr><td align="center">\033[nD</td><td align="left">光标左移n行</td></tr><tr><td align="center">\033[y;xH</td><td align="left">设置光标位置</td></tr><tr><td align="center">\033[2J</td><td align="left">清屏</td></tr><tr><td align="center">\033[K</td><td align="left">清除从光标到行尾的内容</td></tr><tr><td align="center">\033[s</td><td align="left">保存光标位置</td></tr><tr><td align="center">\033[u</td><td align="left">恢复光标位置</td></tr><tr><td align="center">\033[?25l</td><td align="left">隐藏光标</td></tr><tr><td align="center">\33[?25h</td><td align="left">显示光标</td></tr></tbody></table><h2 id="实现显示进度条代码"><a href="#实现显示进度条代码" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法的优点是，由于每次打印显示之前都是先将光标移动到行首并将其后的所有输出内容清除，因此当控制台有其他字符输出时，也不会导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress（进度百分比，取值为0~100）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,本次显示进度条时所输出的字符个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移动到行首并清除从当前光标到行尾的所有内容 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\033[k"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回本次显示进度条时所输出的字符个数 */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用’-b’退格字符实现"><a href="#使用’-b’退格字符实现" class="headerlink" title="使用’\b’退格字符实现"></a>使用’\b’退格字符实现</h1><p>&emsp;&emsp;在C语言中，提供了转义字符’\b’来进行输出后的退格操作。在编程过程中，我们有时候需要进行退格操作。但是，我在以前使用的过程中，发现我使用语句printf(“abc\b”);之后，在输出结果中还是显示的abc并不是我希望得到的ab。</p><h2 id="用法及原理"><a href="#用法及原理" class="headerlink" title="用法及原理"></a>用法及原理</h2><p>&emsp;&emsp;在用’\b’进行退格操作的时候，实际上，每次使用’\b’字符之后，控制台的输出光标会后退一个字符的位置，但是并没有将相应的字符删除。所以，我们需要在’\b’字符后面紧跟一个字符，用来代替需要删除的字符。如果后面没有需要输出的字符，可以用至少一个空格跟在’\b’后面，用来替换需要删除的字符。<br>&emsp;&emsp;该’\b’退格字符，也可以多个连用，以实现对多个字符的删除操作，但是需要注意的是，想要删除几个字符就要使用至少几个’\b’，对应的也需要有相等数量的字符用来替换待删除的字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="对单个字符进行退格操作（删除单个字符）"><a href="#对单个字符进行退格操作（删除单个字符）" class="headerlink" title="对单个字符进行退格操作（删除单个字符）"></a>对单个字符进行退格操作（删除单个字符）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\bv"</span>);  <span class="comment">//此处的输出结果是abv，后面的'v'就是用来替换'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b"</span>);  <span class="comment">//此处的输出结果是abc，可以看出虽然用了'\b'退格，但是并没有提供相应的用来替换最后一个字符'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b "</span>);  <span class="comment">//此处的输出结果是ab，因为在'\b'后面，跟了一个空格' '来替换了字符'c'</span></span><br></pre></td></tr></table></figure><h3 id="对多个字符进行退格操作（删除字符串）"><a href="#对多个字符进行退格操作（删除字符串）" class="headerlink" title="对多个字符进行退格操作（删除字符串）"></a>对多个字符进行退格操作（删除字符串）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b.new"</span>);  <span class="comment">//此处的输出结果是ph.new，后面的字符串".new"是用来替换"rase"的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b newString"</span>);  <span class="comment">//此处输出的结果是ph  newString，中间用了两个空格来代替字符串"ra"，紧接着用了两个字符"ne"来代替字符串"se"，再后面多出的"wString"字符串，则原样输出。</span></span><br></pre></td></tr></table></figure><h2 id="实现显示进度条代码-1"><a href="#实现显示进度条代码-1" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法有个致命的缺点，当控制台有其他字符输出的时候会打乱现有的显示位置，导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress           进度百分比，取值为0~100</span></span><br><span class="line"><span class="comment">* @param[in] last_char_count    上一次显示进度条时所用到的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,目前进度条打印的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress, <span class="keyword">int</span> last_char_count)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把上次显示的进度条信息全部清空*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; last_char_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\b"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回本次显示进度条时所输出的字符个数*/</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================================================================================================&gt;&gt;   [99%]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用C语言对IP地址排序</title>
    <link href="https://zhouyuebiao.cn/2019/06/21/0024-%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AF%B9IP%E5%9C%B0%E5%9D%80%E6%8E%92%E5%BA%8F/"/>
    <id>https://zhouyuebiao.cn/2019/06/21/0024-使用C语言对IP地址排序/</id>
    <published>2019-06-21T03:50:30.000Z</published>
    <updated>2019-07-04T11:21:28.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。<br>&emsp;&emsp;程序运行环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- windows 10 64-bit</span><br><span class="line">- Visual Studio 2015</span><br></pre></td></tr></table></figure><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>&emsp;&emsp;假设IP地址格式为：a.b.c.d<br>&emsp;&emsp;由观察可知：每个数字的范围在0~255之间，灭个字段都是模256的余数，则可以将所有字段按照所在位置乘以256的对应次幂。<br>&emsp;&emsp;由观察可得公式：(a<em>256^3) + (b</em>256^2) + (c<em>256^1) + (d</em>256^0)<br>这样我们就可以得到一个长整数。每个IP地址对应一个长整数，只要将IP地址与对应求得的长整数用链表保存起来。这样我们就将问题转换为基数排序，结果的排序即为索求排序，只需用指针或者下标等方法将两者对应。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort_ip_ddresses.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *ip_Str;    <span class="comment">// 数据域</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ip_Int;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipAddr</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;link;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">创建链表 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">creatLink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建头结点 */</span></span><br><span class="line">link * p = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link)); </span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">往链表增加项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link * <span class="title">addLink</span><span class="params">(link * head, <span class="keyword">char</span> *str, <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = head;</span><br><span class="line">link *targeLink = (link *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line"><span class="keyword">if</span> (targeLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入结点前申请内存失败！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">targeLink-&gt;ip_Int = value;</span><br><span class="line">targeLink-&gt;ip_Str = str;</span><br><span class="line">targeLink-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tempLink-&gt;next = targeLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tempLink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapStr</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr;</span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str1);</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line"><span class="built_in">strcpy</span>(str2, tempStr);</span><br><span class="line"><span class="built_in">free</span>(tempStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapValue</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *value1, <span class="keyword">long</span> <span class="keyword">long</span> *value2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempValue = *value1;</span><br><span class="line"></span><br><span class="line">*value1 = *value2;</span><br><span class="line">*value2 = tempValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">排序链表【冒泡排序】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">link *<span class="title">sortTheLinkedList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> canSort = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">while</span> (tempLink != head-&gt;next &amp;&amp; canSort)</span><br><span class="line">&#123;</span><br><span class="line">link *q = head;</span><br><span class="line">canSort = <span class="literal">false</span>;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line"><span class="keyword">for</span> (; q-&gt;next &amp;&amp; q-&gt;next != q; q = q-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if ((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) &gt; 0))  //|| (((strcmp(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str) == 0)) &amp;&amp; (strlen(q-&gt;ip_Str) &gt; strlen(q-&gt;next-&gt;ip_Str)))</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;ip_Int &gt; q-&gt;next-&gt;ip_Int)</span><br><span class="line">&#123;</span><br><span class="line">swapStr(q-&gt;ip_Str, q-&gt;next-&gt;ip_Str);</span><br><span class="line">swapValue(&amp;q-&gt;ip_Int, &amp;q-&gt;next-&gt;ip_Int);</span><br><span class="line">canSort = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tempLink = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历并输出链表内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">showLinkInf</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">link *tempLink = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tempLink == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (tempLink-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">tempLink = tempLink-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：%s，\t大小：%lld\n"</span>, tempLink-&gt;ip_Str, tempLink-&gt;ip_Int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表长度: %d\n\n"</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">清空链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emptyList</span><span class="params">(link *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link *tempLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempLink = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tempLink);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复制字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strCpy</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tempStr2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">16</span>);</span><br><span class="line"><span class="built_in">memset</span>(tempStr2, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(tempStr2, str, len);</span><br><span class="line"><span class="keyword">return</span> tempStr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设IP地址格式为：a.b.c.d</span></span><br><span class="line"><span class="comment">由观察可知：每个数字的范围在0~255之间，则可以将其看成一个四位的256进制数。</span></span><br><span class="line"><span class="comment">由观察可得公式：(a*256^3) + (b*256^2) + (c*256^1) + (d*256^0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">strToInt</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> calcValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> strTIntVal;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"."</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">strTIntVal = (<span class="keyword">long</span> <span class="keyword">long</span>)atoi(tokStr);</span><br><span class="line">calcValue = calcValue * <span class="number">256</span> + strTIntVal;</span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> calcValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strTok</span><span class="params">(link * head, <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *tokStr, *tempStr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line"></span><br><span class="line">tempStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="built_in">strlen</span>(str));</span><br><span class="line"><span class="built_in">strcpy</span>(tempStr, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分割字符串 */</span></span><br><span class="line">tokStr = strtok(tempStr, <span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (tokStr)</span><br><span class="line">&#123;</span><br><span class="line">tempLongData = strToInt(tokStr, <span class="built_in">strlen</span>(tokStr));</span><br><span class="line"><span class="comment">//tempStr = strCpy(tokStr, strlen(tokStr));</span></span><br><span class="line">addLink(head, tokStr, tempLongData);<span class="comment">// 加入链表</span></span><br><span class="line"></span><br><span class="line">tokStr = strtok(<span class="literal">NULL</span>, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buf;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> len, tempLen;</span><br><span class="line"><span class="keyword">int</span> linkCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tempLongData;</span><br><span class="line">link * ipLink = creatLink();</span><br><span class="line"></span><br><span class="line">buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*MAX_LINE);</span><br><span class="line">fp = fopen(<span class="string">"ipAddress.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"打开文件失败！\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="built_in">free</span>(ipLink);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAX_LINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">tempLen = len;</span><br><span class="line">strTok(ipLink, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sortTheLinkedList(ipLink);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!showLinkInf(ipLink))<span class="built_in">printf</span>(<span class="string">"链表为空，遍历失败！\n"</span>);</span><br><span class="line"></span><br><span class="line">emptyList(ipLink);</span><br><span class="line">fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="需排序的IP地址文本"><a href="#需排序的IP地址文本" class="headerlink" title="需排序的IP地址文本"></a>需排序的IP地址文本</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> </span><br><span class="line"><span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> </span><br><span class="line"><span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> </span><br><span class="line"><span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> </span><br><span class="line"><span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> </span><br><span class="line"><span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> </span><br><span class="line"><span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">92</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> </span><br><span class="line"><span class="number">82</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> </span><br><span class="line"><span class="number">72</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> </span><br><span class="line"><span class="number">62</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IP地址：<span class="number">102</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">1722286341</span></span><br><span class="line">IP地址：<span class="number">112</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">1890058517</span></span><br><span class="line">IP地址：<span class="number">122</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">2057830659</span></span><br><span class="line">IP地址：<span class="number">132</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">2225602825</span></span><br><span class="line">IP地址：<span class="number">142</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">2393374983</span></span><br><span class="line">IP地址：<span class="number">152</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">2561147142</span></span><br><span class="line">IP地址：<span class="number">162</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">2728919811</span></span><br><span class="line">IP地址：<span class="number">172</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">2896691460</span></span><br><span class="line">IP地址：<span class="number">182</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3064463875</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> ，  大小：<span class="number">3232235777</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">2</span> ，  大小：<span class="number">3232235778</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> ，  大小：<span class="number">3232235779</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">4</span> ，  大小：<span class="number">3232235780</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">5</span> ，  大小：<span class="number">3232235781</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">6</span> ，  大小：<span class="number">3232235782</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">7</span> ，  大小：<span class="number">3232235783</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">8</span> ，  大小：<span class="number">3232235784</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">9</span> ，  大小：<span class="number">3232235785</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">21</span> ， 大小：<span class="number">3232235797</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">2</span> ，  大小：<span class="number">3232236034</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">3</span> ，  大小：<span class="number">3232236035</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">15</span> ， 大小：<span class="number">3232236047</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">3</span> ，  大小：<span class="number">3232236291</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">4</span> ，  大小：<span class="number">3232236292</span></span><br><span class="line">IP地址：<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">5</span> ，  大小：<span class="number">3232236293</span></span><br><span class="line">链表长度: <span class="number">31</span></span><br><span class="line"></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;假设有若干IP地址随机存储在文本文件中，需要将其按照从小到大的顺序排序。&lt;br&gt;&amp;emsp;&amp;emsp;程序运行环境
      
    
    </summary>
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/categories/C-C/"/>
    
    
      <category term="C/C++,排序,链表" scheme="https://zhouyuebiao.cn/tags/C-C-%E6%8E%92%E5%BA%8F-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C标准库--string.h</title>
    <link href="https://zhouyuebiao.cn/2019/06/13/0023-C%E6%A0%87%E5%87%86%E5%BA%93-string-h/"/>
    <id>https://zhouyuebiao.cn/2019/06/13/0023-C标准库-string-h/</id>
    <published>2019-06-13T08:03:43.000Z</published>
    <updated>2019-08-15T01:25:06.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、strcmp、strcpy等等，更详细的可以到include文件夹里面查看该文件。</p><h1 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h1><p>&emsp;&emsp;头文件 string.h 中定义的变量类型：</p><table><thead><tr><th align="center">变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">size_t</td><td align="left">这是无符号整数类型，它是 sizeof 关键字的结果</td></tr></tbody></table><h1 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h1><p>头文件 string.h 中定义的宏：</p><table><thead><tr><th align="center">宏</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">NULL</td><td align="left">这个宏是一个空指针常量的值</td></tr></tbody></table><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><p>头文件 string.h 中定义的函数，有下表列出的22种用法。</p><table><thead><tr><th align="center">序号</th><th align="left">函数&amp;描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">void *memchr(const void *str, int c, size_t n)<br>在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">2</td><td align="left">int memcmp(const void *str1, const void *str2, size_t n)<br>把 str1 和 str2 的前 n 个字节进行比较。</td></tr><tr><td align="center">3</td><td align="left">void *memcpy(void *dest, const void *src, size_t n)<br>从 src 复制 n 个字符到 dest。</td></tr><tr><td align="center">4</td><td align="left">void *memmove(void *dest, const void *src, size_t n)<br>另一个用于从 src 复制 n 个字符到 dest 的函数。</td></tr><tr><td align="center">5</td><td align="left">void *memset(void *str, int c, size_t n)<br>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</td></tr><tr><td align="center">6</td><td align="left">char *strcat(char *dest, const char *src)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</td></tr><tr><td align="center">7</td><td align="left">char *strncat(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</td></tr><tr><td align="center">8</td><td align="left">char *strchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">9</td><td align="left">int strcmp(const char *str1, const char *str2)<br>把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</td></tr><tr><td align="center">10</td><td align="left">int strncmp(const char *str1, const char *str2, size_t n)<br>把 str1 和 str2 进行比较，最多比较前 n 个字节。</td></tr><tr><td align="center">11</td><td align="left">int strcoll(const char *str1, const char *str2)<br>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</td></tr><tr><td align="center">12</td><td align="left">char *strcpy(char *dest, const char *src)<br>把 src 所指向的字符串复制到 dest。</td></tr><tr><td align="center">13</td><td align="left">char *strncpy(char *dest, const char *src, size_t n)<br>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</td></tr><tr><td align="center">14</td><td align="left">size_t strcspn(const char *str1, const char *str2)<br>检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</td></tr><tr><td align="center">15</td><td align="left">char *strerror(int errnum)<br>从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</td></tr><tr><td align="center">16</td><td align="left">size_t strlen(const char *str)<br>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</td></tr><tr><td align="center">17</td><td align="left">char *strpbrk(const char *str1, const char *str2)<br>检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</td></tr><tr><td align="center">18</td><td align="left">char *strrchr(const char *str, int c)<br>在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</td></tr><tr><td align="center">19</td><td align="left">size_t strspn(const char *str1, const char *str2)<br>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</td></tr><tr><td align="center">20</td><td align="left">char *strstr(const char *haystack, const char *needle)<br>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</td></tr><tr><td align="center">21</td><td align="left">char *strtok(char *str, const char *delim)<br>分解字符串 str 为一组字符串，delim 为分隔符。</td></tr><tr><td align="center">22</td><td align="left">size_t strxfrm(char *dest, const char *src, size_t n)<br>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</td></tr></tbody></table><blockquote><p>更详细的内容请查阅include文件夹中的文件。</p></blockquote><style>table th:nth-of-type(1){width: 8%;}table th:nth-of-type(2){width: 92%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在C语言中，string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。常用函数有strlen、s
      
    
    </summary>
    
      <category term="C/++" scheme="https://zhouyuebiao.cn/categories/C/"/>
    
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>进程之进程调度</title>
    <link href="https://zhouyuebiao.cn/2019/06/04/0022-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>https://zhouyuebiao.cn/2019/06/04/0022-进程之进程调度/</id>
    <published>2019-06-04T01:00:00.000Z</published>
    <updated>2019-06-04T01:45:02.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互。为了满足这些目标，进程调度器（process scheduler）选择一个可用进程（可能从多个可用进程集合中）到CPU上执行。单处理器系统不会具有多个正在运行的进程。如果有多个进程，那么余下的需要等待CPU空闲并能重新调度。</p><h1 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h1><p>&emsp;&emsp;进程在进入系统时，会被加到作业队列（job queue），这个队列包括系统内的所有进程。驻留在内存中的、就绪的、等待运行的进程保存在就绪队列（ready queue）上。这个队列通常用链表实现；其头节点有两个指针，用于指向链表的第一个和最后一个PCB块，每个PCB还包括一个指针，指向就绪队列的下一个PCB。<br>&emsp;&emsp;系统还有其他队列。当一个进程被分配了CPU后，它执行一段时间，最终退出，或被中断，或等待特定事件发生，如I/O请求的完成。我们假设进程向一个共享设备，如磁盘，发出I/O请求。由于系统具有许多进程，磁盘可能忙于其他进程的I/O请求，因此该进程可能需要等待磁盘空闲。等待特定I/O设备的进程列表，称为设备队列（device queue）。每个设备都有自己的设备队列。</p><p><img src="/images/operating-system/process/2-1_Ready-Queue-And-Various-IO-Device-Queues.png" alt="就绪队列和各种IO设备队列"></p><center>图2-1 就绪队列和各种IO设备队列</center>&emsp;&emsp;进程调度通常用队列图（queueing diagram）来表示，如图1-2所示。每个举行框代表一个队列；这里具有两种队列：就绪队列和设备队列。圆圈表示服务队列的资源；箭头表示系统内的进程流向。<p><img src="/images/operating-system/process/2-2_Representation-of-Process-Scheduling.jpg" alt="表示进程调度的队列图"></p><center>图2-2 表示进程调度的队列</center>&emsp;&emsp;最初，新进程被加载到就绪队列；之后它便在就绪队列中一直等待，知道被选中执行或被分配（dispatched）。当该进程分配到CPU并执行时，以下事件可能发生：* 进程可能发出I/O请求，并被放到I/O队列。* 进程可能创建一个新的子进程，并等待其终止。* 进程可能由于中断而被强制释放CPU，并被放回到就绪队列。对于前面两种情况，进程最终从等待状态切换到就绪状态，并放回到就绪队列。进程重复这一循环直到终止；然后它会从所有队列中删除，其PCB和资源也被释放。<h1 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h1><p>&emsp;&emsp;进程在整个生命周期中，会在葛总调度队列之间迁移。操作系统为了调度必须按一定方式从这些队列中选择进程。进程选择通过适当调度器或调度程序(scheduler)来执行。<br>&emsp;&emsp;通常，对于批处理系统（又名批处理操作系统），提交的进程多于可以立即执行的。这些进程会被保存到大容量存储设备(通常为磁盘)的缓冲池，以便以后执行。长期调度程序(long-term scheduler)或作业调度程序(job scheduler)从该池中选择进程，加到内存，以便执行。短期调度程序（short-term scheduler）或CPU调度程序(CPU scheduler)从准备执行的进程中选择进程，并分配CPU。<br>&emsp;&emsp;这两种调度程序的主要区别是执行频率。短期调度程序必须经常为CPU选择新的进程。进程可能执行几毫秒(ms)，就会等待I/0请求。通常，短期调度程序每100ms至少执行一次。由于执行之间的时间短，短期调度程序必须快速.如果花费10ms来确定执行一个运行一个100ms的进程，那么 10/(100+10)=9% 的CPU时间会用在(或浪费在)调度工作上。<br>&emsp;&emsp;长期调度程序执行并不频繁；在新进程的创建之间，可能有几分钟间隔。长期调度程序控制多道程序程度(degree of multiprogramming)(内存中的进程数量)。如果多道程序程度稳定，那么创建进程的平均每度必须等于进程离开系统的平均速度。因此，只有在进程离开系统时，才需要长期调度程序的调度。由于每次执行之间的更长时间间隔，长期调度程序可以负担得起更多时间，以便决定应该选择执行哪个进程。<br>&emsp;&emsp;重要的是，长期调度程序进行认真选择。通常，大多数进程可分为：I/0为主或CPU为主。I/0密集型进程(I/O-bound process)，执行I/0比执行计算需要花费更多时间。相反，CPU密集型进程(CPU-bound process)很少产生I/O请求，而是将更多时间用于执行计算。重要的是，长期调度程序应该选择I/O密集型和CPU密集型的合理进程组合。</p><ul><li>如果所有进程都是I/O密集型的，那么就绪队列几乎总是为空，从而短期调度程序没有什么可做。</li><li>如果所有进程都是CPU密集型的，那么I/0等待队列几乎总是为空，从而设备没有得到使用，因而系统会不平衡。为了使得性能最佳，系统需要I/O密集型和CPU密集型的进程合理组合。</li></ul><p>&emsp;&emsp;有的系统，可能没有或极少采用长期调度程序。例如，UNIX或微软Windows的分时系统通常没有长期调度程序，只是简单将所有新进程放于内存，以供短期调度程序使用。这些系统的稳定性取决于物理限制(如可用的终端数)或用户的自我调整。如果多用户系统性能下降到令人难以接受，那么有的用户就会退出。<br>&emsp;&emsp;有的操作系统如分时系统，可能引人一个额外的中期调度程序(medium-term scheduler)。中期调度程序的核心思想是可将进程从内存(或从CPU竞争)中移出，从而降低多道程序程度。之后，进程可被重新调人内存，并从中断处继续执行。这种方案称为交换（swap）。通过中期调度，进程可换出（swap out），并在后来可换入（swap in）。为了改善进程组合，或者由于内存需求改变导致过渡使用内存从而需要释放内存，就有必要使用交换。</p><p><img src="/images/operating-system/process/2-3_Addition-of-Medium-Term-Scheduling.png" alt="添加中级进程调度到队列"></p><center>图3-1 添加中级进程调度到队列</center><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>&emsp;&emsp;中断导致CPU从执行当前任务改变到执行内核程序。这种操作在通用系统中经常发生。当中断发生时，系统需要保存当前运行在CPU上的进程的上下文，以便在处理后能够恢复上下文，即先挂起进程，在恢复进程。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等。通常，通过执行状态保存（state save），保存CPU当前状态（包括系统模式和用户模式）；之后，装填回复（state restore）重新开始运行。<br>&emsp;&emsp;切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个任务称上下文切换(context swiitch)。当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。上下文切换的时间是纯粹的开销，因为在切换时系统并没有做任何有用工作。上下文切换的速度因机器不同而有所不同，它依赖于内存速度、必须复制的寄存器数量、是否有特殊指令(如加载或存储所有寄存器的单个指令)。典型速度为几毫秒。<br>&emsp;&emsp;上下文切换的时间与硬件支持密切相关。例如，有的处理器(如Sun U1traspARC)提供了多个寄存器组，上下文切换只需简单改变当前寄存器组的指针。当然，如果活动进程数量超过寄存器的组数，那么系统需要像以前一样在寄存器与内存之间进行数据复制。而且，操作系统越复杂，上下文切换所要做的就越多。高级的内存管理技术在每次上下文切换时，所需切换的数据会更多。例如，在使用下一个进程的地址空间之前，需要保存当前进程的地址空间。如何保存地址空间，需要做什么才能保存等，取决于操作系统的内存管理方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程，当不执行时，位于某个等待队列。操作系统有两种主要队列：I/O请求队列和就绪队列。就绪队列包括所有准备执行并等待CPU的进程，每个进程都用PCB来表示。<br>&emsp;&emsp;操作系统应从各个调度队列中选择进程。长期调度（用于作业）选择进程以便竞争CPU。通常长期调度充分考虑资源分配，尤其是内存管理。短期调度从就绪队列中选择进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;多道程序设计的目标是，无论何时都有进程运行，从而最大化CPU利用率。分时操作系统的目的是在进程之间快速切换CPU，以
      
    
    </summary>
    
      <category term="操作系统" scheme="https://zhouyuebiao.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://zhouyuebiao.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://zhouyuebiao.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程之基础概念</title>
    <link href="https://zhouyuebiao.cn/2019/06/03/0021-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://zhouyuebiao.cn/2019/06/03/0021-进程之概念/</id>
    <published>2019-06-03T00:51:52.000Z</published>
    <updated>2019-06-04T01:37:40.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。这些资源在创建进程或执行进程时得以分配。<br>&emsp;&emsp;进程是大多数系统的工作单元。这种操作系统包含一组进程：操作系统进程执行系统代码，而用户进程执行用户代码。所有这些进程可以并发执行。<br>&emsp;&emsp;操作系统负责进程和线程管理的多个方面：用户进程与系统进程的创建与删除，进程调度，用于进程同步、进程通信与进程死锁处理的机制等。</p><h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>&emsp;&emsp;一个程序文件（program），只是一堆待执行的代码和部分待处理的数据，他们只有被加载到内存中，然后让CPU逐条执行其代码，并根据代码做出相应的动作，才能形成一个真正“活动”、动态的进程（process），因此进程时一个动态变化的过程，是一出有始有终的戏，而程序文件只是这一系列动作的原始蓝本，是一个静态的剧本。</p><p><img src="/images/operating-system/process/01_Process-in-Memory.png" alt="内存中的进程"></p><center>图2-1 进程的内存结构</center>&emsp;&emsp;进程是执行的程序。进程不只是程序代码，进程代码有时称为“文本段（text section）”（或“代码段（code section）”）。&emsp;&emsp;进程还包括：* 进程堆栈（stack）：包括临时数据，如函数参数、返回地址和局部变量。* 数据段（data section）：包括全局变量* 堆（heap）：可能包括堆，这是在进程运行时动态分配的内存。> 进程还包括当前活动，如程序计数器（program）的值和处理器寄存器的内容等。<h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>&emsp;&emsp;进程在执行时会改变状态。进程的状态，部分取决于进程的当前活动。每个进程都有可能处于以下状态的某种状态：</p><ul><li>新的（new）：进程正在创建；</li><li>运行（running）：指令正在执行；</li><li>等待（waiting）：进程正在等待发生某个时间（如I/O完成或受到信号）；</li><li>就绪（ready）：进程等待分配处理器；</li><li>终止（terminated）：进程已经完成执行。</li></ul><p><img src="/images/operating-system/process/02_Diagram-of-Process-State.png" alt="进程状态"></p><center>图3-1 进程状态图</center>> 一次只有一个进程可在处理器上运行（running）；但是可多个进程处于就绪（ready）或者等待（waiting）状态。<h1 id="程序与进程的关系"><a href="#程序与进程的关系" class="headerlink" title="程序与进程的关系"></a>程序与进程的关系</h1><p>&emsp;&emsp;程序本身不是进程。程序是被动（passive）实体，如存储在磁盘上包含一系列指令的文件（我们常称之为“可执行文件”（executable file））。相反，进程是活动（active）实体，具有一个程序计数器用于表示可执行命令和一组相关资源。当一个可执行文件被加载到内存时，这个程序就成为进程。</p><blockquote><p>加载可执行文件通常由两种方法：双击一个代表可执行文件的图标或在命令行上输入可执行文件的名称（如prog.exe或a.out）。</p></blockquote><p><img src="/images/operating-system/process/03_program-and-process.png" alt="程序与进程"></p><center>图4-1 程序与进程的关系</center>&emsp;&emsp;虽然多个进程可以与同一个程序相关联，但是实际上每个都是单独的执行序列。比如，多个用户可以运行电子邮件的不同副本，或者同意用户可以调用Web浏览器程序的多个副本。每个副本（进程）都是单独运行的；虽然文本段相同，但是数据、堆、及堆栈却不同。进程在运行时也经常会生成许多进程（子进程）。# 进程控制块&emsp;&emsp;操作系统内的每个进程表示，都采用进程控制块表示（Process Control Block），也称任务控制块（task control block）。当可执行程序被进行时，内核中实际上产生了一个叫"task_struct{}"的结构体来表示这个进程，进程是一个“活动的实体”，这个活动的实体从一开始诞生就需要各种各样的资源以便于生存下去，而这些信息都被记录在"task_struct"结构体之中，这个结构体被常常称之为进程控制块（PCB，即Process Control Block）。进程控制块包括：* 进程状态：状态可以包括由新的、就绪、运行、等待、停止等。* 程序计数器：计数器表示进程将要执行的下个指令的地址。* CPU寄存器：根据计算机体系的不同寄存器的类型和数量也会不同。他们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件吗信息寄存器。在发生中断时，这些状态信息与程序计数器一起需要保存，一边进程以后能正确地继续执行。* CPU调度信息：这类信息包括进程优先级、调度队列地指针和气压调度参数。* 内存管理信息：根据操作系统使用的内核系统，这类信息可以包括及地址和界限寄存器的值、页表或段表。* 记账信息：这类信息包括CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开文件列表等。&emsp;&emsp;简而言之，PCB简单地作为这些信息的仓库，这些信息也会随着进程的不同而不同。<p><img src="/images/operating-system/process/04_Process-Control-Block-(PCB).png" alt="进程控制块"></p><center>图5-1 进程控制块</center><p><img src="/images/operating-system/process/05_CPU-Switch-From-Process-to-Process.png" alt="进程间的CPU切换"></p><center>图5-2 进程间的CPU切换</center><h1 id="Linux的进程表示"><a href="#Linux的进程表示" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;Linux操作系统的进程控制块采用C语言结构体 task_struct 来表示，它位于Linux内核源代码目录内的头文件&lt;linux/sched.h&gt;。这个结构体包含用于表示进程的所有必要信息，包括进程的状态、调度和内存管理信息、打开文件列表、指向父进程的指针及指向子进程和兄弟进程列表的指针等。（父进程（parent process）为创建他的进程，子进程（child process）为它本身创建的进程，兄弟进程（sibling process）为具有同一父进程的进程。）<br>这些成员包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pid t pid;                  <span class="comment">/* process identifier */</span> </span><br><span class="line"><span class="keyword">long</span> state;                 <span class="comment">/* state of the process */</span> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> time slice     <span class="comment">/* scheduling information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> <span class="title">struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* this process’s parent */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">head</span> <span class="title">children</span>;</span>  <span class="comment">/* this process’s children */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files</span> <span class="title">struct</span> *<span class="title">files</span>;</span> <span class="comment">/* list of open files */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm</span> <span class="title">struct</span> *<span class="title">mm</span>;</span>       <span class="comment">/* address space of this process */</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，进程状态是由这个结构的成员 long state 来表示的。在Linux内核中，所有活动进程的表示都采用task_struct 的双向链表。内核采用一个指针即 current，用于指向当前系统正在执行的进车.</p><p><img src="/images/operating-system/process/06_task-struct-double-linuxked-list.png" alt="task_struct双向链表"></p><center>图6-1 task_struct双向链表</center><h1 id="Linux的进程表示-1"><a href="#Linux的进程表示-1" class="headerlink" title="Linux的进程表示"></a>Linux的进程表示</h1><p>&emsp;&emsp;下面举例说明，内核如何修改某个特定进程的 task_struct 的成员，假设系统需要将当前运行状态改成值 new_state。如果current 为指向当前运行进程的指针，那么可以这样改变状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state = new_state;</span><br></pre></td></tr></table></figure><blockquote><p>Linux内核代码纷繁复杂，千万头绪，这个结构体是系统进程在执行过程中所有设计的方方面面的缩影，因此以这个所谓的进程控制块（PCB）为切入点，是研究内核的一个很好的窗口。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;进程是可执行的程序。随着进程的执行，它会改变状态。<br>&emsp;&emsp;程序本身不是进程。程序只是被动实体，进程是活动实体，当一个可执行文件被加载到内存时，这个程序就成为进程。进程状态是由进程当前活动定义的。<br>&emsp;&emsp;每个进程都可以处于如下状态的某一种：新的、就绪、运行、等待或终止。<br>&emsp;&emsp;在操作系统中，每个进程通过它的进程控制块（PCB）来表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;可以将进程（process）看作执行的程序。进程需要一定的资源，如CPU时间、内存、文件和I/O设备，用以执行任务。
      
    
    </summary>
    
      <category term="操作系统" scheme="https://zhouyuebiao.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://zhouyuebiao.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="https://zhouyuebiao.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解Makefile及典型的Makefile示例</title>
    <link href="https://zhouyuebiao.cn/2019/04/27/0020-%E7%90%86%E8%A7%A3Makefile%E5%8F%8A%E5%85%B8%E5%9E%8B%E7%9A%84Makefile%E7%A4%BA%E4%BE%8B/"/>
    <id>https://zhouyuebiao.cn/2019/04/27/0020-理解Makefile及典型的Makefile示例/</id>
    <published>2019-04-27T13:56:48.000Z</published>
    <updated>2019-04-27T15:08:09.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考<a href="http://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">GNU Make Manual</a></p><h1 id="Makefile到底是什么"><a href="#Makefile到底是什么" class="headerlink" title="Makefile到底是什么"></a>Makefile到底是什么</h1><p>&emsp;&emsp;一个正式的软件工程中源文件可能数不胜数，并且源文件按类型、功能、模块等分别放在不同的目录下，在我们使用使用keil, Visual Studio, avr等工具开发程序时点点鼠标就可以编译了，但是对于其中的内部机制是什么？是怎么组织管理程序的？怎么决定编译哪一个文件？我们一概不知，因为IDE帮我们屏蔽了这方面的细节，让我们得以安心的投入到编码中。但是如果真要我们手工处理的话，那么我们每次都在命令行执行例如这样的指令： gcc a.c b.c c.c -o test ，显然是非常影响效率的！而Makefile是我们可以信赖的好伙伴，它定义了一系列的规则来指定：哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br>&emsp;&emsp;综上所述，Makefile 就是一个用来帮助我们编译的工具，和 Windows 下的 IDE 类似，只不过 Makefile 需要我们自己动手编写，一个好的 Makefile 可以极大的提升工作的效率。</p><h1 id="Makefile的核心—规则"><a href="#Makefile的核心—规则" class="headerlink" title="Makefile的核心—规则"></a>Makefile的核心—规则</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################</span></span><br><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">目标 : 依赖1 依赖2 ...</span><br><span class="line">[TAB]命令</span><br><span class="line">...</span><br><span class="line"><span class="comment">#######################################</span></span><br></pre></td></tr></table></figure><ul><li>target 就是我们编译文件要生成的目标;</li><li>prerequisites 就是我们编译文件需要的依赖;</li><li>command 就是用依赖生成目标所需要执行的命令（注意需用tab开始）。</li></ul><blockquote><p>当”目标文件”[不存在], 或某个依赖文件比目标文件[“新”],则: 执行”命令”</p></blockquote><p>&emsp;&emsp;比如我们平时使用的 gcc a.c b.c -o test<br>&emsp;&emsp;这里的 test 就是我们要生成的目标， a.c 就是我们生成目标需要的依赖，而 gcc a.c -o test 则是命令。将这行命令用 Makefile 的方式来写就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:a.c b.c</span></span><br><span class="line">    gcc a.c b.c -o test</span><br></pre></td></tr></table></figure><blockquote><p>再次强调：Makefile 中的命令必须用 tab 开始，不能是空格。</p></blockquote><p>&emsp;&emsp;Makefile 可以自动推导文件以及文件依赖关系后面的命令，在后面的示例中我们可以看到目标的依赖基本都是 .o 文件而不是 .c 文件，原因正是 Makefile 强大的自动推导功能。<br>&emsp;&emsp;通常 Makefile 中还会有一个名为 clean 的目标，用来清除编译后产生的各种文件。一般情况下 Makefile 会根据依赖和目标的新旧来决定是否编译，但是如果不小心修改了目标而造成目标比依赖新的情况的话，Makefile 会因为目标比依赖新而忽略这个目标下的命令，这个时候显然会造成问题，一个解决的办法就是使用 clean 这样的目标来清除编译后的文件，然后 make 重新编译。<br>&emsp;&emsp;clean 这个目标有点特殊，他是不需要依赖的，因此也叫伪目标。一般使用方式如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o test -f</span><br></pre></td></tr></table></figure><h1 id="Makefile-使用"><a href="#Makefile-使用" class="headerlink" title="Makefile 使用"></a>Makefile 使用</h1><p>&emsp;&emsp;make 命令执行时，需要一个 Makefile 文件(文件名为 Makefile 、 makefile 、 *.mk )，以告诉 make 命令需要怎么样的去编译和链接程序。执行时只用在命令行输入 make ， Makefile 就会自动执行第一个目标下的命令。而是否执行命令则取决于依赖，如果没有目标文件或是目标后的依赖文件比目标文件新，Makefile 就会执行其下面的命令：</p><ul><li>Makefile 中使用 # 注释,只注释 # 后的一行。</li><li>Makefile 中引用其他 Makefile，用 include 指令来引用。引用的效果就是原地展开。</li><li>Makefile 命令前面加 @ 来静默执行，即执行命令时不打印命令本身。</li></ul><h1 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h1><h2 id="Makefile-变量"><a href="#Makefile-变量" class="headerlink" title="Makefile 变量"></a>Makefile 变量</h2><p>&emsp;&emsp;Makefile 中的变量和 shell 脚本中非常相似，都是直接定义，不需要类型，引用时用 $(var) 。<br>&emsp;&emsp;伪目标（ .PHONY ）：伪目标形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。</p><h2 id="Makefile-中的几种变量赋值运算符"><a href="#Makefile-中的几种变量赋值运算符" class="headerlink" title="Makefile 中的几种变量赋值运算符"></a>Makefile 中的几种变量赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">延时变量赋值，可以被赋值为变量的值，解析时取这个变量最后的值。</td></tr><tr><td align="center">:=</td><td align="left">即时变量赋值，被赋值为变量时解析为变量在这行语句时的值，即变量如果后面改变这里的值也不改变。</td></tr><tr><td align="center">?=</td><td align="left">延时变量赋值, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句。</td></tr><tr><td align="center">+=</td><td align="left">附加, 它是即时变量还是延时变量取决于前面的定义。</td></tr></tbody></table><blockquote><p>关于 = 和 := ，比如 B=$(A)bcd ，那么 B 的值取决于变量 A 最后一次被赋值的值，即使 A 在 B 之后再次被赋值，变量 B 仍然会随着 A 的改变而改变。而 := 则只看之前 A 最后被赋值的值。</p></blockquote><p>&emsp;&emsp;即时变量也叫简单变量，即时变量与延时变量的理解示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A := xxx   <span class="comment"># A的值即刻确定，在定义时即确定</span></span><br><span class="line">B  = xxx   <span class="comment"># B的值使用到时才确定</span></span><br></pre></td></tr></table></figure><h2 id="Makefile-中的自动变量"><a href="#Makefile-中的自动变量" class="headerlink" title="Makefile 中的自动变量"></a>Makefile 中的自动变量</h2><p>&emsp;&emsp;自动变量是 Makefile 中提前预定义的特殊意义的符号，类似 C 语言中的宏 <strong>__</strong>LINE__ 等，提前被定义并被赋予了特殊含义。</p><table><thead><tr><th align="center">符号</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">$@</td><td align="left">目标文件名，比如上文的 test 。</td></tr><tr><td align="center">$&lt;</td><td align="left">第一个依赖文件名，如果依赖目标是以模式（即“ % “）定义的，那么” $&lt; “将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</td></tr><tr><td align="center">$^</td><td align="left">依赖的文件集合，比如上文的 a.c b.c 。</td></tr></tbody></table><p>&emsp;&emsp;此外还可以向 Makefile 传参， $# 存放传递参数个数， $1 存放第一个参数的字符串， $2 存放第二个参数的字符串……</p><h2 id="Makefile-的环境变量"><a href="#Makefile-的环境变量" class="headerlink" title="Makefile 的环境变量"></a>Makefile 的环境变量</h2><ul><li>Makefile 中用 export 导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。</li><li>环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有 Makefile 之间可以共享的全局变量，而普通变量只是当前本 Makefile 中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的 Makefile 文件，因此要小心。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>&emsp;&emsp;通配符：比如在当前文件夹下有 1.c 2.c 12.c test.c 1.h 。</p><table><thead><tr><th align="center">通配符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">%</td><td align="left">若干个任意字符，和 * 很相似，但是 % 一般只用于规则描述中，又叫做规则通配符。</td></tr><tr><td align="center">*</td><td align="left">若干个任意字符 *.c 匹配 1.c 2.c 12.c test.c 。</td></tr><tr><td align="center">?</td><td align="left">1个任意字符 ?.c 匹配 1.c 2.c 。</td></tr><tr><td align="center">[]</td><td align="left">将 [] 中的字符依次去和外面的结合匹配 [12].c 匹配 1.c 2.c 。</td></tr><tr><td align="center">$@</td><td align="left">表示目标</td></tr><tr><td align="center">$&lt;</td><td align="left">表示第1个依赖文件</td></tr><tr><td align="center">$^</td><td align="left">表示所有依赖文件</td></tr></tbody></table><p>&emsp;&emsp;Makefile 与 shell 脚本非常相似，shell 脚本中能使用的 Makefile 也能使用，比如 awk 等工具。</p><h2 id="Makefile-的函数"><a href="#Makefile-的函数" class="headerlink" title="Makefile 的函数"></a>Makefile 的函数</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern...,text)</span>      <span class="comment"># 在text中取出符合patten格式的值</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern...,text)</span>  <span class="comment"># 在text中取出不符合patten格式的值</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span>            <span class="comment"># pattern定义了文件名的格式,</span></span><br><span class="line">                               <span class="comment"># wildcard取出其中存在的文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,<span class="variable">$(var)</span>)</span>  <span class="comment"># 从列表中取出每一个值</span></span><br><span class="line">                                        <span class="comment"># 如果符合pattern</span></span><br><span class="line"><span class="comment"># 则替换为replacement</span></span><br></pre></td></tr></table></figure><h1 id="Makefile-典型示例"><a href="#Makefile-典型示例" class="headerlink" title="Makefile 典型示例"></a>Makefile 典型示例</h1><p>&emsp;&emsp;请移步我的<a href="https://github.com/YobeZhou/Example-For-Makefile" target="_blank" rel="noopener">GitHub仓库</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Makefile是用于自动编译和链接的工具。本文仅供学习参考，需获取更全面、权威的内容请参考&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="https://zhouyuebiao.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="嵌入式Linux" scheme="https://zhouyuebiao.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
  <entry>
    <title>什么是BootLoader？</title>
    <link href="https://zhouyuebiao.cn/2019/04/21/0019-%E4%BB%80%E4%B9%88%E6%98%AFBootloader%EF%BC%9F/"/>
    <id>https://zhouyuebiao.cn/2019/04/21/0019-什么是Bootloader？/</id>
    <published>2019-04-21T01:15:32.000Z</published>
    <updated>2019-04-27T15:08:37.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoader 可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。<br>&emsp;&emsp;Bootloader不但依赖于CPU的体系结构，而且依赖于嵌入式系统板级设备的配置。对于嵌入式系统，Bootloader是基于特定硬件平台来实现的。因此，几乎不可能为所有的嵌入式系统建立一个通用的Bootloader，不同的处理器架构都有不同的Bootloader。<br>&emsp;&emsp;在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p><h1 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h1><ul><li>自启动模式：在这种模式下，bootloader从目标机上的某个固态存储设备上将操作系统加载到RAM中运行，整个过程并没有用户的介入。</li><li>交互模式：在这种模式下，目标机上的bootloader将通过串口或网络等通行手段从开发主机（Host）上下载内核映像等到RAM中。可以被bootloader写到目标机上的固态存储媒质中，或者直接进入系统的引导。也可以通过串口接收用户的命令。</li></ul><h1 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h1><p>&emsp;&emsp;Bootloader启动大多数都分为两个阶段。第一阶段主要包含依赖于CPU的体系结构硬件初始化的代码，通常都用汇编语言来实现。这个阶段的任务有：<br>    1. 基本的硬件设备初始化（屏蔽所有的中断、关闭处理器内部指令/数据Cache等）。<br>    2. 为第二阶段准备RAM空间。<br>    3. 如果是从某个固态存储媒质中，则复制Bootloader的第二阶段代码到RAM。<br>    4. 设置堆栈。<br>    5. 跳转到第二阶段的C程序入口点。</p><p>&emsp;&emsp;第二阶段通常用C语言完成，以便实现更复杂的功能，也使程序有更好的可读性和可移植性。这个阶段的任务有：<br>    1. 初始化本阶段要使用到的硬件设备。<br>    2. 检测系统内存映射。<br>    3. 将内核映像和根文件系统映像从Flash读到RAM。<br>    4. 为内核设置启动参数。<br>    5. 调用内核。</p><blockquote><p>在第一阶段中为什么要关闭Cache？通常使用Cache以及写缓冲是为了提高系统性能，但由于Cache的使用可能改变访问主存的数量、类型和时间，因此Bootloader通常是不需要的。</p></blockquote><h1 id="常见的Bootloader"><a href="#常见的Bootloader" class="headerlink" title="常见的Bootloader"></a>常见的Bootloader</h1><p>BootLoader可以是U-Boot\Eboot\vivi等待其他一切方式。BootLoader是所有boot的总称。</p><h2 id="ARMboot"><a href="#ARMboot" class="headerlink" title="ARMboot"></a>ARMboot</h2><p>&emsp;&emsp;ARMboot是一个ARM平台的开源固件项目，它特别基于PPCBoot，一个为PowerPC平台上的系统提供类似功能的姊妹项目。鉴于对PPCBoot的严重依赖性，已经与PPCBoot项目合并，新的项目为U-Boot。<br>&emsp;&emsp;ARMboot发布的最后版本为ARMboot-1.1.0，2002年ARMboot终止了维护。</p><h2 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h2><p>&emsp;&emsp;U-Boot是由开源项目PPCBoot发展起来的，ARMboot并入了PPCBoot，和其他一些arch的Loader合称U-Boot。2002年12月17日第一个版本U-Boot-0.2.0发布，同时PPCBoot和ARMboot停止维护。<br>&emsp;&emsp;U-Boot支持的处理器构架包括PowerPC (MPC5xx，MPC8xx，MPC82xx，MPC7xx，MPC74xx，4xx)， ARM （ARM7，ARM9，StrongARM，Xscale），MIPS (4Kc，5Kc)，x86等等， U-Boot（Universal Bootloader）从名字就可以看出，它是在GPL下资源代码最完整的一个通用Boot Loader。<br>&emsp;&emsp;U-Boot提供两种操作模式：启动加载（Boot loading）模式和下载（Downloading）模式,并具有大型Boot Loader的全部功能。<br>&emsp;&emsp;U-Boot的功能是如此之强大，涵盖了绝大部分处理器构架，提供大量外设驱动，支持多个文件系统，附带调试、脚本、引导等工具，特别支持Linux,为板级移植做了大量的工作。U-Boot1.1.1版本特别包含了对SA1100和44B0芯片的移植，所以44B0移植主要是针对Board 的移植，包括FLASH、内存配置以及串口波特率等等。U-Boot的完整功能性和后续不断的支持，使系统的升级维护变得十分方便。</p><h2 id="Eboot"><a href="#Eboot" class="headerlink" title="Eboot"></a>Eboot</h2><p>&emsp;&emsp;是使用网口的意思，是微软提供的一般是wince下的bootloader，但是经过修改也可以兼容运行在其他OS下，如linux。如果直接说eboot也是bootloader”这样说不够严谨，对于基于norflash的bootloader来说是对的，如果bootloader是从nandflash开始执行就不对了，但我们所说的bootloader=nboot+eboot，其中nboot负责把eboot加载到SDRAM指定的内存处，然后运行eboot，接着eboot会把NK加载到SDRAM中并且执行。</p><h2 id="vivi"><a href="#vivi" class="headerlink" title="vivi"></a>vivi</h2><p>&emsp;&emsp;vivi是韩国mizi 公司开发的bootloader, 适用于ARM9处理器。Vivi有两种工作模式：启动加载模式和下载模式。启动加载模式可以在一段时间后（这个时间可更改）自行启动linux内核，这是vivi的默认模式。在下载模式下，vivi为用户提供一个命令行接口，通过接口可以使用vivi提供的一些命令</p><h2 id="Redboot"><a href="#Redboot" class="headerlink" title="Redboot"></a>Redboot</h2><p>&emsp;&emsp;Redboot是Redhat公司随eCos发布的一个BOOT方案，是一个开源项目。<br>&emsp;&emsp;Redboot支持的处理器构架有ARM，MIPS，MN10300，PowerPC， Renesas SHx，v850，x86等，是一个完善的嵌入式系统Boot Loader。<br>&emsp;&emsp;Redboot是在ECOS的基础上剥离出来的，继承了ECOS的简洁、轻巧、可灵活配置、稳定可靠等品质优点。它可以使用X-modem或Y-modem协议经由串口下载，也可以经由以太网口通过BOOTP/DHCP服务获得IP参数，使用TFTP方式下载程序映像文件，常用于调试支持和系统初始化（Flash下载更新和网络启动）。Redboot可以通过串口和以太网口与GDB进行通信，调试应用程序，甚至能中断被GDB运行的应用程序。Redboot为管理FLASH映像，映像下载，Redboot配置以及其他如串口、以太网口提供了一个交互式命令行接口，自动启动后，REDBOOT用来从TFTP服务器或者从Flash下载映像文件加载系统的引导脚本文件保存在Flash上。<br>&emsp;&emsp;Redboot是标准的嵌入式调试和引导解决方案，支持几乎所有的处理器构架以及大量的外围硬件接口，并且还在不断地完善过程中。</p><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>&emsp;&emsp;Blob(Boot Loader Object)是由Jan-Derk Bakker and Erik Mouw发布的，是专门为StrongARM 构架下的LART设计的Boot Loader。<br>&emsp;&emsp;Blob也提供两种工作模式，在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 Blob 切换到下载模式。如果在 10 秒内没有用户按键，则 Blob 继续启动 Linux内核。<br>&emsp;&emsp;Blob功能比较齐全，代码较少，比较适合做修改移植，用来引导Liunx，目前大部分S3C44B0板都用Blob修改移植后来加载uClinux。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在嵌入式操作系统中，BootLoader 是系统的一个引导加载程序，其在操作系统内核运行之前运行。BootLoade
      
    
    </summary>
    
      <category term="嵌入式Linux" scheme="https://zhouyuebiao.cn/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
    
      <category term="操作系统" scheme="https://zhouyuebiao.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="嵌入式Linux" scheme="https://zhouyuebiao.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"/>
    
  </entry>
  
</feed>
