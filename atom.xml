<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YobeZhou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhouyuebiao.cn/"/>
  <updated>2020-01-29T07:04:20.157Z</updated>
  <id>https://zhouyuebiao.cn/</id>
  
  <author>
    <name>YobeZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>USB设备驱动程序</title>
    <link href="https://zhouyuebiao.cn/2020/01/29/0044-USB%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://zhouyuebiao.cn/2020/01/29/0044-USB设备驱动程序/</id>
    <published>2020-01-29T06:04:30.000Z</published>
    <updated>2020-01-29T07:04:20.157Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/driver/usb_driver/usb_driver.jpg" alt="usb_driver"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在 windows 系统下，当我们第一次接入一个新设备时（如 Android 手机）：<ol><li>windows 右下角弹出”发现android phone”</li><li>跳出一个对话框，提示你安装驱动程序</li></ol></li></ul><p>&emsp;&emsp;由此引出学习 USB 驱动程序的几个问题。</p><h1 id="学习前的几个-FAQs"><a href="#学习前的几个-FAQs" class="headerlink" title="学习前的几个 FAQs"></a>学习前的几个 FAQs</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><ul><li>A: 既然还没有”驱动程序”，为何能知道是”android phone”</li><li>Q: 这是因为：<ul><li>windows里已经有了USB的总线驱动程序，接入USB设备后，是”总线驱动程序”知道你是”android phone”</li><li>并提示你安装的是”设备驱动程序”</li></ul></li></ul><blockquote><p>USB总线驱动程序负责：识别USB设备, 给USB设备找到对应的驱动程序</p></blockquote><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><ul><li>A: USB设备种类非常多，为什么一接入电脑，就能识别出来？</li><li>Q: PC和USB设备都得遵守一些规范：<ul><li>比如：USB设备接入电脑后，PC机会发出”你是什么”？<ul><li>USB设备就必须回答”我是xxx”, 并且回答的语言必须是中文</li></ul></li><li>USB总线驱动程序会发出某些命令想获取设备信息(描述符)，</li><li>USB设备必须返回”描述符”给PC</li></ul></li></ul><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><ul><li>A: PC机上接有非常多的 USB 设备，而 USB 硬件接口只有 4 条线: 5V,GND,D-,D+，系统是怎么分辨它们的？</li><li>Q: 系统为设备分配编号来管理多个设备<ul><li>每一个USB设备接入PC时，USB总线驱动程序都会给它分配一个编号</li><li>接在USB总线上的每一个USB设备都有自己的编号(地址)</li><li>PC机想访问某个USB设备时，发出的命令都含有对应的编号(地址)</li></ul></li></ul><h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><ul><li>A: USB设备刚接入 PC 时，还没有编号；那么 PC 怎么把 “准备分配的编号” 告诉它？</li><li>Q: 有一个默认编号来处理新设备，接就绪的所有设备都不会使用默认编号。<ul><li>新接入的USB设备的默认编号是0，在未分配新编号前，PC使用0编号和它通信。</li></ul></li></ul><h2 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h2><ul><li>A: 为什么一接入 USB 设备，PC 机就能发现它？</li><li>Q: 这是因为在硬件上做了手脚：<ul><li>PC的USB口内部，D-和D+接有15K的下拉电阻，未接USB设备时为低电平</li><li>USB设备的USB口内部，D-或D+接有1.5K的上拉电阻；它一接入PC，就会把PC USB口的D-或D+拉高，从硬件的角度通知PC有新设备接入</li></ul></li></ul><p><img src="/images/driver/usb_driver/USB_HOST_Port.png" alt></p><h1 id="一些必要的概念理解"><a href="#一些必要的概念理解" class="headerlink" title="一些必要的概念理解"></a>一些必要的概念理解</h1><h2 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h2><p>&emsp;&emsp;USB是主从结构的<br>&emsp;&emsp;&emsp;&emsp;所有的USB传输，都是从USB主机这方发起；USB设备没有”主动”通知USB主机的能力。<br>&emsp;&emsp;&emsp;&emsp;例子：USB鼠标滑动一下立刻产生数据，但是它没有能力通知PC机来读数据，只能被动地等得PC机来读。</p><h2 id="USB的传输类型"><a href="#USB的传输类型" class="headerlink" title="USB的传输类型"></a>USB的传输类型</h2><ul><li>USB的传输类型有下面四种:<br><ul><li>控制传输：可靠，时间有保证，比如：USB设备的识别过程<br></li><li>批量传输: 可靠, 时间没有保证, 比如：U盘<br></li><li>中断传输：可靠，实时，比如：USB鼠标<br></li><li>实时传输：不可靠，实时，比如：USB摄像头<br></li></ul></li></ul><h2 id="USB的传输对象"><a href="#USB的传输对象" class="headerlink" title="USB的传输对象"></a>USB的传输对象</h2><p>&emsp;&emsp;USB传输的对象：端点(endpoint)<br></p><ul><li>我们说”读U盘”、”写U盘”，可以细化为：<br><ul><li>读U盘: 把数据写到U盘的端点1</li><li>写U盘: 从 U 盘的端点 2 中读出数据</li></ul></li></ul><p>&emsp;&emsp;除了端点 0 外，每一个端点只支持一个方向的数据传输<br><br>&emsp;&emsp;端点0: 用于控制传输。既能输出也能输入<br></p><p>&emsp;&emsp;每一个端点都有传输类型，传输方向<br></p><blockquote><p>术语里、程序里说的输入(IN)、输出(OUT) “都是” 基于 USB 主机的立场说的。比如鼠标的数据是从鼠标传到PC机, 对应的端点称为”输入端点”</p></blockquote><h1 id="USB驱动程序框架"><a href="#USB驱动程序框架" class="headerlink" title="USB驱动程序框架"></a>USB驱动程序框架</h1><p><img src="/images/driver/usb_driver/USB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.png" alt></p><h2 id="USB总线驱动程序的作用"><a href="#USB总线驱动程序的作用" class="headerlink" title="USB总线驱动程序的作用"></a>USB总线驱动程序的作用</h2><p>&emsp;&emsp;USB总线驱动程序的作用有下面 3 个。<br></p><h3 id="识别-USB-设备"><a href="#识别-USB-设备" class="headerlink" title="识别 USB 设备"></a>识别 USB 设备</h3><p>&emsp;&emsp;分配地址<br>&emsp;&emsp;&emsp;&emsp;并告诉 USB 设备(set address)<br>&emsp;&emsp;发出命令获取描述符<br>&emsp;&emsp;&emsp;&emsp;设备描述符(struct usb_device_descriptor)的信息可以在 include\linux\usb\Ch9.h 获取<br>&emsp;&emsp;还有<br>&emsp;&emsp;&emsp;&emsp;配置描述符 struct usb_config_descriptor (include\linux\usb\Ch9.h)<br>&emsp;&emsp;….<br><img src="/images/driver/usb_driver/USB%E6%8F%8F%E8%BF%B0%E7%AC%A6.bmp" alt></p><h4 id="识别过程"><a href="#识别过程" class="headerlink" title="识别过程"></a>识别过程</h4><p>&emsp;&emsp;把USB设备接到开发板上，看输出信息:(using s3c2410-ohci and address 2)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 2</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">scsi0 : SCSI emulation <span class="keyword">for</span> USB Mass Storage devices</span><br><span class="line">scsi 0:0:0:0: Direct-Access     HTC      Android Phone    0100 PQ: 0 ANSI: 2</span><br><span class="line">sd 0:0:0:0: [sda] Attached SCSI removable disk</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;拔掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb 1-1: USB disconnect, address</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再接上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 3</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">scsi1 : SCSI emulation <span class="keyword">for</span> USB Mass Storage devices</span><br><span class="line">scsi 1:0:0:0: Direct-Access     HTC      Android Phone    0100 PQ: 0 ANSI: 2</span><br><span class="line">sd 1:0:0:0: [sda] Attached SCSI removable disk</span><br></pre></td></tr></table></figure><h4 id="内核处理过程"><a href="#内核处理过程" class="headerlink" title="内核处理过程"></a>内核处理过程</h4><p>在内核源码目录下搜索关键字:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"USB device using"</span> * -nR</span><br><span class="line">drivers/usb/core/hub.c:2186:              <span class="string">"%s %s speed %sUSB device using %s and address %d\n"</span>,</span><br></pre></td></tr></table></figure><p>“%s %s speed %sUSB device using %s and address %d\n”,的调用过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hub_irq <span class="comment">//注意是 USB 主机控制器中注册的中断，当USB设备接入后产生中断</span></span><br><span class="line">    kick_khubd  <span class="comment">//唤醒 hub_thread 线程)</span></span><br><span class="line">        hub_thread</span><br><span class="line">            hub_events</span><br><span class="line">                hub_port_connect_change</span><br><span class="line">                </span><br><span class="line">                    udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br><span class="line">                                dev-&gt;dev.bus = &amp;usb_bus_type;<span class="comment">// 总线-设备-驱动模型： usb_bus_type usb_interface usb_driver</span></span><br><span class="line">                </span><br><span class="line">                    choose_address(udev); <span class="comment">// 给新设备分配编号(地址)</span></span><br><span class="line">                                          <span class="comment">// if (devnum &gt;= 128) 最多支持 1-127 个 USB 设备</span></span><br><span class="line">                    </span><br><span class="line">                    hub_port_init    <span class="comment">//打印如： usb 1-1: new full speed USB device using s3c2410-ohci and address 3</span></span><br><span class="line">                        </span><br><span class="line">                        hub_set_address  <span class="comment">// 把编号(地址)告诉 USB 设备</span></span><br><span class="line">                        </span><br><span class="line">                        usb_get_device_descriptor(udev, <span class="number">8</span>); <span class="comment">// 获取设备描述符</span></span><br><span class="line">                        retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE); <span class="comment">// 描述符的信息可以在 include\linux\usb\Ch9.h 获取 (ch9 第九章)</span></span><br><span class="line">                        </span><br><span class="line">                        usb_new_device(udev)   </span><br><span class="line">                            err = usb_get_configuration(udev);  <span class="comment">// 把所有的描述符都读出来，并解析</span></span><br><span class="line">                            usb_parse_configuration<span class="comment">// 解析</span></span><br><span class="line">                            </span><br><span class="line">                            device_add  <span class="comment">// 把 device 放入 usb_bus_type 的 dev 链表, </span></span><br><span class="line">                                        <span class="comment">// 从 usb_bus_type 的 driver 链表里取出 usb_driver，</span></span><br><span class="line">                                        <span class="comment">// 把 usb_interface 和 usb_driver的id_table 一一比较</span></span><br><span class="line">                                        <span class="comment">// 如果能匹配，则调用 usb_driver 的 probe</span></span><br></pre></td></tr></table></figure><blockquote><p>深入理解总线驱动程序，参考：《LINUX内核源代码情景分析》</p></blockquote><h2 id="查找并安装对应的设备驱动程序"><a href="#查找并安装对应的设备驱动程序" class="headerlink" title="查找并安装对应的设备驱动程序"></a>查找并安装对应的设备驱动程序</h2><h2 id="提供USB读写函数"><a href="#提供USB读写函数" class="headerlink" title="提供USB读写函数"></a>提供USB读写函数</h2><h1 id="编写-USB-设备驱动程序"><a href="#编写-USB-设备驱动程序" class="headerlink" title="编写 USB 设备驱动程序"></a>编写 USB 设备驱动程序</h1><p>&emsp;&emsp;在我们接入设备时，USB总线驱动程序会新建一个 usb device 并注册到总线中，我们只需要构造一个新的 usb_driver 结构体并注册进总线中<br>&emsp;&emsp;这里给出编写一个 USB 鼠标驱动程序的过程。</p><blockquote><p>基于 Linux-2.6.22.6 内核源码编写驱动程序。<br>参考案例： drivers\hid\usbid\Usbmouse.c</p></blockquote><h2 id="编写-Makegile"><a href="#编写-Makegile" class="headerlink" title="编写 Makegile"></a>编写 Makegile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KERN_DIR = /work/system/linux-2.6.22.6</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">rm -rf modules.order</span><br><span class="line"></span><br><span class="line">obj-m+= usbmouse_as_key.o</span><br></pre></td></tr></table></figure><h2 id="最基本的-USB-设备驱动程序"><a href="#最基本的-USB-设备驱动程序" class="headerlink" title="最基本的 USB 设备驱动程序"></a>最基本的 USB 设备驱动程序</h2><p>这里只编写了 USB 设备驱动程序的基本框架，在连接上设备后打印 版本号、厂家 ID、设备 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drivers\hid\usbhid\usbmouse.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/usb/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">usbmouse_as_key_id_table</span> [] = &#123;</span></span><br><span class="line">&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br><span class="line">USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//&#123;USB_DEVICE(0x1234,0x5678)&#125;,</span></span><br><span class="line">&#123; &#125;<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_probe</span><span class="params">(struct usb_interface *intf, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line"></span><br><span class="line">printk(<span class="string">"found usbmouse!\n"</span>);</span><br><span class="line"></span><br><span class="line">printk(<span class="string">"bcdUSB = %x\n"</span>, dev-&gt;descriptor.bcdUSB);        <span class="comment">// 版本号</span></span><br><span class="line">printk(<span class="string">"VID    = 0x%x\n"</span>, dev-&gt;descriptor.idVendor);    <span class="comment">// 厂家 ID</span></span><br><span class="line">printk(<span class="string">"PID    = 0x%x\n"</span>, dev-&gt;descriptor.idProduct);   <span class="comment">// 设备 ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_disconnect</span><span class="params">(struct usb_interface *intf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"disconnect usbmouse!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置usb_driver */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbmouse_as_key_driver</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"usbmouse_as_key_"</span>,</span><br><span class="line">.probe= usbmouse_as_key_probe,</span><br><span class="line">.disconnect= usbmouse_as_key_disconnect,</span><br><span class="line">.id_table= usbmouse_as_key_id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 2. 注册 */</span></span><br><span class="line">usb_register(&amp;usbmouse_as_key_driver);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usb_deregister(&amp;usbmouse_as_key_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(usbmouse_as_key_init);</span><br><span class="line">module_exit(usbmouse_as_key_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>make menuconfig 去掉原来的 USB 鼠标驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig</span><br><span class="line">-&gt; Device Drivers </span><br><span class="line">-&gt; HID Devices</span><br><span class="line">&lt;&gt; USB Human Interface Device (full HID) support</span><br></pre></td></tr></table></figure></li><li><p>make uImage 并使用新的内核启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make uImage</span><br><span class="line">$ cp arch/arm/boot/uImage ~/</span><br></pre></td></tr></table></figure><ul><li><p>使用新内核启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJTAG&gt; nfs 30000000 192.168.1.5:/work/nfs_root/uImage_nohid:bootm 30000000</span><br></pre></td></tr></table></figure></li><li><p>启动后，挂载网络文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mout -t nfs -o nolock,vers=2 192.168.1.5:/work/nfs_root/first_fs /mnt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>装载驱动     </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod usbmouse_as_key</span><br><span class="line">$ insmod usbmouse_as_key.ko</span><br></pre></td></tr></table></figure></li><li><p>在开发板上接入、拔出USB鼠标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># usb 1-1:new full speed USB device using s3c2410-ohci and address 3</span></span><br><span class="line">    usb 1-1:configuration <span class="comment">#l chosen from 1 choice </span></span><br><span class="line">    found usbmouse!</span><br><span class="line">    bcdUSB=200</span><br><span class="line">    VID =0×46d</span><br><span class="line">    PID=0xc52f</span><br><span class="line"></span><br><span class="line">    disconnect usbmouse!\n</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="调试、分析USB鼠标产生的数据"><a href="#调试、分析USB鼠标产生的数据" class="headerlink" title="调试、分析USB鼠标产生的数据"></a>调试、分析USB鼠标产生的数据</h2><p>&emsp;&emsp;USB主机控制器会不断查询是否有数据产生，当有数据产生时，会将数据存入一个 buffer 中，然后产生一个中断，这就导致中断处理函数被调用，我们需要编写这个中断处理函数(这里是 usbmouse_as_key_irq 函数)。<br>&emsp;&emsp;在这里，当调用中断处理函数后只是直接将数据按照 16 进制的格式打印显示，用以分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drivers\hid\usbhid\usbmouse.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/usb/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">uk_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *usb_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dma_addr_t</span> usb_buf_phys;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">uk_urb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">usbmouse_as_key_id_table</span> [] = &#123;</span></span><br><span class="line">&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br><span class="line">USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//&#123;USB_DEVICE(0x1234,0x5678)&#125;,</span></span><br><span class="line">&#123; &#125;<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">"data cnt %d: "</span>, ++cnt);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"%02x "</span>, usb_buf[i]);  <span class="comment">// 打印鼠标产生的数据</span></span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新提交urb */</span></span><br><span class="line">usb_submit_urb(uk_urb, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_probe</span><span class="params">(struct usb_interface *intf, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">interface</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line"><span class="keyword">int</span> pipe;</span><br><span class="line"></span><br><span class="line">interface = intf-&gt;cur_altsetting;</span><br><span class="line">endpoint = &amp;interface-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a. 分配一个input_dev */</span></span><br><span class="line">uk_dev = input_allocate_device();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b. 设置 */</span></span><br><span class="line"><span class="comment">/* b.1 能产生哪类事件 */</span></span><br><span class="line">set_bit(EV_KEY, uk_dev-&gt;evbit);</span><br><span class="line">set_bit(EV_REP, uk_dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.2 能产生哪些事件 */</span></span><br><span class="line">set_bit(KEY_L, uk_dev-&gt;keybit);</span><br><span class="line">set_bit(KEY_S, uk_dev-&gt;keybit);</span><br><span class="line">set_bit(KEY_ENTER, uk_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* c. 注册 */</span></span><br><span class="line">input_register_device(uk_dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* d. 硬件相关操作 */</span></span><br><span class="line"><span class="comment">/* 数据传输3要素: 源,目的,长度 */</span></span><br><span class="line"><span class="comment">/* 源: USB设备的某个端点 */</span></span><br><span class="line">pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 长度: */</span></span><br><span class="line">len = endpoint-&gt;wMaxPacketSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目的: */</span></span><br><span class="line">usb_buf = usb_buffer_alloc(dev, len, GFP_ATOMIC, &amp;usb_buf_phys);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用"3要素" */</span></span><br><span class="line"><span class="comment">/* 分配usb request block */</span></span><br><span class="line">uk_urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"><span class="comment">/* 使用"3要素设置urb" */</span></span><br><span class="line">usb_fill_int_urb(uk_urb, dev, pipe, usb_buf, len, usbmouse_as_key_irq, <span class="literal">NULL</span>, endpoint-&gt;bInterval);</span><br><span class="line">uk_urb-&gt;transfer_dma = usb_buf_phys;</span><br><span class="line">uk_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用URB */</span></span><br><span class="line">usb_submit_urb(uk_urb, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_disconnect</span><span class="params">(struct usb_interface *intf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printk("disconnect usbmouse!\n");</span></span><br><span class="line">usb_kill_urb(uk_urb);</span><br><span class="line">usb_free_urb(uk_urb);</span><br><span class="line"></span><br><span class="line">usb_buffer_free(dev, len, usb_buf, usb_buf_phys);</span><br><span class="line">input_unregister_device(uk_dev);</span><br><span class="line">input_free_device(uk_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置usb_driver */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbmouse_as_key_driver</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"usbmouse_as_key_"</span>,</span><br><span class="line">.probe= usbmouse_as_key_probe,</span><br><span class="line">.disconnect= usbmouse_as_key_disconnect,</span><br><span class="line">.id_table= usbmouse_as_key_id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 2. 注册 */</span></span><br><span class="line">usb_register(&amp;usbmouse_as_key_driver);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usb_deregister(&amp;usbmouse_as_key_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(usbmouse_as_key_init);</span><br><span class="line">module_exit(usbmouse_as_key_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><ol><li><p>make menuconfig 去掉原来的 USB 鼠标驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig</span><br><span class="line">-&gt; Device Drivers </span><br><span class="line">-&gt; HID Devices</span><br><span class="line">&lt;&gt; USB Human Interface Device (full HID) support</span><br></pre></td></tr></table></figure></li><li><p>make uImage 并使用新的内核启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make uImage</span><br><span class="line">$ cp arch/arm/boot/uImage ~/</span><br></pre></td></tr></table></figure><ul><li><p>使用新内核启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJTAG&gt; nfs 30000000 192.168.1.5:/work/nfs_root/uImage_nohid:bootm 30000000</span><br></pre></td></tr></table></figure></li><li><p>启动后，挂载网络文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mout -t nfs -o nolock,vers=2 192.168.1.5:/work/nfs_root/first_fs /mnt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>装载驱动     </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod usbmouse_as_key</span><br><span class="line">$ insmod usbmouse_as_key.ko</span><br></pre></td></tr></table></figure></li><li><p>接上USB鼠标</p></li><li><p>查看设备的 event 接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /dev/event*</span><br></pre></td></tr></table></figure></li><li><p>操作鼠标观察其产生的数据<br> 不同鼠标的数据不一样，参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data cnt 299: 00 00 00 00 00 00 00 00   ---  (分析数据含义)</span><br><span class="line">              -----------------------</span><br><span class="line">              00 00|00 00|00 00|00 00</span><br><span class="line">              按键 | X   |  Y  | 滚轮</span><br><span class="line">                  |  正负值区分方向</span><br></pre></td></tr></table></figure></li></ol><h2 id="完整的-USB-鼠标驱动程序"><a href="#完整的-USB-鼠标驱动程序" class="headerlink" title="完整的 USB 鼠标驱动程序"></a>完整的 USB 鼠标驱动程序</h2><ul><li>主要是在上节代码的基础上，完善中断处理函数，在中断处理函数中添加对应的事件，实现鼠标按键的效果：<ul><li>左键 — L</li><li>右键 — S</li><li>中键 — 回车<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux-2.6.22.6 -&gt;</span></span><br><span class="line"><span class="comment"> * drivers\hid\usbhid\usbmouse.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/usb/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">uk_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *usb_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dma_addr_t</span> usb_buf_phys;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">uk_urb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">usbmouse_as_key_id_table</span> [] = &#123;</span></span><br><span class="line">&#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br><span class="line">USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//&#123;USB_DEVICE(0x1234,0x5678)&#125;,</span></span><br><span class="line">&#123; &#125;<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当 USB 主机控制器不断查询的过程中有数据到来时，其会将数据存入 buffer 中，然后产生一个中断，导致中断函数被调用(这里是 usbmouse_as_key_irq )。 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> pre_val;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">"data cnt %d: "</span>, ++cnt);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"%02x "</span>, usb_buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* USB鼠标数据含义</span></span><br><span class="line"><span class="comment"> * data[0]: bit0-左键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment"> *          bit1-右键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment"> *          bit2-中键, 1-按下, 0-松开 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> ((pre_val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) != (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)))<span class="comment">// 按下了左键</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 左键发生了变化 */</span></span><br><span class="line">input_event(uk_dev, EV_KEY, KEY_L, (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) ? <span class="number">1</span> : <span class="number">0</span>);  <span class="comment">// 产生 EV_KEY 类 KEY_L 事件</span></span><br><span class="line">input_sync(uk_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pre_val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) != (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 右键发生了变化 */</span></span><br><span class="line">input_event(uk_dev, EV_KEY, KEY_S, (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">input_sync(uk_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pre_val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) != (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 中键发生了变化 */</span></span><br><span class="line">input_event(uk_dev, EV_KEY, KEY_ENTER, (usb_buf[<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">input_sync(uk_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre_val = usb_buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新提交urb */</span></span><br><span class="line">usb_submit_urb(uk_urb, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_probe</span><span class="params">(struct usb_interface *intf, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_host_interface</span> *<span class="title">interface</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line"><span class="keyword">int</span> pipe;</span><br><span class="line"></span><br><span class="line">interface = intf-&gt;cur_altsetting;</span><br><span class="line">endpoint = &amp;interface-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a. 分配一个input_dev */</span></span><br><span class="line">uk_dev = input_allocate_device(); <span class="comment">// ==&gt; input_free_device()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* b. 设置 */</span></span><br><span class="line"><span class="comment">/* b.1 能产生哪类事件 */</span></span><br><span class="line">set_bit(EV_KEY, uk_dev-&gt;evbit);</span><br><span class="line">set_bit(EV_REP, uk_dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.2 能产生哪些事件 */</span></span><br><span class="line">set_bit(KEY_L, uk_dev-&gt;keybit);</span><br><span class="line">set_bit(KEY_S, uk_dev-&gt;keybit);</span><br><span class="line">set_bit(KEY_ENTER, uk_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* c. 注册 */</span></span><br><span class="line">input_register_device(uk_dev);  <span class="comment">// ==&gt; input_unregister_device()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* d. 硬件相关操作 */</span></span><br><span class="line"><span class="comment">/* 数据传输 3 要素: 源,目的,长度 */</span></span><br><span class="line"><span class="comment">/* 源: USB 设备的某个端点 */</span></span><br><span class="line">pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目的: */</span></span><br><span class="line">usb_buf = usb_buffer_alloc(dev, len, GFP_ATOMIC, &amp;usb_buf_phys);  <span class="comment">// 分配 buffer ==&gt; usb_buffer_free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 长度: */</span></span><br><span class="line">len = endpoint-&gt;wMaxPacketSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用"3要素" */</span></span><br><span class="line"><span class="comment">/* 分配usb request block */</span></span><br><span class="line">uk_urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);  <span class="comment">// ==&gt; usb_free_urb()</span></span><br><span class="line"><span class="comment">/* 使用"3 要素设置 urb" */</span></span><br><span class="line">usb_fill_int_urb(uk_urb, dev, </span><br><span class="line"> pipe, usb_buf, len,<span class="comment">/* 源、目的、长度 */</span></span><br><span class="line"> usbmouse_as_key_irq, <span class="literal">NULL</span>, endpoint-&gt;bInterval);  <span class="comment">/* 中断函数(并不具有中断 CPU 的能力) 由 USB 主机控制器来查询 、 查询的频率(bInterval)*/</span></span><br><span class="line">uk_urb-&gt;transfer_dma = usb_buf_phys;  <span class="comment">/* 给出物理地址，这样 USB 主机控制器可以将数据放入指定的内存区域 */</span></span><br><span class="line">uk_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP; <span class="comment">/* 设置某些标记（可不理解含义） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用URB */</span></span><br><span class="line">usb_submit_urb(uk_urb, GFP_KERNEL);  <span class="comment">// 提交 URB ==&gt; usb_kill_urb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_disconnect</span><span class="params">(struct usb_interface *intf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">intf</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printk("disconnect usbmouse!\n");</span></span><br><span class="line">usb_kill_urb(uk_urb);<span class="comment">// kill urb ==&gt; usb_submit_urb()</span></span><br><span class="line">usb_free_urb(uk_urb);<span class="comment">// 释放 urb ==&gt; usb_alloc_urb()</span></span><br><span class="line"></span><br><span class="line">usb_buffer_free(dev, len, usb_buf, usb_buf_phys);  <span class="comment">// 释放 buffer ==&gt; usb_buffer_alloc()</span></span><br><span class="line">input_unregister_device(uk_dev);<span class="comment">// 注销 ==&gt; input_register_device()</span></span><br><span class="line">input_free_device(uk_dev);<span class="comment">//  ==&gt; input_allocate_device()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置usb_driver */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbmouse_as_key_driver</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"usbmouse_as_key_"</span>,</span><br><span class="line">.probe= usbmouse_as_key_probe,</span><br><span class="line">.disconnect= usbmouse_as_key_disconnect,</span><br><span class="line">.id_table= usbmouse_as_key_id_table,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">usbmouse_as_key_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 2. 注册 */</span></span><br><span class="line">usb_register(&amp;usbmouse_as_key_driver);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usbmouse_as_key_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">usb_deregister(&amp;usbmouse_as_key_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(usbmouse_as_key_init);</span><br><span class="line">module_exit(usbmouse_as_key_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ol><li><p>make menuconfig 去掉原来的 USB 鼠标驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make menuconfig</span><br><span class="line">-&gt; Device Drivers </span><br><span class="line">-&gt; HID Devices</span><br><span class="line">&lt;&gt; USB Human Interface Device (full HID) support</span><br></pre></td></tr></table></figure></li><li><p>make uImage 并使用新的内核启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make uImage</span><br><span class="line">$ cp arch/arm/boot/uImage ~/</span><br></pre></td></tr></table></figure><ul><li><p>使用新内核启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJTAG&gt; nfs 30000000 192.168.1.5:/work/nfs_root/uImage_nohid:bootm 30000000</span><br></pre></td></tr></table></figure></li><li><p>启动后，挂载网络文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mout -t nfs -o nolock,vers=2 192.168.1.5:/work/nfs_root/first_fs /mnt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>装载驱动     </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod usbmouse_as_key</span><br><span class="line">$ insmod usbmouse_as_key.ko</span><br></pre></td></tr></table></figure></li><li><p>接上USB鼠标</p></li><li><p>查看设备的 event 接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /dev/event*</span><br></pre></td></tr></table></figure></li><li><p>查看 tty1 控制终端，然后按鼠标键：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /dev/tty1</span><br></pre></td></tr></table></figure></li><li><p>或者直接查看对应的 event 接口的原始数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexdump /dev/event0   <span class="comment"># 理解其数据含义，参考：按键驱动程序</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/driver/usb_driver/usb_driver.jpg&quot; alt=&quot;usb_driver&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="driver" scheme="https://zhouyuebiao.cn/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>中断系统中的设备树(5)</title>
    <link href="https://zhouyuebiao.cn/2020/01/29/0043-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%AE%BE%E5%A4%87%E6%A0%91-5/"/>
    <id>https://zhouyuebiao.cn/2020/01/29/0043-设备树之中断系统中的设备树-5/</id>
    <published>2020-01-29T06:04:03.000Z</published>
    <updated>2020-01-29T07:03:09.724Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;待编写…</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;待编写…&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;百问网：&lt;a href=&quot;http://www.10
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="Device tree" scheme="https://zhouyuebiao.cn/tags/Device-tree/"/>
    
  </entry>
  
  <entry>
    <title>u-boot对设备树的支持(4)</title>
    <link href="https://zhouyuebiao.cn/2020/01/20/0042-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8Bu-boot%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E6%94%AF%E6%8C%81-4/"/>
    <id>https://zhouyuebiao.cn/2020/01/20/0042-设备树之u-boot对设备树的支持-4/</id>
    <published>2020-01-20T01:44:06.000Z</published>
    <updated>2020-01-29T07:03:06.363Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/device_tree/u-boot%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png" alt="devicetree"></p><h1 id="第01节-传递dtb给内核-r2-寄存器"><a href="#第01节-传递dtb给内核-r2-寄存器" class="headerlink" title="第01节_传递dtb给内核(r2 寄存器)"></a>第01节_传递dtb给内核(r2 寄存器)</h1><h2 id="u-boot-中的内核启动命令"><a href="#u-boot-中的内核启动命令" class="headerlink" title="u-boot 中的内核启动命令:"></a>u-boot 中的内核启动命令:</h2><p>&emsp;&emsp;无设备树时启动命令格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm &lt;uImage_addr&gt;                            <span class="comment">// 无设备树，如: bootm 0x30007FC0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有设备树的启动命令格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm &lt;uImage_addr&gt; &lt;initrd_addr&gt; &lt;dtb_addr&gt;   <span class="comment">// 有设备树</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比如 : </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 <span class="number">0x30007FC0</span> kernel;     <span class="comment">// 读内核 uImage 到内存 0x30007FC0</span></span><br><span class="line">nand read.jffs2 <span class="number">32000000</span> device_tree;  <span class="comment">// 读 dtb 到内存 32000000</span></span><br><span class="line">bootm <span class="number">0x30007FC0</span> - <span class="number">0x32000000</span>          <span class="comment">// 启动, 没有 initrd 时对应参数写为"-"（如果所使用的 uboot 不支持 initrd）</span></span><br></pre></td></tr></table></figure><h2 id="这个过程是怎样的呢？"><a href="#这个过程是怎样的呢？" class="headerlink" title="这个过程是怎样的呢？"></a>这个过程是怎样的呢？</h2><blockquote><p>bootm 命令怎么把 dtb_addr 写入 r2 寄存器传给内核?  </p></blockquote><p>&emsp;&emsp;根据 <strong>ARM 程序调用规则(ATPCS)</strong> 一个 C 函数即可实现，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_function(p0, p1, p2) <span class="comment">// p0 =&gt; r0, p1 =&gt; r1, p2 =&gt; r2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;内核代码中，<br>&emsp;&emsp;定义函数指针 the_kernel, 指向内核的启动地址,<br>&emsp;&emsp;然后执行: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* uboot代码， armlinux.c */</span></span><br><span class="line">do_bootm_linux()</span><br><span class="line">   the_kernel(<span class="number">0</span>, machine_id, <span class="number">0x32000000</span>); <span class="comment">// r0 =&gt; 0, r1 =&gt; machine id, r3 =&gt; dtb addr</span></span><br></pre></td></tr></table></figure><h2 id="dtb-addr-可以随便选吗"><a href="#dtb-addr-可以随便选吗" class="headerlink" title="dtb_addr 可以随便选吗?"></a>dtb_addr 可以随便选吗?</h2><ul><li>必须遵循两个原则:  <ul><li>不要破坏 u-boot 本身  </li><li>不要挡内核的路: 内核本身的空间不能占用, 内核要用到的内存区域也不能占用；内核启动时一般会在它所处位置的下边放置页表, 这块空间(一般是 0x4000 即 16K 字节)不能被占用  </li></ul></li></ul><p>&emsp;&emsp;JZ2440 内存使用情况:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                   ------------------------------</span><br><span class="line">0x33f80000       -&gt;|    u-boot                  |</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |    u-boot所使用的内存(栈等) |</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |          空闲区域           |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">                   ------------------------------</span><br><span class="line">0x30008000       -&gt;|      zImage                |</span><br><span class="line">                   ------------------------------  uImage = 64 字节的头部 + zImage</span><br><span class="line">0x30007FC0       -&gt;|      uImage 头部           |</span><br><span class="line">                   ------------------------------</span><br><span class="line">0x30004000       -&gt;|      内核创建的页表         |  head.S</span><br><span class="line">                   ------------------------------</span><br><span class="line">                   |                            |</span><br><span class="line">                   |                            |</span><br><span class="line">            -----&gt; ------------------------------</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            --- (内存基址 0x30000000)</span><br></pre></td></tr></table></figure><h2 id="确定内核存放的地址"><a href="#确定内核存放的地址" class="headerlink" title="确定内核存放的地址"></a>确定内核存放的地址</h2><blockquote><p>如何确定内核是放在 <strong>0x30008000</strong> 的位置？  </p></blockquote><p>&emsp;&emsp;进入内核的目录：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /work/system/<span class="built_in">cd</span> linux-4.19-rc3</span><br><span class="line">$ make uImage</span><br><span class="line">$ mkimage -l arch/arm/boot/uImage <span class="comment"># make uImage 工具</span></span><br><span class="line">Image Name:    Linux-4.19.0-rc3</span><br><span class="line">Created:       Fri oct 19 16:53:58 2018</span><br><span class="line">Image Type:    ARM Linux Kernel Image (uncompressed)</span><br><span class="line">Data Size:     3444952 Bytes=3364.21 kB=3.29 MB </span><br><span class="line">Load Address:  30008000</span><br><span class="line">Entry Point:   30008000</span><br></pre></td></tr></table></figure><h2 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h2><ol><li><p>可以启动:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 30000000 device_tree</span><br><span class="line">nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">bootm 0x30007FC0 - 30000000</span><br></pre></td></tr></table></figure></li><li><p>不可以启动: 内核启动时会使用 0x30004000 的内存来存放页表，dtb 会被破坏  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nand read.jffs2 30004000 device_tree</span><br><span class="line">nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">bootm 0x30007FC0 - 30004000</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/device_tree/u-boot%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84.png&quot; alt=&quot;devicetree&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;第01节-传递dtb给内核-r2-寄存器&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="Device tree" scheme="https://zhouyuebiao.cn/tags/Device-tree/"/>
    
  </entry>
  
  <entry>
    <title>内核对设备树的处理(3)</title>
    <link href="https://zhouyuebiao.cn/2020/01/11/0041-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%A4%84%E7%90%86-3/"/>
    <id>https://zhouyuebiao.cn/2020/01/11/0041-设备树之内核对设备树的处理-3/</id>
    <published>2020-01-11T00:05:51.000Z</published>
    <updated>2020-01-20T01:50:20.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;根据 devicetree-specification-v0.2.pdf p43 中的说明: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux uses DT data <span class="keyword">for</span> three major purposes:</span><br><span class="line">  1) platform identification,</span><br><span class="line">  2) runtime configuration, and</span><br><span class="line">  3) device population.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;本文根据这个过程分析内核对设备树的处理流程。 </p><h1 id="从源头分析"><a href="#从源头分析" class="headerlink" title="从源头分析"></a>从源头分析</h1><p>&emsp;&emsp;内核head.S对dtb的简单处理：</p><ul><li><p>bootloader启动内核时,会设置r0,r1,r2三个寄存器： </p><ul><li>r0 一般设置为 0; </li><li>r1 一般设置为 machine id (在使用设备树时该参数没有被使用);  </li><li>r2 一般设置 ATAGS 或 DTB 的开始地址 </li></ul></li><li><p>bootloader给内核传递的参数时有2种方法： </p><ul><li>ATAGS 或 DTB </li><li>ATAGS 传参方法： <ul><li>a. __lookup_processor_type : 使用汇编指令读取CPU ID, 根据该ID找到对应的proc_info_list结构体(里面含有这类CPU的初始化函数、信息) </li><li>b. __vet_atags             : 判断是否存在可用的ATAGS或DTB </li><li>c. __create_page_tables    : 创建页表, 即创建虚拟地址和物理地址的映射关系 </li><li>d. __enable_mmu            : 使能MMU, 以后就要使用虚拟地址了 </li><li>e. <strong>mmap_switched         : 上述函数里将会调用</strong>mmap_switched </li><li>f. 把bootloader传入的r2参数, 保存到变量__atags_pointer中 </li><li>g. 调用C函数start_kernel </li></ul></li></ul></li></ul><p>&emsp;&emsp;head.S/head-common.S 中:<br>&emsp;&emsp;&emsp;&emsp;把bootloader传来的r1值, 赋给了C变量: __machine_arch_type<br>&emsp;&emsp;&emsp;&emsp;把bootloader传来的r2值, 赋给了C变量: __atags_pointer     // dtb首地址 </p><h1 id="内核设备树中平台信息的处理-选择-machine-desc"><a href="#内核设备树中平台信息的处理-选择-machine-desc" class="headerlink" title="内核设备树中平台信息的处理 (选择 machine_desc)"></a>内核设备树中平台信息的处理 (选择 machine_desc)</h1><p>&emsp;&emsp;a. 设备树 dts 根节点的 compatible 属性列出了一系列的字符串,<br>&emsp;&emsp;&emsp;&emsp;表示它兼容的单板名,<br>&emsp;&emsp;&emsp;&emsp;从左到右列出的表示：从”最兼容”到次之 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* dts 声明了期望哪些 madine_desc */</span></span><br><span class="line">/&#123;</span><br><span class="line">    model = <span class="string">"SMDK2440"</span>;</span><br><span class="line">    compatible = <span class="string">"samsung,smdk2440"</span>,<span class="string">"samsung,smdk2410"</span>,<span class="string">"samsung,smdk24xx"</span>;</span><br><span class="line">    <span class="comment">/* 单板         最好                次之                第三选择 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;b. 内核中有多个 machine_desc ，每个 machine_desc 表明能支持哪些单板： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span>&#123;</span></span><br><span class="line">    .init;</span><br><span class="line">    .nr;</span><br><span class="line">    .dt_compat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>*<span class="keyword">const</span> smdk2440 dt_compat[]initconst=&#123;</span><br><span class="line">    <span class="string">"samsung,smdk2440"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MACHINE START（S3C2440,<span class="string">"SMDK2440"</span>）</span><br><span class="line">    <span class="comment">/*aintainer:Ben Dooks &lt;ben-linuxefluff.org&gt;*/</span></span><br><span class="line">    .atag offset  = <span class="number">0x100</span>,</span><br><span class="line">    ·dt compat    = smak240_dt_compat,</span><br><span class="line">    .init_irg     = s3c2440_init_irq,</span><br><span class="line">    .map_io       = smdk2440_map_io,</span><br><span class="line">    .init_machine = smdk2440_machine_init,</span><br><span class="line">    .init_time    = smdk2440 init time,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;其中有 dt_compat 成员, 它指向一个字符串数组, 里面表示该 machine_desc 支持哪些单板 </p><p>&emsp;&emsp;c. 有多个 machine_desc 跟 dts 吻合，选择哪个？<br>&emsp;&emsp;&emsp;&emsp;使用 compatile 属性的值,<br>&emsp;&emsp;&emsp;&emsp;跟<br>&emsp;&emsp;&emsp;&emsp;每一个 machine_desc.dt_compat<br>&emsp;&emsp;&emsp;&emsp;比较,<br>&emsp;&emsp;&emsp;&emsp;成绩为”吻合的 compatile 属性值的位置”, </p><p>&emsp;&emsp;&emsp;&emsp;成绩越低越匹配, 对应的 machine_desc 即被选中 </p><p>&emsp;&emsp;&emsp;&emsp;函数调用过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start_kernel <span class="comment">// init/main.c</span></span><br><span class="line">    setup_arch(&amp;command_line);  <span class="comment">// arch/arm/kernel/setup.c</span></span><br><span class="line">        mdesc = setup_machine_fdt(__atags_pointer);  <span class="comment">// arch/arm/kernel/devtree.c</span></span><br><span class="line">                    early_init_dt_verify(phys_to_virt(dt_phys)  <span class="comment">// 判断是否有效的dtb, drivers/of/ftd.c</span></span><br><span class="line">                                    initial_boot_params = params;</span><br><span class="line">                    mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);  <span class="comment">// 找到最匹配的machine_desc, drivers/of/ftd.c</span></span><br><span class="line">                                    <span class="keyword">while</span> ((data = get_next_compat(&amp;compat))) &#123;</span><br><span class="line">                                        score = of_flat_dt_match(dt_root, compat);</span><br><span class="line">                                        <span class="keyword">if</span> (score &gt; <span class="number">0</span> &amp;&amp; score &lt; best_score) &#123;</span><br><span class="line">                                            best_data = data;</span><br><span class="line">                                            best_score = score;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                    </span><br><span class="line">        machine_desc = mdesc;</span><br></pre></td></tr></table></figure><h1 id="内核对设备树中运行时配置信息的处理"><a href="#内核对设备树中运行时配置信息的处理" class="headerlink" title="内核对设备树中运行时配置信息的处理"></a>内核对设备树中运行时配置信息的处理</h1><p>&emsp;&emsp;函数调用过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start_kernel <span class="comment">// init/main.c</span></span><br><span class="line">    setup_arch(&amp;command_line);  <span class="comment">// arch/arm/kernel/setup.c</span></span><br><span class="line">        mdesc = setup_machine_fdt(__atags_pointer);  <span class="comment">// arch/arm/kernel/devtree.c</span></span><br><span class="line">                    early_init_dt_scan_nodes();      <span class="comment">// drivers/of/ftd.c</span></span><br><span class="line">                        <span class="comment">/* Retrieve various information from the /chosen node */</span></span><br><span class="line">                        of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Initialize &#123;size,address&#125;-cells info */</span></span><br><span class="line">                        of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Setup memory, calling early_init_dt_add_memory_arch */</span></span><br><span class="line">                        of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;a. /chosen 节点中 bootargs 属性的值, 存入全局变量： boot_command_line<br>&emsp;&emsp;b. 确定根节点的这 2 个属性的值: #address-cells, #size-cells<br>   存入全局变量: dt_root_addr_cells, dt_root_size_cells<br>&emsp;&emsp;c. 解析 /memory 中的 reg 属性, 提取出 “base, size”, 最终调用 memblock_add(base, size); </p><h1 id="dtb-转换为-device-node-unflatten"><a href="#dtb-转换为-device-node-unflatten" class="headerlink" title="dtb 转换为 device_node (unflatten)"></a>dtb 转换为 device_node (unflatten)</h1><p>&emsp;&emsp;函数调用过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">start_kernel <span class="comment">// init/main.c</span></span><br><span class="line">    setup_arch(&amp;command_line);  <span class="comment">// arch/arm/kernel/setup.c</span></span><br><span class="line">        arm_memblock_init(mdesc);   <span class="comment">// arch/arm/kernel/setup.c</span></span><br><span class="line">            early_init_fdt_reserve_self();</span><br><span class="line">                    <span class="comment">/* Reserve the dtb region */</span></span><br><span class="line">                    <span class="comment">// 把DTB所占区域保留下来, 即调用: memblock_reserve</span></span><br><span class="line">                    early_init_dt_reserve_memory_arch(__pa(initial_boot_params),</span><br><span class="line">                                    fdt_totalsize(initial_boot_params),</span><br><span class="line">                                    <span class="number">0</span>);           </span><br><span class="line">            early_init_fdt_scan_reserved_mem();  <span class="comment">// 根据dtb中的memreserve信息, 调用memblock_reserve</span></span><br><span class="line">            </span><br><span class="line">        unflatten_device_tree();    <span class="comment">// arch/arm/kernel/setup.c</span></span><br><span class="line">            __unflatten_device_tree(initial_boot_params, <span class="literal">NULL</span>, &amp;of_root,</span><br><span class="line">                        early_init_dt_alloc_memory_arch, <span class="literal">false</span>);            <span class="comment">// drivers/of/fdt.c</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* First pass, scan for size */</span></span><br><span class="line">                size = unflatten_dt_nodes(blob, <span class="literal">NULL</span>, dad, <span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* Allocate memory for the expanded device tree */</span></span><br><span class="line">                mem = dt_alloc(size + <span class="number">4</span>, __alignof__(struct device_node));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* Second pass, do actual unflattening */</span></span><br><span class="line">                unflatten_dt_nodes(blob, mem, dad, mynodes);</span><br><span class="line">                    populate_node</span><br><span class="line">                        np = unflatten_dt_alloc(mem, <span class="keyword">sizeof</span>(struct device_node) + allocl,</span><br><span class="line">                                    __alignof__(struct device_node));</span><br><span class="line">                        </span><br><span class="line">                        np-&gt;full_name = fn = ((<span class="keyword">char</span> *)np) + <span class="keyword">sizeof</span>(*np);</span><br><span class="line">                        </span><br><span class="line">                        populate_properties</span><br><span class="line">                                pp = unflatten_dt_alloc(mem, <span class="keyword">sizeof</span>(struct property),</span><br><span class="line">                                            __alignof__(struct property));</span><br><span class="line">                            </span><br><span class="line">                                pp-&gt;name   = (<span class="keyword">char</span> *)pname;</span><br><span class="line">                                pp-&gt;length = sz;</span><br><span class="line">                                pp-&gt;value  = (__be32 *)val;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;a. 在DTB文件中,<br>&emsp;&emsp;&emsp;&emsp;每一个节点都以 TAG(FDT_BEGIN_NODE, 0x00000001) 开始, 节点内部可以嵌套其他节点,<br>&emsp;&emsp;&emsp;&emsp;每一个属性都以 TAG(FDT_PROP, 0x00000003) 开始 </p><p>&emsp;&emsp;b. 每一个节点都转换为一个 device_node 结构体: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 来自节点中的name属性, 如果没有该属性, 则设为"NULL"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 来自节点中的device_type属性, 如果没有该属性, 则设为"NULL"</span></span><br><span class="line">    phandle phandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *full_name;  <span class="comment">// 节点的名字, node-name[@unit-address]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">properties</span>;</span>  <span class="comment">// 节点的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">property</span> *<span class="title">deadprops</span>;</span>    <span class="comment">/* removed properties */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">parent</span>;</span>   <span class="comment">// 节点的父亲</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">child</span>;</span>    <span class="comment">// 节点的孩子(子节点)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">device_node</span> *<span class="title">sibling</span>;</span>  <span class="comment">// 节点的兄弟(同级节点)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</span><br><span class="line">    <span class="keyword">void</span>    *data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path_component_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;c. device_node 结构体中有 properties, 用来表示该节点的属性<br>&emsp;&emsp;&emsp;&emsp;每一个属性对应一个 property 结构体: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    *name;    <span class="comment">// 属性名字, 指向dtb文件中的字符串</span></span><br><span class="line">    <span class="keyword">int</span> length;       <span class="comment">// 属性值的长度</span></span><br><span class="line">    <span class="keyword">void</span>    *value;   <span class="comment">// 属性值, 指向dtb文件中value所在位置, 数据仍以big endian存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_PROMTREE)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unique_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_OF_KOBJ)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;d. 这些 device_node 构成一棵树, 根节点为: of_root<br><img src="/images/device_tree/dtb%E8%BD%AC%E6%8D%A2%E4%B8%BAdevice_node.png" alt="dtb转换为device_node"></p><h1 id="device-node-转换为-platform-device"><a href="#device-node-转换为-platform-device" class="headerlink" title="device_node 转换为 platform_device"></a>device_node 转换为 platform_device</h1><p>&emsp;&emsp;从 dts 到 platform_device 的转化过程： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dts -&gt; dtb -&gt; device_node -&gt; platform_device</span><br></pre></td></tr></table></figure><h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h2><p>&emsp;&emsp;要理解这个过程得先理解这两个问题: </p><ol><li><p>哪些device_node可以转换为platform_device? </p><ul><li>根节点下含有compatile属性的子节点 </li><li>如果一个结点的compatile属性含有这些特殊的值(“simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus”)之一, 那么它的子结点(需含compatile属性)也可以转换为platform_device </li><li>i2c, spi等总线节点下的子节点, 应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device </li></ul></li><li><p>怎么转换? </p><ul><li>platform_device中含有resource数组, 它来自device_node的reg, interrupts属性; </li><li>platform_device.dev.of_node指向device_node, 可以通过它获得其他属性 </li></ul></li></ol><h2 id="内核的处理过程"><a href="#内核的处理过程" class="headerlink" title="内核的处理过程"></a>内核的处理过程</h2><ol><li>内核函数 of_platform_default_populate_init, 遍历 device_node 树, 生成 platform_device </li><li>并非所有的 device_node 都会转换为 platform_device </li></ol><ul><li>只有以下的 device_node 会转换: <ul><li>该节点必须含有compatible属性 </li><li>根节点的子节点(节点必须含有compatible属性) </li><li>含有特殊compatible属性的节点的子节点(子节点必须含有compatible属性): <ul><li>这些特殊的compatilbe属性为: “simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus” </li></ul></li></ul></li></ul><p>&emsp;&emsp;示例:<br>&emsp;&emsp;假设当前接入设备如下：<br><img src="/images/device_tree/device_node%E8%BD%AC%E6%8D%A2%E4%B8%BAplatform_device%E7%9A%84%E5%81%87%E6%83%B3%E8%AE%BE%E5%A4%87.png" alt="dtb转换为device_node"></p><p>&emsp;&emsp;比如以下的节点,  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">        i2c &#123;                           <span class="comment">// --&gt; platform_device &lt;--&gt; platform_driver.probe</span></span><br><span class="line">            compatile = <span class="string">"samsung,i2c"</span>;</span><br><span class="line">            at24c02 &#123;                   <span class="comment">// 交给 probe 处理转换为 I2C_client</span></span><br><span class="line">                compatile = <span class="string">"at24c02"</span>;                      </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        spi &#123;</span><br><span class="line">            compatile = <span class="string">"samsung,spi"</span>;              </span><br><span class="line">            flash@<span class="number">0</span> &#123;                   <span class="comment">// spi_device</span></span><br><span class="line">                compatible = <span class="string">"winbond,w25q32dw"</span>;</span><br><span class="line">                spi-max-frequency = &lt;<span class="number">25000000</span>&gt;;</span><br><span class="line">                reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        led &#123;</span><br><span class="line">            compatile = <span class="string">"jz2550_led"</span>;              </span><br><span class="line">            reg = &lt;<span class="number">5</span>, <span class="number">1</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mytest &#123;</span><br><span class="line">            compatile = <span class="string">"mytest"</span>, <span class="string">"simple-bus"</span>; <span class="comment">// 如果有 "simple-bus" ，mytest 会转换为 platform_device</span></span><br><span class="line">            mytest@<span class="number">0</span> &#123;</span><br><span class="line">                compatile = <span class="string">"mytest_0"</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;/mytest会被转换为platform_device,<br>&emsp;&emsp;因为它兼容”simple-bus”, 它的子节点/mytest/mytest@0 也会被转换为platform_device </p><p>&emsp;&emsp;/i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;<br>&emsp;&emsp;/i2c/at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个i2c_client。 </p><p>&emsp;&emsp;类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;<br>&emsp;&emsp;/spi/flash@0节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">        mytest &#123;</span><br><span class="line">            compatile = <span class="string">"mytest"</span>, <span class="string">"simple-bus"</span>;</span><br><span class="line">            mytest@<span class="number">0</span> &#123;</span><br><span class="line">                compatile = <span class="string">"mytest_0"</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        i2c &#123;</span><br><span class="line">            compatile = <span class="string">"samsung,i2c"</span>;</span><br><span class="line">            at24c02 &#123;</span><br><span class="line">                compatile = <span class="string">"at24c02"</span>;                      </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        spi &#123;</span><br><span class="line">            compatile = <span class="string">"samsung,spi"</span>;              </span><br><span class="line">            flash@<span class="number">0</span> &#123;</span><br><span class="line">                compatible = <span class="string">"winbond,w25q32dw"</span>;</span><br><span class="line">                spi-max-frequency = &lt;<span class="number">25000000</span>&gt;;</span><br><span class="line">                reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><h3 id="调用-of-platform-default-populate-init-函数"><a href="#调用-of-platform-default-populate-init-函数" class="headerlink" title="调用 of_platform_default_populate_init 函数"></a>调用 of_platform_default_populate_init 函数</h3><p>&emsp;&emsp;of_platform_default_populate_init (drivers/of/platform.c) 被调用的过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start_kernel     <span class="comment">// init/main.c</span></span><br><span class="line">    rest_init();</span><br><span class="line">        pid = kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">                    kernel_init</span><br><span class="line">                        kernel_init_freeable();</span><br><span class="line">                            do_basic_setup();</span><br><span class="line">                                do_initcalls();</span><br><span class="line">                                    <span class="keyword">for</span> (level = <span class="number">0</span>; level &lt; ARRAY_SIZE(initcall_levels) - <span class="number">1</span>; level++)</span><br><span class="line">                                        do_initcall_level(level);  <span class="comment">// 比如 do_initcall_level(3)</span></span><br><span class="line">                                                                            <span class="keyword">for</span> (fn = initcall_levels[<span class="number">3</span>]; fn &lt; initcall_levels[<span class="number">3</span>+<span class="number">1</span>]; fn++)</span><br><span class="line">                                                                                    do_one_initcall(initcall_from_entry(fn));  <span class="comment">// 就是调用"arch_initcall_sync(fn)"中定义的fn函数</span></span><br></pre></td></tr></table></figure><h3 id="调用-of-platform-default-populate-init-函数-1"><a href="#调用-of-platform-default-populate-init-函数-1" class="headerlink" title="调用 of_platform_default_populate_init 函数"></a>调用 of_platform_default_populate_init 函数</h3><p>&emsp;&emsp;of_platform_default_populate_init  (drivers/of/platform.c) 生成platform_device的过程: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">of_platform_default_populate_init</span><br><span class="line">    of_platform_default_populate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        of_platform_populate(<span class="literal">NULL</span>, of_default_bus_match_table, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">            for_each_child_of_node(root, child) &#123;</span><br><span class="line">                rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);  <span class="comment">// 调用过程看下面</span></span><br><span class="line">                            dev = of_device_alloc(np, bus_id, parent);   <span class="comment">// 根据device_node节点的属性设置platform_device的resource</span></span><br><span class="line">                <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">                    of_node_put(child);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="调用-of-platform-bus-create-函数"><a href="#调用-of-platform-bus-create-函数" class="headerlink" title="调用 of_platform_bus_create 函数"></a>调用 of_platform_bus_create 函数</h3><p>&emsp;&emsp;of_platform_bus_create(bus, matches, …)的调用过程(处理bus节点生成platform_devie, 并决定是否处理它的子节点): </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);  <span class="comment">// 生成bus节点的platform_device结构体</span></span><br><span class="line"><span class="keyword">if</span> (!dev || !of_match_node(matches, bus))  <span class="comment">// 如果bus节点的compatile属性不吻合matches成表, 就不处理它的子节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">for_each_child_of_node(bus, child) &#123;    <span class="comment">// 取出每一个子节点</span></span><br><span class="line">    pr_debug(<span class="string">"   create child: %pOF\n"</span>, child);</span><br><span class="line">    rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);   <span class="comment">// 处理它的子节点, of_platform_bus_create是一个递归调用</span></span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        of_node_put(child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I2C-总线节点的处理过程"><a href="#I2C-总线节点的处理过程" class="headerlink" title="I2C 总线节点的处理过程"></a>I2C 总线节点的处理过程</h3><p>&emsp;&emsp;/i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;<br>&emsp;&emsp;platform_driver的probe函数中会调用i2c_add_numbered_adapter: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i2c_add_numbered_adapter   <span class="comment">// drivers/i2c/i2c-core-base.c</span></span><br><span class="line">     __i2c_add_numbered_adapter</span><br><span class="line">         i2c_register_adapter</span><br><span class="line">             of_i2c_register_devices(adap);   <span class="comment">// drivers/i2c/i2c-core-of.c</span></span><br><span class="line">                 for_each_available_child_of_node(bus, node) &#123;</span><br><span class="line">                     client = of_i2c_register_device(adap, node);</span><br><span class="line">                                     client = i2c_new_device(adap, &amp;info);   <span class="comment">// 设备树中的i2c子节点被转换为i2c_client</span></span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><h3 id="SPI-总线节点的处理过程"><a href="#SPI-总线节点的处理过程" class="headerlink" title="SPI 总线节点的处理过程"></a>SPI 总线节点的处理过程</h3><p>&emsp;&emsp;/spi节点一般表示spi控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;<br>&emsp;&emsp;platform_driver的probe函数中会调用spi_register_master, 即spi_register_controller: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   spi_register_controller        <span class="comment">// drivers/spi/spi.c</span></span><br><span class="line">        of_register_spi_devices   <span class="comment">// drivers/spi/spi.c</span></span><br><span class="line">            for_each_available_child_of_node(ctlr-&gt;dev.of_node, nc) &#123;</span><br><span class="line">                spi = of_register_spi_device(ctlr, nc);  <span class="comment">// 设备树中的spi子节点被转换为spi_device</span></span><br><span class="line">                                spi = spi_alloc_device(ctlr);</span><br><span class="line">                                rc = of_spi_parse_dt(ctlr, spi, nc);</span><br><span class="line">                                rc = spi_add_device(spi);</span><br><span class="line">            &#125;</span><br><span class="line">```                   </span><br><span class="line"></span><br><span class="line"># platform_device 与 platform_driver 的匹配</span><br><span class="line">&amp;emsp;&amp;emsp;参考内核代码： </span><br><span class="line">```bash</span><br><span class="line">    drivers/base/platform.c</span><br></pre></td></tr></table></figure><h2 id="注册-platform-driver-的过程"><a href="#注册-platform-driver-的过程" class="headerlink" title="注册 platform_driver 的过程:"></a>注册 platform_driver 的过程:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform_driver_register</span><br><span class="line">    __platform_driver_register</span><br><span class="line">        drv-&gt;driver.probe = platform_drv_probe;</span><br><span class="line">        driver_register</span><br><span class="line">            bus_add_driver</span><br><span class="line">                klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);    <span class="comment">// 把 platform_driver 放入 platform_bus_type 的driver链表中</span></span><br><span class="line">                driver_attach</span><br><span class="line">                    bus_for_each_dev(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach);  <span class="comment">// 对于plarform_bus_type下的每一个设备, 调用__driver_attach</span></span><br><span class="line">                        __driver_attach</span><br><span class="line">                            ret = driver_match_device(drv, dev);  <span class="comment">// 判断dev和drv是否匹配成功</span></span><br><span class="line">                                        <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;  <span class="comment">// 调用 platform_bus_type.match</span></span><br><span class="line">                            driver_probe_device(drv, dev);</span><br><span class="line">                                        really_probe</span><br><span class="line">                                            drv-&gt;probe  <span class="comment">// platform_drv_probe</span></span><br><span class="line">                                                platform_drv_probe</span><br><span class="line">                                                    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">drv</span> = <span class="title">to_platform_driver</span>(_<span class="title">dev</span>-&gt;<span class="title">driver</span>);</span></span><br><span class="line">                                                    drv-&gt;probe</span><br></pre></td></tr></table></figure><h2 id="注册-platform-device-的过程"><a href="#注册-platform-device-的过程" class="headerlink" title="注册 platform_device 的过程:"></a>注册 platform_device 的过程:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">    platform_device_add</span><br><span class="line">        device_add</span><br><span class="line">            bus_add_device</span><br><span class="line">                klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices); <span class="comment">// 把 platform_device 放入 platform_bus_type的device链表中</span></span><br><span class="line">            bus_probe_device(dev);</span><br><span class="line">                device_initial_probe</span><br><span class="line">                    __device_attach</span><br><span class="line">                        ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, &amp;data, __device_attach_driver); <span class="comment">// // 对于plarform_bus_type下的每一个driver, 调用 __device_attach_driver</span></span><br><span class="line">                                    __device_attach_driver</span><br><span class="line">                                        ret = driver_match_device(drv, dev);</span><br><span class="line">                                                    <span class="keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="number">1</span>;  <span class="comment">// 调用platform_bus_type.match</span></span><br><span class="line">                                        driver_probe_device</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;匹配函数是 platform_bus_type.match, 即 platform_match,<br>&emsp;&emsp;匹配过程按优先顺序罗列如下: </p><ol><li>比较 platform_dev.driver_override 和 platform_driver.drv-&gt;name </li><li>比较 platform_dev.dev.of_node的compatible属性 和 platform_driver.drv-&gt;of_match_table </li><li>比较 platform_dev.name 和 platform_driver.id_table </li><li>比较 platform_dev.name 和 platform_driver.drv-&gt;name </li></ol><blockquote><p>有一个成功, 即匹配成功 </p></blockquote><h1 id="内核中设备树的操作函数"><a href="#内核中设备树的操作函数" class="headerlink" title="内核中设备树的操作函数"></a>内核中设备树的操作函数</h1><p>&emsp;&emsp;参考内核源代码 include/linux/ 目录下有很多 of 前缀开头的文件，这些就是内核中操作设备树的函数，下面对这些文件的作用作一个简单的说明。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理DTB */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_fdt.h&gt;           // dtb文件的相关操作函数, 我们一般用不到, 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理device_node */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of.h&gt;                // 提供设备树的一般处理函数, 比如 of_property_read_u32(读取某个属性的u32值), of_get_child_count(获取某个device_node的子节点数)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_address.h&gt;        // 地址相关的函数, 比如 of_get_address(获得reg属性中的addr, size值)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;of_match_device(从matches数组中取出与当前设备最匹配的一项)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_dma.h&gt;            // 设备树中DMA相关属性的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_gpio.h&gt;           // GPIO相关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_graph.h&gt;          // GPU相关驱动中用到的函数, 从设备树中获得GPU信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_iommu.h&gt;          // 很少用到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_irq.h&gt;            // 中断相关的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_mdio.h&gt;           // MDIO (Ethernet PHY) API</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_net.h&gt;            // OF helpers for network devices. </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_pci.h&gt;            // PCI相关函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_pdt.h&gt;            // 很少用到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_reserved_mem.h&gt;   // reserved_mem的相关函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理 platform_device */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_platform.h&gt;       // 把device_node转换为platform_device时用到的函数, </span></span></span><br><span class="line">                                    <span class="comment">// 比如： of_device_alloc (根据 device_node 分配设置 platform_device), </span></span><br><span class="line">                                    <span class="comment">//        of_find_device_by_node (根据 device_node 查找到 platform_device),</span></span><br><span class="line">                                    <span class="comment">//        of_platform_bus_probe (处理 device_node 及它的子节点)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;of_device.h&gt;         // 设备相关的函数, 比如 of_match_device</span></span></span><br></pre></td></tr></table></figure><h1 id="在根文件系统中查看设备树-有助于调试"><a href="#在根文件系统中查看设备树-有助于调试" class="headerlink" title="在根文件系统中查看设备树(有助于调试)"></a>在根文件系统中查看设备树(有助于调试)</h1><h2 id="原始-dtb-文件的存放位置"><a href="#原始-dtb-文件的存放位置" class="headerlink" title="原始 dtb 文件的存放位置"></a>原始 dtb 文件的存放位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/firmware/fdt</span><br></pre></td></tr></table></figure><h2 id="16-进制查看-dtb-文件"><a href="#16-进制查看-dtb-文件" class="headerlink" title="16 进制查看 dtb 文件"></a>16 进制查看 dtb 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C /sys/firmware/fdt</span><br></pre></td></tr></table></figure><h2 id="查看以目录结构存放的-dtb-文件"><a href="#查看以目录结构存放的-dtb-文件" class="headerlink" title="查看以目录结构存放的 dtb 文件"></a>查看以目录结构存放的 dtb 文件</h2><p>&emsp;&emsp;以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/firmware/devicetree</span><br></pre></td></tr></table></figure><h2 id="查看系统中所有的-platform-device"><a href="#查看系统中所有的-platform-device" class="headerlink" title="查看系统中所有的 platform_device"></a>查看系统中所有的 platform_device</h2><p>&emsp;&emsp;系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的<br>&emsp;&emsp;对于来自设备树的platform_device,<br>&emsp;&emsp;可以进入 /sys/devices/platform/&lt;设备名&gt;/of_node 查看它的设备树属性 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/platform</span><br></pre></td></tr></table></figure><h2 id="proc-device-tree-文件"><a href="#proc-device-tree-文件" class="headerlink" title="/proc/device-tree 文件"></a>/proc/device-tree 文件</h2><p>&emsp;&emsp;/proc/device-tree 是链接文件, 指向 /sys/firmware/devicetree/base </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;根据 devicetree-specification-v0.2.pdf p43 中的说明: &lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="Device tree" scheme="https://zhouyuebiao.cn/tags/Device-tree/"/>
    
  </entry>
  
  <entry>
    <title>设备树之设备树的规范(2)</title>
    <link href="https://zhouyuebiao.cn/2020/01/05/0040-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E8%A7%84%E8%8C%83-2/"/>
    <id>https://zhouyuebiao.cn/2020/01/05/0040-设备树之设备树的规范-2/</id>
    <published>2020-01-05T06:10:41.000Z</published>
    <updated>2020-01-11T00:51:53.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/device_tree/devicetree.png" alt="devicetree"></p><h1 id="DTS格式"><a href="#DTS格式" class="headerlink" title="DTS格式"></a>DTS格式</h1><h2 id="DTS的语法"><a href="#DTS的语法" class="headerlink" title="DTS的语法"></a>DTS的语法</h2><h3 id="Devicetree-node（节点）格式"><a href="#Devicetree-node（节点）格式" class="headerlink" title="Devicetree node（节点）格式"></a>Devicetree node（节点）格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">[properties definitions]</span><br><span class="line">[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="properties-的命名格式"><a href="#properties-的命名格式" class="headerlink" title="properties 的命名格式"></a>properties 的命名格式</h4><p>&emsp;&emsp;properties 有两种命名格式</p><ol><li><p>Property (属性名)格式1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure></li><li><p>Property(属性名)格式2(没有值):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name;</span><br></pre></td></tr></table></figure></li></ol><h4 id="properties-的取值"><a href="#properties-的取值" class="headerlink" title="properties 的取值"></a>properties 的取值</h4><p>&emsp;&emsp;Property (属性名)取值只有 3 种: </p><ol><li>arrays of cells<ul><li>1 个或多个 32 位数据, 64 位数据使用 2 个 32 位数据表示), </li></ul></li><li>string<ul><li>字符串: “str”, </li></ul></li><li>bytestring<ul><li>16 进制表示的 1 个或多个字节，中括号: []。</li><li>一个 byte 用 2 位 16 进制数表示，如： 00 必须写成 00，不可写成 0。</li><li>byte之间的空格可省略： [001122] 或者 [00 11 22]</li></ul></li></ol><blockquote><p>这三种形式可组合使用。</p></blockquote><h4 id="properties-的取值示例"><a href="#properties-的取值示例" class="headerlink" title="properties 的取值示例:"></a>properties 的取值示例:</h4><p>&emsp;&emsp;a. Arrays of cells : cell就是一个 32 位的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">17</span> <span class="number">0xc</span>&gt;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;b. 64 bit 数据使用 2 个 cell 来表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;c. A null-terminated string (有结束符的字符串):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">"simple-bus"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;d. A bytestring(字节序列) :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local-mac-address = [<span class="number">00</span> <span class="number">00</span> <span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];  <span class="comment">// 每个byte使用 2 个 16 进制数来表示</span></span><br><span class="line">local-mac-address = [<span class="number">000012345678</span>];       <span class="comment">// 每个byte使用 2 个 16 进制数来表示</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;e. 可以是各种值的组合, 用逗号隔开:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">"ns16550"</span>, <span class="string">"ns8250"</span>;</span><br><span class="line">example = &lt;<span class="number">0xf00f0000</span> <span class="number">19</span>&gt;, <span class="string">"a strange property format"</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/device_tree/DTS%E6%A0%BC%E5%BC%8F.png" alt="DTS格式"></p><h2 id="DTS-文件的基本布局-layout"><a href="#DTS-文件的基本布局-layout" class="headerlink" title="DTS 文件的基本布局(layout)"></a>DTS 文件的基本布局(layout)</h2><p>&emsp;&emsp;一个最基本的 dts 文件示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;    <span class="comment">// 版本</span></span><br><span class="line">[memory reservations]   <span class="comment">// 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;; （给自己使用不希望内核使用的，保留的内存区域，如果希望内核使用全部的内存区域省略此项即可）</span></span><br><span class="line">                            <span class="comment">// 留1MB的内存给自己使用，示例： /memreserve/ 0x33000000 0x10000;</span></span><br><span class="line"><span class="comment">// 设备树的起点（根节点）</span></span><br><span class="line">/ &#123;</span><br><span class="line">    [property definitions]  <span class="comment">// 属性-描述硬件的信息</span></span><br><span class="line">    [child nodes]<span class="comment">// 子节点，子节点中可分出各种节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="特殊的、默认的属性"><a href="#特殊的、默认的属性" class="headerlink" title="特殊的、默认的属性"></a>特殊的、默认的属性</h2><p>&emsp;&emsp;a. 根节点:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells   <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)</span></span></span><br><span class="line"><span class="meta">#size-cells      <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)</span></span></span><br><span class="line">compatible       <span class="comment">// 定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备</span></span><br><span class="line">                    <span class="comment">// 即这个板子兼容哪些平台 </span></span><br><span class="line">                    <span class="comment">// uImage : smdk2410 smdk2440 mini2440     ==&gt; machine_desc   // 有不同的初始化函数</span></span><br><span class="line">                    </span><br><span class="line">model            <span class="comment">// 咱这个板子是什么</span></span><br><span class="line">                    <span class="comment">// 比如有2款板子配置基本一致, 它们的compatible是一样的</span></span><br><span class="line">                    <span class="comment">// 那么就通过model来分辨这2款板子</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;b. /memory</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_type = <span class="string">"memory"</span>;</span><br><span class="line">reg             <span class="comment">// 用来指定内存的地址、大小</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;c. /chosen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootargs        <span class="comment">// 内核command line参数, 跟u-boot中设置的bootargs作用一样</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;d. /cpus<br>&emsp;&emsp;&emsp;&emsp;/cpus 节点下有 1 个或多个 cpu 子节点, cpu 子节点中用 reg 属性用来标明自己是哪一个 cpu<br>&emsp;&emsp;所以 /cpus 中有以下2个属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells   <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)</span></span></span><br><span class="line"><span class="meta">#size-cells      <span class="comment">// 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)</span></span></span><br><span class="line">                    <span class="comment">// 必须设置为0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;e. /cpus/cpu*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_type = <span class="string">"cpu"</span>;</span><br><span class="line">reg             <span class="comment">// 表明自己是哪一个 cpu</span></span><br></pre></td></tr></table></figure><h2 id="如何引用其他节点"><a href="#如何引用其他节点" class="headerlink" title="如何引用其他节点"></a>如何引用其他节点</h2><p>&emsp;&emsp;a. phandle : // 节点中的 phandle 属性, 它的取值必须是唯一的(不要跟其他的 phandle 值一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span> &#123;</span><br><span class="line">    phandle = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">another-device-node &#123;</span><br><span class="line">    interrupt-parent = &lt;<span class="number">1</span>&gt;;   <span class="comment">// 使用phandle值为1来引用上述节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;b. label:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PIC: pic@<span class="number">10000000</span> &#123;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">another-device-node &#123;</span><br><span class="line">    interrupt-parent = &lt;&amp;PIC&gt;;   <span class="comment">// 使用 label 来引用上述节点, </span></span><br><span class="line">                                    <span class="comment">// 使用 lable 时实际上也是使用phandle来引用, </span></span><br><span class="line">                                    <span class="comment">// 在编译 dts 文件为dtb文件时, 编译器 dtc 会在 dtb 中插入 phandle 属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dts-文件可以包含-dtsi-文件"><a href="#dts-文件可以包含-dtsi-文件" class="headerlink" title="dts 文件可以包含 dtsi 文件"></a>dts 文件可以包含 dtsi 文件</h3><p>&emsp;&emsp;比较公共的文件的命名为：“<em>.dtsi”,“</em>.dts”文件可以包含“<em>.dtsi”文件；包含之后“</em>.dts”文件中重新定义的内容会覆盖“*.dtsi”文件的内容。<br>&emsp;&emsp;jz2440.dts 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SAMSUNG SMDK2440 board device tree source</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Copyright (c) 2018 weidongshan@qq.com</span></span><br><span class="line"><span class="comment">* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jz2440.dtsi"</span></span></span><br><span class="line">&amp;LED &#123;</span><br><span class="line">pin = &lt;S3C2410_GPF(<span class="number">7</span>)&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;jz2440.dtsi 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SAMSUNG SMDK2440 board device tree source</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Copyright (c) 2018 weidongshan@qq.com</span></span><br><span class="line"><span class="comment">* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPA(_nr)((0&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPB(_nr)((1&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPC(_nr)((2&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPD(_nr)((3&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPE(_nr)((4&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPF(_nr)((5&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPG(_nr)((6&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPH(_nr)((7&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPJ(_nr)((8&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPK(_nr)((9&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPL(_nr)((10&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPM(_nr)((11&lt;&lt;16) + (_nr))</span></span><br><span class="line"></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">model = <span class="string">"SMDK24440"</span>;</span><br><span class="line">compatible = <span class="string">"samsung,smdk2440"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"><span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"></span><br><span class="line">memory &#123;  <span class="comment">/* /memory */</span></span><br><span class="line">device_type = <span class="string">"memory"</span>;</span><br><span class="line">reg =  &lt;<span class="number">0x30000000</span> <span class="number">0x4000000</span> <span class="number">0</span> <span class="number">4096</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cpus &#123;</span></span><br><span class="line"><span class="comment">cpu &#123;</span></span><br><span class="line"><span class="comment">compatible = "arm,arm926ej-s";</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chosen &#123;</span><br><span class="line">bootargs = <span class="string">"noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LED: led &#123;</span><br><span class="line">compatible = <span class="string">"jz2440_led"</span>;</span><br><span class="line">pin = &lt;S3C2410_GPF(<span class="number">5</span>)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="编译得出-dtb-文件"><a href="#编译得出-dtb-文件" class="headerlink" title="编译得出 dtb 文件"></a>编译得出 dtb 文件</h4><p>&emsp;&emsp;编译路径（Linux 4.19 内核路径）: /work/system/linux-4.19-rc3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/<span class="built_in">local</span>/games:/usr/<span class="built_in">local</span>/arm/4.3.2/bin</span><br><span class="line">make dtbs <span class="comment"># 得到dtb文件</span></span><br></pre></td></tr></table></figure><h2 id="将dtb文件反汇编为dts文件"><a href="#将dtb文件反汇编为dts文件" class="headerlink" title="将dtb文件反汇编为dts文件"></a>将dtb文件反汇编为dts文件</h2><p>&emsp;&emsp;使用 ./scripts/dtc/dtc 可将dtb文件反汇编为dts文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -0 dts -o tmp.dts arch/arm/boot/dts/jz2440.dtb</span><br><span class="line">vi tmp.dts</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;官方文档: <a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">https://www.devicetree.org/specifications/</a><br>&emsp;&emsp;查看内核描述文件 <a href>Documentation/devicetree/booting-without-of.txt</a> 对设备树的描述进行了总结：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux uses DT data <span class="keyword">for</span> three major purposes:</span><br><span class="line">1) platform identification,// 平台信息，根节点中前面的信息： model compatible, address-cells, size-cells....</span><br><span class="line">2) runtime configuration, and// 运行时的配置信息，如：chosen, [memory reservations]</span><br><span class="line">3) device population// 描述设备：如：各个node</span><br></pre></td></tr></table></figure><h1 id="DTB格式"><a href="#DTB格式" class="headerlink" title="DTB格式"></a>DTB格式</h1><p>&emsp;&emsp;DTB 中使用大端模式。（无论是大端还是小端，都只是对数值的储存的有影响，对字符串没有影响？）</p><h2 id="fdt-header结构体"><a href="#fdt-header结构体" class="headerlink" title="fdt_header结构体"></a>fdt_header结构体</h2><p>&emsp;&emsp;参考文档： <a href>devicetree-specification-v0.2.pdf</a> p43 中的 fdt_header 结构体信息可对照 dtb 文件内容得出对应的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> magic;</span><br><span class="line"><span class="keyword">uint32_t</span> totalsize;    <span class="comment">// 整个dtb文件的大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> off_dt_struct;</span><br><span class="line"><span class="keyword">uint32_t</span> off_dt_strings;</span><br><span class="line"><span class="keyword">uint32_t</span> off_mem_rsvmap; <span class="comment">// 保留的内存区域的偏移地址</span></span><br><span class="line"><span class="keyword">uint32_t</span> version;</span><br><span class="line"><span class="keyword">uint32_t</span> last_comp_version;</span><br><span class="line"><span class="keyword">uint32_t</span> boot_cpuid_phys;</span><br><span class="line"><span class="keyword">uint32_t</span> size_dt_strings;</span><br><span class="line"><span class="keyword">uint32_t</span> size_dt_struct;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;fdt_header 中各个成员的说明：<br><img src="/images/device_tree/Flattened_Devicetree_Header_Fields.png" alt="Flattened_Devicetree_Header_Fields"></p><h2 id="DTB文件布局"><a href="#DTB文件布局" class="headerlink" title="DTB文件布局"></a>DTB文件布局</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        ------------------------------</span><br><span class="line">base -&gt; |  struct boot_param_header  |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      (alignment gap) (*)   |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      memory reserve map    |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      (alignment gap)       |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |                            |</span><br><span class="line">        |    device-tree structure   |</span><br><span class="line">        |                            |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |      (alignment gap)       |</span><br><span class="line">        ------------------------------</span><br><span class="line">        |                            |</span><br><span class="line">        |     device-tree strings    |</span><br><span class="line">        |                            |</span><br><span class="line">-----&gt; ------------------------------</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">--- (base + totalsize)</span><br></pre></td></tr></table></figure><h2 id="分析示例"><a href="#分析示例" class="headerlink" title="分析示例"></a>分析示例</h2><h3 id="示例使用的-dts-文件"><a href="#示例使用的-dts-文件" class="headerlink" title="示例使用的 dts 文件"></a>示例使用的 dts 文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jz2440.dts */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SAMSUNG SMDK2440 board device tree source</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Copyright (c) 2018 weidongshan@qq.com</span></span><br><span class="line"><span class="comment">* dtc -I dtb -O dts -o jz2440.dts jz2440.dtb</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPA(_nr)((0&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPB(_nr)((1&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPC(_nr)((2&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPD(_nr)((3&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPE(_nr)((4&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPF(_nr)((5&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPG(_nr)((6&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPH(_nr)((7&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPJ(_nr)((8&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPK(_nr)((9&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPL(_nr)((10&lt;&lt;16) + (_nr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2410_GPM(_nr)((11&lt;&lt;16) + (_nr))</span></span><br><span class="line"></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line">/memreserve/ <span class="number">0x33f00000</span> <span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">model = <span class="string">"SMDK24440"</span>;</span><br><span class="line">compatible = <span class="string">"samsung,smdk2440"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"><span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"></span><br><span class="line">memory &#123;  <span class="comment">/* /memory */</span></span><br><span class="line">device_type = <span class="string">"memory"</span>;</span><br><span class="line">reg =  &lt;<span class="number">0x30000000</span> <span class="number">0x4000000</span> <span class="number">0</span> <span class="number">4096</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cpus &#123;</span></span><br><span class="line"><span class="comment">cpu &#123;</span></span><br><span class="line"><span class="comment">compatible = "arm,arm926ej-s";</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chosen &#123;</span><br><span class="line">bootargs = <span class="string">"noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">led &#123;</span><br><span class="line">compatible = <span class="string">"jz2440_led"</span>;</span><br><span class="line">pin = &lt;S3C2410_GPF(<span class="number">5</span>)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dts-生成对应的-dtb-文件"><a href="#dts-生成对应的-dtb-文件" class="headerlink" title="dts 生成对应的 dtb 文件"></a>dts 生成对应的 dtb 文件</h3><p><img src="/images/device_tree/demodtb.png" alt="demodtb"></p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p><img src="/images/device_tree/DTB%E6%A0%BC%E5%BC%8F.png" alt="DTB格式"></p><h4 id="只分析其中的一个节点"><a href="#只分析其中的一个节点" class="headerlink" title="只分析其中的一个节点"></a>只分析其中的一个节点</h4><p>&emsp;&emsp;下面代码中注释部分为对应 dtb 文件中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Devicetree node 格式： */</span></span><br><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">[properties definitions]</span><br><span class="line">[child nodes]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/ &#123;            <span class="comment">/* ----&gt; 0x00000001 */</span></span><br><span class="line">led &#123;  <span class="comment">/* ----&gt; 0x00000001 （表示 node 的开始） + 节点名字 */</span></span><br><span class="line">compatible = <span class="string">"jz2440_led"</span>; <span class="comment">/* ----&gt; 0x00000003 （表示属性） + </span></span><br><span class="line"><span class="comment">struct&#123;</span></span><br><span class="line"><span class="comment">uint32_t len;     // val 长度</span></span><br><span class="line"><span class="comment">uint32_t nameoff; // 名字在 strings block 中的 offset + val (len 个字节)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pin = &lt;S3C2410_GPF(<span class="number">5</span>)&gt;;  <span class="comment">/* ----&gt; 0x00000003 + struct + val */</span></span><br><span class="line">&#125;;     <span class="comment">/* ----&gt; 0x00000002 (表示 node 结束) */</span></span><br><span class="line">&#125;;             <span class="comment">/* ----&gt; 0x00000002 */</span></span><br><span class="line">               <span class="comment">/* ----&gt; 0x00000009 (表示整个 structure block 结束） */</span></span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a><br>&emsp;&emsp;官方文档： <a href="https://www.devicetree.org/specifications/" target="_blank" rel="noopener">https://www.devicetree.org/specifications/</a><br>&emsp;&emsp;内核文档: <a href>Documentation/devicetree/booting-without-of.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/device_tree/devicetree.png&quot; alt=&quot;devicetree&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;DTS格式&quot;&gt;&lt;a href=&quot;#DTS格式&quot; class=&quot;headerlink&quot; title=&quot;DTS格式&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="Device tree" scheme="https://zhouyuebiao.cn/tags/Device-tree/"/>
    
  </entry>
  
  <entry>
    <title>设备树之为什么需要设备树(1)</title>
    <link href="https://zhouyuebiao.cn/2020/01/03/0039-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%BE%E5%A4%87%E6%A0%91-1/"/>
    <id>https://zhouyuebiao.cn/2020/01/03/0039-设备树之为什么需要设备树-1/</id>
    <published>2020-01-03T08:11:44.000Z</published>
    <updated>2020-01-05T06:24:41.243Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/device_tree/devicetree.png" alt="devicetree"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;设备树(Device Tree)是一种描述硬件的数据结构，由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。<br>&emsp;&emsp;设备树的出现是为了解决内核中大量的板级文件代码，通过 DTS 可以像应用程序里的 XML 语言一样很方便的对硬件信息进行配置。</p><h2 id="字符设备驱动程序的三种写法"><a href="#字符设备驱动程序的三种写法" class="headerlink" title="字符设备驱动程序的三种写法"></a>字符设备驱动程序的三种写法</h2><p>&emsp;&emsp;驱动程序编写有 3 种方法：传统方法、使用总线设备驱动模型、使用设备树<br>&emsp;&emsp;这3种方法也核心都是一样的: 分配、设置、注册 file_operations 结构体<br>&emsp;&emsp;&emsp;&emsp;这个 file_operations 结构体中有 .open, .read, .write, .ioctl 等成员<br>&emsp;&emsp;&emsp;&emsp;驱动程序要实现这些成员，通过这些成员函数中操作硬件<br>&emsp;&emsp;这 3 种方法的差别在于：如何指定硬件资源？（比如：如何指定 LED 引脚是哪个？）<br>&emsp;&emsp;这 3 中方法的做法分别是：</p><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>&emsp;&emsp;在驱动程序代码中写死硬件资源, 代码简单/不易扩展：<br>&emsp;&emsp;&emsp;&emsp;a. 分配file_operations结构体<br>&emsp;&emsp;&emsp;&emsp;b. 设置file_operations结构体<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;该结构体中有.open,.read,.write等成员,<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在这些成员函数中去操作硬件<br>&emsp;&emsp;&emsp;&emsp;c. 注册file_operations结构体:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;register_chrdev(major, name, &amp;fops)<br>&emsp;&emsp;&emsp;&emsp;d. 入口函数: 调用register_chrdev<br>&emsp;&emsp;&emsp;&emsp;e. 出口函数: 调用unregister_chrdev<br><img src="/images/device_tree/%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="输入子系统"></p><h3 id="总线设备驱动模型"><a href="#总线设备驱动模型" class="headerlink" title="总线设备驱动模型"></a>总线设备驱动模型</h3><p>&emsp;&emsp;a. 把驱动程序分为两部分(platform_driver, platform_device)<br>&emsp;&emsp;&emsp;&emsp;* 在 platform_device 中指定硬件资源,<br>&emsp;&emsp;&emsp;&emsp;* 在 platform_driver 根据与之匹配的platform_device获得硬件资源，分配/设置/注册 file_operations结构体（从platform_device获得硬件资源信息）<br>&emsp;&emsp;b. 如何确定platform_device和platform_driver是否匹配?<br>&emsp;&emsp;&emsp;&emsp;b.1 platform_device含有name<br>&emsp;&emsp;&emsp;&emsp;b.2 platform_driver.id_table”可能”指向一个数组, 每个数组项都有name, 表示该platform_driver所能支持的platform_device<br>&emsp;&emsp;&emsp;&emsp;b.3  platform_driver.driver含有name, 表示该platform_driver所能支持的platform_device<br>&emsp;&emsp;&emsp;&emsp;b.4 优先比较b.1, b.2两者的name, 若相同则表示互相匹配<br>&emsp;&emsp;&emsp;&emsp;b.5 如果platform_driver.id_table为NULL, 则比较b.1, b.3两者的name, 若相同则表示互相匹配<br><img src="/images/device_tree/%E6%80%BB%E7%BA%BF-%E8%AE%BE%E5%A4%87-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.png" alt="总线-设备-驱动模型"></p><p>&emsp;&emsp;特点：<br>&emsp;&emsp;&emsp;&emsp;优点：易于扩展，但是有很多冗余代码(每种配置都对应一个platform_device结构体),<br>&emsp;&emsp;&emsp;&emsp;缺点：硬件有变动时需要重新编译内核或驱动程序。</p><h3 id="使用设备树指定硬件资源"><a href="#使用设备树指定硬件资源" class="headerlink" title="使用设备树指定硬件资源"></a>使用设备树指定硬件资源</h3><p>&emsp;&emsp;驱动程序也分为两部分(platform_driver, 设备树<em>.dts)<br>&emsp;&emsp;在设备树</em>.dts中指定硬件资源, dts被编译为dtb文件, 在启动单板时会将dtb文件传给内核,<br>&emsp;&emsp;内核根据dtb文件分配/设置/注册多个platform_device<br>&emsp;&emsp;而platform_driver的编写方法跟”总线设备驱动模型”一样。</p><p>&emsp;&emsp;特点：<br>&emsp;&emsp;&emsp;&emsp;易于扩展，没有冗余代码<br>&emsp;&emsp;&emsp;&emsp;硬件有变动时不需要重新编译内核或驱动程序，只需要提供不一样的dtb文件<br>&emsp;&emsp;注: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dts  - device tree source  // 设备树源文件</span><br><span class="line">dtb  - device tree blob    // 设备树二进制文件, 由dts编译得来</span><br><span class="line">blob - binary large object</span><br></pre></td></tr></table></figure><p><img src="/images/device_tree/%E8%AE%BE%E5%A4%87%E6%A0%91.png" alt="设备树写法"></p><h2 id="使用设备树编写驱动的详细过程"><a href="#使用设备树编写驱动的详细过程" class="headerlink" title="使用设备树编写驱动的详细过程"></a>使用设备树编写驱动的详细过程</h2><p>&emsp;&emsp;a. 使用”总线设备驱动模型”编写的驱动程序分为 platform_device 和 platform_driver 两部分<br>&emsp;&emsp;&emsp;&emsp;* platform_device : 指定硬件资源, 来自 .c 文件<br>&emsp;&emsp;&emsp;&emsp;* platform_driver : 根据与之匹配的 platform_device 获得硬件资源, 并分配-&gt;设置-&gt;注册 file_operations 结构体<br>&emsp;&emsp;b. 实际上platform_device也可以来自设备树文件.dts<br>&emsp;&emsp;&emsp;&emsp;* 1. dts 文件被编译为 dtb 文件,<br>&emsp;&emsp;&emsp;&emsp;* 2. dtb 文件会传给内核,<br>&emsp;&emsp;&emsp;&emsp;* 3. 内核会解析 dtb 文件, 构造出一系列的 device_node 结构体,<br>&emsp;&emsp;&emsp;&emsp;* 4. device_node 结构体会转换为 platform_device 结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dts -&gt; dtv -&gt; 内核解析dtb -&gt; device_node -&gt; platform_device</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;所以: 我们在 dts 文件中指定资源即可； 不再需要在 .c 文件中设置 platform_device 结构体。<br>&emsp;&emsp;c.  “来自 dts 的 platform_device 结构体” 与 “我们写的 platform_driver “ 的匹配过程:<br>&emsp;&emsp;&emsp;&emsp;”来自 dts 的 platform_device 结构体”里面有成员”.dev.of_node”, 它里面含有各种属性, 比如 compatible, reg, pin<br>&emsp;&emsp;&emsp;&emsp;”我们写的 platform_driver “ 里面有成员 “.driver.of_match_table”, 它表示能支持哪些来自于 dts 的 platform_device</p><p>&emsp;&emsp;&emsp;&emsp;如果 “of_node 中的 compatible” 跟 “of_match_table 中的 compatible” 一致, 就表示匹配成功, 则调用 platform_driver 中的 probe 函数;<br>&emsp;&emsp;&emsp;&emsp;在 probe 函数中, 可以继续从 of_node 中获得各种属性来确定硬件资源</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>&emsp;&emsp;百问网：<a href="http://www.100ask.net" target="_blank" rel="noopener">http://www.100ask.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/device_tree/devicetree.png&quot; alt=&quot;devicetree&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zhouyuebiao.cn/tags/Linux/"/>
    
      <category term="Device tree" scheme="https://zhouyuebiao.cn/tags/Device-tree/"/>
    
  </entry>
  
  <entry>
    <title>分析Android-Recovery-UI的实现过程</title>
    <link href="https://zhouyuebiao.cn/2019/10/11/0038-%E5%88%86%E6%9E%90Android-Recovery-UI%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <id>https://zhouyuebiao.cn/2019/10/11/0038-分析Android-Recovery-UI的实现过程/</id>
    <published>2019-10-11T09:26:43.000Z</published>
    <updated>2019-10-12T01:44:51.108Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/Android_Recovery_UI.jpg" alt="Android_Recovery_UI"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;recovery作为一个简单的rootfs, 只提供了非常有限的几个功能，在源码中其利用boottable/recovery下的minui库作为基础，采用直接刷framebuffer的形式绘制显示UI。<br>&emsp;&emsp;在recovery的源码中，跟ui显示相关的代码主要有： </p><ol><li>定义并实现几个类，如ScreenRecoveryUI，ScreenRecoveryUI、RecoveryUI，这几个类由抽象到具体一层层继承下来，在recovery.cpp的main中实例化并被使用</li><li>将minui库里resources.cpp，graphics.cpp提供的基本api封装到几个方法中，这几个方法在类中基本被按功能划分，单独负责一个ui单元的显示，如draw_background_locked、draw_battery_locked、draw_logo_locked、update_progress_locked、draw_progressbar_locked、draw_state_locked等,之后再将这些方法进一步按照设计需求组合，实现了一些完成更多功能的方法，如SetBackground，ShowProgress</li><li>boottable/recovery/minui下的resources.cpp，graphics.cpp其中resources.cpp提供的api主要用于图片资源的读取和加载，graphics.cpp负责具体完成各类ui的绘制</li><li>recovery下面根据分辨率不同保存的图片资源，如boottable/recovery/res-xxhdpi等。</li></ol><p>&emsp;&emsp;以Android P原生代码作为分析材料，对Recovery模式下各类UI资源被加载并显示的过程来做具体分析：<br>&emsp;&emsp;recovery的UI实现的大部分实现细节放在了screen_ui.cpp等文件中，在recovery的main中，主要是要完成ui的显示。</p><h1 id="recovery-cpp-main-function"><a href="#recovery-cpp-main-function" class="headerlink" title="recovery.cpp main function"></a>recovery.cpp main function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recovery.cpp */</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv) &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line"></span><br><span class="line">    Device* device = make_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : Device::REBOOT;</span></span><br><span class="line">    <span class="comment">// 1. If the recovery menu is visible, prompt and wait for commands.</span></span><br><span class="line">    <span class="comment">// 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into</span></span><br><span class="line">    <span class="comment">//    recovery to sideload a package.)</span></span><br><span class="line">    <span class="comment">// 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device</span></span><br><span class="line">    <span class="comment">//    without waiting.</span></span><br><span class="line">    <span class="comment">// 4. In all other cases, reboot the device. Therefore, normal users will observe the device</span></span><br><span class="line">    <span class="comment">//    reboot after it shows the "error" screen for 5s.</span></span><br><span class="line">    <span class="keyword">if</span> (just_exit) &#123;</span><br><span class="line">            after = Device::REBOOT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((status == INSTALL_NONE) &amp;&amp; !sideload_auto_reboot) || ui-&gt;IsTextVisible()) &#123;</span><br><span class="line">        Device::BuiltinAction temp = prompt_and_wait(device, status);</span><br><span class="line">        <span class="keyword">if</span> (temp != Device::NO_ACTION) &#123;</span><br><span class="line">        after = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Reocvery的main函数代码中UI相关的语句中的工作很简单：首先新建了一个Device类的对象， Device类封装了一些操作，包括UI的操作。</p><h1 id="device-h-class-Device"><a href="#device-h-class-Device" class="headerlink" title="device.h class Device"></a>device.h class Device</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* device.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Device</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    explicit Device(RecoveryUI* ui) : ui_(ui) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Device() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called to obtain the UI object that should be used to display the recovery user interface for</span></span><br><span class="line">    <span class="comment">// this device. You should not have called Init() on the UI object already, the caller will do</span></span><br><span class="line">    <span class="comment">// that after this method returns.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> RecoveryUI* <span class="title">GetUI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ui_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ..... */</span></span><br><span class="line">    <span class="comment">// The device-specific library must define this function (or the default one will be used, if there</span></span><br><span class="line">    <span class="comment">// is no device-specific library). It returns the Device object that recovery should use.</span></span><br><span class="line">    <span class="function">Device* <span class="title">make_device</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;make_device()函数的说明在device.h中有提及。</p><h1 id="三个类的继承关系"><a href="#三个类的继承关系" class="headerlink" title="三个类的继承关系"></a>三个类的继承关系</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./ui.h(RecoveryUI)-&gt;./screen_ui.h(ScreenRecoveryUI)-&gt;./device.h(DefaultUI) */</span></span><br><span class="line">./ui.h</span><br><span class="line">    RecoveryUI</span><br><span class="line">        ./screen_ui.h</span><br><span class="line">            ScreenRecoveryUI</span><br><span class="line">                ./device.h</span><br><span class="line">                    DefaultUI</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用Device类的GetUI()返回一个DefaultUI对象，recovery中涉及到三个UI类，三个类之间为继承关系，分别为DefaultUI、ScreenRecoveryUI、RecoveryUI</p><h1 id="screen-ui-cpp-Init-function"><a href="#screen-ui-cpp-Init-function" class="headerlink" title="screen_ui.cpp Init function"></a>screen_ui.cpp Init function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="comment">/* ..... */</span></span><br><span class="line"><span class="keyword">bool</span> ScreenRecoveryUI::Init(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; locale) &#123;</span><br><span class="line">  RecoveryUI::Init(locale);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!InitTextParams()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Are we portrait or landscape?</span></span><br><span class="line">  layout_ = (gr_fb_width() &gt; gr_fb_height()) ? LANDSCAPE : PORTRAIT;</span><br><span class="line">  <span class="comment">// Are we the large variant of our base layout?</span></span><br><span class="line">  <span class="keyword">if</span> (gr_fb_height() &gt; PixelsFromDp(<span class="number">800</span>)) ++layout_;</span><br><span class="line"></span><br><span class="line">  text_ = Alloc2d(text_rows_, text_cols_ + <span class="number">1</span>);</span><br><span class="line">  file_viewer_text_ = Alloc2d(text_rows_, text_cols_ + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  text_col_ = text_row_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the locale info.</span></span><br><span class="line">  SetLocale(locale);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"icon_error"</span>, &amp;error_icon);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"progress_empty"</span>, &amp;progressBarEmpty);</span><br><span class="line">  LoadBitmap(<span class="string">"progress_fill"</span>, &amp;progressBarFill);</span><br><span class="line"></span><br><span class="line">  LoadBitmap(<span class="string">"stage_empty"</span>, &amp;stageMarkerEmpty);</span><br><span class="line">  LoadBitmap(<span class="string">"stage_fill"</span>, &amp;stageMarkerFill);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Background text for "installing_update" could be "installing update"</span></span><br><span class="line">  <span class="comment">// or "installing security update". It will be set after UI init according</span></span><br><span class="line">  <span class="comment">// to commands in BCB.</span></span><br><span class="line">  installing_text = <span class="literal">nullptr</span>;</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"erasing_text"</span>, &amp;erasing_text);</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"no_command_text"</span>, &amp;no_command_text);</span><br><span class="line">  LoadLocalizedBitmap(<span class="string">"error_text"</span>, &amp;error_text);</span><br><span class="line"></span><br><span class="line">  LoadAnimation();</span><br><span class="line"></span><br><span class="line">  pthread_create(&amp;progress_thread_, <span class="literal">nullptr</span>, ProgressThreadStartRoutine, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ..... */</span></span><br></pre></td></tr></table></figure><ol><li>调用RecoveryUI的Init()，初始化输入事件处理。</li><li>InitTextParams()用于初始化图形设备和字体显示的环境。</li><li>调用DefaultUI类的Init()，由于DefaultUI类没有Init()方法，因此将调用它的父类ScreenRecoveryUI的Init()：</li><li>同理可得，调用ScreenRecoveryUI类的SetLocale()来标识几个比较特别的区域</li><li>同理可得，调用ScreenRecoveryUI类的SetBackground()设置初始状态的背景图</li><li>最后显示recovery的主界面，即平时所见的刷机界面。</li><li>LoadBitmap()  将png生成surface, 每个png图片对应一个surface, 所有surface存放在一个数组中</li><li>LoadLocalizedBitmap()  将区域文字所在的图片中的text信息根据当前的locale提取出来，生成对应的surface, 所以surface也存放在一个数组中</li><li>pthread_create(&amp;progress_t, NULL, progress_thread, NULL) 创建一个线程，该线程的任务是一个死循环，在该循环中不停地检测currentIcon以及progressBarType来决定是不是要更新进度条。</li></ol><h2 id="screen-ui-cpp-InitTextParams-function"><a href="#screen-ui-cpp-InitTextParams-function" class="headerlink" title="screen_ui.cpp InitTextParams function"></a>screen_ui.cpp InitTextParams function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="comment">/* ..... */</span></span><br><span class="line"><span class="keyword">bool</span> ScreenRecoveryUI::InitTextParams() &#123;</span><br><span class="line">  <span class="keyword">if</span> (gr_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gr_font_size(gr_sys_font(), &amp;char_width_, &amp;char_height_);</span><br><span class="line">  text_rows_ = (ScreenHeight() - kMarginHeight * <span class="number">2</span>) / char_height_;</span><br><span class="line">  text_cols_ = (ScreenWidth() - kMarginWidth * <span class="number">2</span>) / char_width_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ..... */</span></span><br></pre></td></tr></table></figure><p>&emsp;gr_init()  初始化图形设备，分配Pixelflinger库渲染的内存<br>&emsp;gr_font_size()  将字体对应的surface长宽赋值给char_width和char_height</p><h2 id="screen-ui-cpp-SetLocale-function"><a href="#screen-ui-cpp-SetLocale-function" class="headerlink" title="screen_ui.cpp SetLocale function"></a>screen_ui.cpp SetLocale function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::SetLocale(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; new_locale) &#123;</span><br><span class="line">  locale_ = new_locale;</span><br><span class="line">  rtl_locale_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!new_locale.empty()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> underscore = new_locale.find(<span class="string">'_'</span>);</span><br><span class="line">    <span class="comment">// lang has the language prefix prior to '_', or full string if '_' doesn't exist.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lang = new_locale.substr(<span class="number">0</span>, underscore);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A bit cheesy: keep an explicit list of supported RTL languages.</span></span><br><span class="line">    <span class="keyword">if</span> (lang == <span class="string">"ar"</span> ||  <span class="comment">// Arabic</span></span><br><span class="line">        lang == <span class="string">"fa"</span> ||  <span class="comment">// Persian (Farsi)</span></span><br><span class="line">        lang == <span class="string">"he"</span> ||  <span class="comment">// Hebrew (new language code)</span></span><br><span class="line">        lang == <span class="string">"iw"</span> ||  <span class="comment">// Hebrew (old language code)</span></span><br><span class="line">        lang == <span class="string">"ur"</span>) &#123;  <span class="comment">// Urdu</span></span><br><span class="line">      rtl_locale_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ScreenRecoveryUI类的SetLocale， 该函数根据locale判断所用的字体是否属于阿拉伯语系，阿拉伯语的书写习惯是从右到左，如果是阿拉伯语系的话，就设置一个标志，后面根据这个标志决定从右到左显示文字或进度条。<br>&emsp;SetLocale的参数locale赋值逻辑是这样的，先从command文件中读取, command文件中设置locale的命令如”–locale=zh_CN“，如果没有传入locale,初始化过程中会尝试从/cache/recovery/last_locale中读取locale, 如果该文件也没有，则locale不会被赋值，就默认用English。</p><h2 id="screen-ui-cpp-SetBackground-function"><a href="#screen-ui-cpp-SetBackground-function" class="headerlink" title="screen_ui.cpp SetBackground function"></a>screen_ui.cpp SetBackground function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::SetBackground(Icon icon) &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;updateMutex);</span><br><span class="line"></span><br><span class="line">  currentIcon = icon;</span><br><span class="line">  update_screen_locked();</span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;updateMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update_screen_locked包含两个操作，一是更新screen, 二是切换前后buffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::update_screen_locked() &#123;</span><br><span class="line">  draw_screen_locked();</span><br><span class="line">  gr_flip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;SetBackground函数比较简洁，关键部分在update_screen_locked，下面重点分析一下:<br>&emsp;update_screen_locked和update_progress_locked是recovery的UI部分的关键函数，update_screen_locked用来更新背景, update_progress_locked用来更新进度条，因为显示的画面会一直在更新，所以这两个函数会在不同的地方被反复调用。</p><h2 id="screen-ui-cpp-draw-background-locked-function"><a href="#screen-ui-cpp-draw-background-locked-function" class="headerlink" title="screen_ui.cpp draw_background_locked function"></a>screen_ui.cpp draw_background_locked function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::draw_background_locked() &#123;</span><br><span class="line">  pagesIdentical = <span class="literal">false</span>;</span><br><span class="line">  gr_color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  gr_clear();</span><br><span class="line">  <span class="keyword">if</span> (currentIcon != NONE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_stage != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> stage_height = gr_get_height(stageMarkerEmpty);</span><br><span class="line">      <span class="keyword">int</span> stage_width = gr_get_width(stageMarkerEmpty);</span><br><span class="line">      <span class="keyword">int</span> x = (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> y = ScreenHeight() - stage_height - kMarginHeight;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_stage; ++i) &#123;</span><br><span class="line">        GRSurface* stage_surface = (i &lt; stage) ? stageMarkerFill : stageMarkerEmpty;</span><br><span class="line">        DrawSurface(stage_surface, <span class="number">0</span>, <span class="number">0</span>, stage_width, stage_height, x, y);</span><br><span class="line">        x += stage_width;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GRSurface* text_surface = GetCurrentText();</span><br><span class="line">    <span class="keyword">int</span> text_x = (ScreenWidth() - gr_get_width(text_surface)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> text_y = GetTextBaseline();</span><br><span class="line">    gr_color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    DrawTextIcon(text_x, text_y, text_surface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;draw_background_locked函数的实现代码中又出现了几个以gr_开头的函数，以gr_开头的函数来自minui库，minui库的代码在recovery源码下的minui目录下，minui提供的接口实现了图形的描绘以及固定大小的文字显示。</p><ul><li>gr_color(unsigned char r, unsigned char g, unsigned char b, unsigned char a);  /* 设置字体颜色 */  </li><li>gr_fill(int x, int y, int w, int h);  /* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */  </li><li>gr_blit(gr_surface source, int sx, int sy, int w, int h, int dx, int dy);  /* 填充由source指定的图片 */  </li></ul><p>&emsp;&emsp;draw_background_locked函数先将整个渲染buffer填充为黑色，然后计算背景surface的长宽，文字surface的长宽，再结合fb的长宽计算出背景surface以及文字surface显示的坐标，有长宽和坐标就可以调用Pixelflinger的接口在渲染buffer上进行渲染。</p><h2 id="screen-ui-cpp-update-progress-locked-function"><a href="#screen-ui-cpp-update-progress-locked-function" class="headerlink" title="screen_ui.cpp update_progress_locked function"></a>screen_ui.cpp update_progress_locked function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ./screen_ui.cpp */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::update_progress_locked() &#123;</span><br><span class="line">  <span class="keyword">if</span> (show_text || !pagesIdentical) &#123;</span><br><span class="line">    draw_screen_locked();  <span class="comment">// Must redraw the whole screen</span></span><br><span class="line">    pagesIdentical = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    draw_foreground_locked();  <span class="comment">// Draw only the progress bar and overlays</span></span><br><span class="line">  &#125;</span><br><span class="line">  gr_flip();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line"><span class="keyword">void</span> ScreenRecoveryUI::draw_foreground_locked() &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentIcon != NONE) &#123;</span><br><span class="line">    GRSurface* frame = GetCurrentFrame();</span><br><span class="line">    <span class="keyword">int</span> frame_width = gr_get_width(frame);</span><br><span class="line">    <span class="keyword">int</span> frame_height = gr_get_height(frame);</span><br><span class="line">    <span class="keyword">int</span> frame_x = (ScreenWidth() - frame_width) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> frame_y = GetAnimationBaseline();</span><br><span class="line">    DrawSurface(frame, <span class="number">0</span>, <span class="number">0</span>, frame_width, frame_height, frame_x, frame_y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (progressBarType != EMPTY) &#123;</span><br><span class="line">    <span class="keyword">int</span> width = gr_get_width(progressBarEmpty);</span><br><span class="line">    <span class="keyword">int</span> height = gr_get_height(progressBarEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> progress_x = (ScreenWidth() - width) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> progress_y = GetProgressBaseline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Erase behind the progress bar (in case this was a progress-only update)</span></span><br><span class="line">    gr_color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    DrawFill(progress_x, progress_y, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (progressBarType == DETERMINATE) &#123;</span><br><span class="line">      <span class="keyword">float</span> p = progressScopeStart + progress * progressScopeSize;</span><br><span class="line">      <span class="keyword">int</span> pos = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(p * width);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rtl_locale_) &#123;</span><br><span class="line">        <span class="comment">// Fill the progress bar from right to left.</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarFill, width - pos, <span class="number">0</span>, pos, height, progress_x + width - pos,</span><br><span class="line">                      progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; width - <span class="number">1</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarEmpty, <span class="number">0</span>, <span class="number">0</span>, width - pos, height, progress_x, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fill the progress bar from left to right.</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarFill, <span class="number">0</span>, <span class="number">0</span>, pos, height, progress_x, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; width - <span class="number">1</span>) &#123;</span><br><span class="line">          DrawSurface(progressBarEmpty, pos, <span class="number">0</span>, width - pos, height, progress_x + pos, progress_y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;update_progress_locked函数的原理与 update_screen_locked函数类似， 最终是将进度条的surface输出到渲染buffer,<br>&emsp;recovery中各个场景的画面，就是由背景、文字、进度条的重叠，不同的是所用的surface 以及surface的坐标。</p><p>&emsp;recovery main函数中的UI代码基本上已经分析过了，最后一点主菜单的显示，就是通过上面介绍的这些接口将文字图片显示出来，因此就不再多讲。总的来说，recovery的UI显示部分难度不大，应用层调用minui库实现了图形的描绘以及固定大小的文字显示，minui库调用了Pixelflinger库来进行渲染。</p><h1 id="minui部分接口说明"><a href="#minui部分接口说明" class="headerlink" title="minui部分接口说明"></a>minui部分接口说明</h1><p>&emsp;&emsp;仅供参考</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;             <span class="comment">/* 初始化图形显示,主要是打开设备、分配内存、初始化一些参数 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">/* 注销图形显示,关闭设备并释放内存 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_fb_width</span><span class="params">(<span class="keyword">void</span>)</span></span>;         <span class="comment">/* 获取屏幕的宽度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_fb_height</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">/* 获取屏幕的高度 */</span>  </span><br><span class="line"><span class="function">gr_pixel *<span class="title">gr_fb_data</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">/* 获取显示数据缓存的地址 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_flip</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">/* 刷新显示内容 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_fb_blank</span><span class="params">(<span class="keyword">bool</span> blank)</span></span>;  <span class="comment">/* 清屏 */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_color</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> r, <span class="keyword">unsigned</span> <span class="keyword">char</span> g, <span class="keyword">unsigned</span> <span class="keyword">char</span> b, <span class="keyword">unsigned</span> <span class="keyword">char</span> a)</span></span>;  <span class="comment">/* 设置字体颜色 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span>;  <span class="comment">/* 填充矩形区域,参数分别代表起始坐标、矩形区域大小 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_text</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;  <span class="comment">/* 显示字符串 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gr_measure</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;             <span class="comment">/* 获取字符串在默认字库中占用的像素长度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_font_size</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;         <span class="comment">/* 获取当前字库一个字符所占的长宽 */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gr_blit</span><span class="params">(gr_surface source, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>;  <span class="comment">/* 填充由source指定的图片 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gr_get_width</span><span class="params">(gr_surface surface)</span></span>;   <span class="comment">/* 获取图片宽度 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gr_get_height</span><span class="params">(gr_surface surface)</span></span>;  <span class="comment">/* 获取图片高度 */</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">res_create_surface</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, gr_surface* pSurface)</span></span>;  <span class="comment">/* 根据图片创建显示资源数据,name为图片在mk文件指定的相对路径 */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">res_free_surface</span><span class="params">(gr_surface surface)</span></span>;       <span class="comment">/* 释放资源数据 */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/Android_Recovery_UI.jpg&quot; alt=&quot;Android_Recovery_UI&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的升级流程</title>
    <link href="https://zhouyuebiao.cn/2019/10/09/0037-Android%E7%9A%84%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://zhouyuebiao.cn/2019/10/09/0037-Android的升级流程分析/</id>
    <published>2019-10-09T07:44:13.000Z</published>
    <updated>2019-10-11T09:39:12.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/upgrade.jpg" alt="upgrade"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;以Android P原生代码作为分析材料。</p><h1 id="从Android的启动模式说起"><a href="#从Android的启动模式说起" class="headerlink" title="从Android的启动模式说起"></a>从Android的启动模式说起</h1><p>&emsp;&emsp;Android系统一般有三种启动模式：Fastboot、Recovery system、Main system。这三种启动模式对应不同的启动场景需求：</p><ul><li>Fastboot：在这种模式下，可以修改手机的硬件，并且允许我们发送一些命令给Bootloader。如使用电脑刷机，则需要进入fastboot模式，通过电脑执行命令将系统镜像刷到通过USB刷到Android设备中中。</li><li>Recovery：Recovery是一个小型的操作系统，并且会加载部分文件系统，这样才能从sdcard中读取升级包。</li><li>Main System: 即我们平时正常开机后所使用的手机操作系统模式。</li></ul><p>&emsp;&emsp;但是我们一般经常用到的是recovery system和main system这两种启动模式。下面主要区分下recovery system和main system：<br><img src="/images/Android/%E5%BC%80%E6%9C%BA%E8%BF%9B%E5%85%A5recovery%E8%BF%98%E6%98%AFAndroid%E7%B3%BB%E7%BB%9F.png" alt="开机进入recovery还是Android系统"></p><p>&emsp;&emsp;启动经过bootloader之后，系统的启动方式有两种选择，这个选择有两个方式可以决定：一个是操作bootloader，一个是根据recovery的command文件。<br>&emsp;&emsp;上半部分是mian system（正常启动模式），下半部分为Recovery模式。正常的启动模式是从boot.img启动系统（Main System），而recovery模式则是从reovery.img启动系统；（reovery.img只包含内核、简单的文件管理系统和图形系统）</p><h1 id="升级流程之升级方式"><a href="#升级流程之升级方式" class="headerlink" title="升级流程之升级方式"></a>升级流程之升级方式</h1><h2 id="应用层ota升级流程："><a href="#应用层ota升级流程：" class="headerlink" title="应用层ota升级流程："></a>应用层ota升级流程：</h2><p>&emsp;&emsp;应用层层面的 ota升级包的下载、校验以及最后的发起安装过程：<br><img src="/images/Android/Android%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.jpg" alt="Android应用层升级流程"></p><h2 id="Recovery模式下的OTA升级流程"><a href="#Recovery模式下的OTA升级流程" class="headerlink" title="Recovery模式下的OTA升级流程"></a>Recovery模式下的OTA升级流程</h2><p>&emsp;&emsp;进入Recovery模式之后，根据相应的指令指示开始对下载的升级包进行升级，整体的流程图如下所示：<br><img src="/images/Android/Recovery%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84OTA%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.jpg" alt="Recovery模式下的OTA升级流程"></p><h1 id="升级流程之升级包"><a href="#升级流程之升级包" class="headerlink" title="升级流程之升级包"></a>升级流程之升级包</h1><h2 id="升级包的制作"><a href="#升级包的制作" class="headerlink" title="升级包的制作"></a>升级包的制作</h2><p>&emsp;&emsp;升级包是通过脚本ota_from_target_files进行制作的。（在Android SDK源码中的位置：build/make/tools/releasetools/ota_from_target_files）</p><ol><li>WriteFullOTAPackage 执行目的<ul><li>使用 edify_generator 生成升级脚本 updater-script</li><li>使用 **target-xxx.zip 中的内容生成最终的升级包<blockquote><p>整体通过ota_from_target_files脚本，进行了升级包的制作，Android是使用 make otapackage 命令进行制作，制作出升级脚本后，会连带着系统相关信息进行打包。</p></blockquote></li></ul></li></ol><h2 id="升级包的架构"><a href="#升级包的架构" class="headerlink" title="升级包的架构"></a>升级包的架构</h2><p>&emsp;&emsp;下面是升级包的基本的架构，是以hisi 3798mv300举例不同平台升级包略有不同，单架构没什么差异裸分区镜像就使用boot.img loader.bin这种方式。<br>&emsp;&emsp;META 目录下是system的权限信息和misc标记信息。<br>&emsp;&emsp;META-INF中的metadata是系统信息，我们的apk会先去校验这个文件与我们的系统是否一致，信息举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">post-build=xxxxxxxx/xxxxxxxx/xxxxxxxx:4.4.2/xxxxxxxx/817109000126:eng/test-keys</span><br><span class="line">post-timestamp=1553223178</span><br><span class="line">pre-device=xxxxxxxx</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;updater-script是升级脚本，update-binary是升级脚本执行的执行程序，Recovery下面是升级recovery用的。<br>update-script升级脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(!less_than_int(1569489228, getprop("ro.build.date.utc"))) || abort("E3003: Can't install this package (2019年 00月 00日 星期x xx:xx:xx CST) over newer build (" + getprop("ro.build.date") + ").");</span><br><span class="line">getprop("ro.product.device") == "franklin" || abort("E3004: This package is for \"franklin\" devices; this is a \"" + getprop("ro.product.device") + "\".");</span><br><span class="line">if ota_zip_check() == "1" then</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">backup_update_package("/dev/block/mmcblk0", "1894");</span><br><span class="line">set_bootloader_env("upgrade_step", "2");</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">reboot_recovery();</span><br><span class="line">else</span><br><span class="line">ui_print("Target: Android/xxxxx/xxxxxx:9.0.0/xxxxx/0000.00000.001:eng/test-keys");</span><br><span class="line">set_bootloader_env("upgrade_step", "3");</span><br><span class="line">show_progress(0.750000, 0);</span><br><span class="line">ui_print("Patching system image unconditionally...");</span><br><span class="line">block_image_update("/dev/block/system", package_extract_file("system.transfer.list"), "system.new.dat.br", "system.patch.dat") ||</span><br><span class="line">  abort("E1001: Failed to update system image.");</span><br><span class="line">show_progress(0.050000, 5);</span><br><span class="line">package_extract_file("boot.img", "/dev/block/boot");</span><br><span class="line">show_progress(0.200000, 10);</span><br><span class="line">if get_update_stage() == "2" then</span><br><span class="line">format("ext4", "EMMC", "/dev/block/metadata", "0", "/metadata");</span><br><span class="line">format("ext4", "EMMC", "/dev/block/tee", "0", "/tee");</span><br><span class="line">wipe_cache();</span><br><span class="line">set_update_stage("0");</span><br><span class="line">endif;</span><br><span class="line">set_bootloader_env("upgrade_step", "1");</span><br><span class="line">set_bootloader_env("force_auto_update", "false");</span><br><span class="line">endif;</span><br><span class="line">set_progress(1.000000);</span><br></pre></td></tr></table></figure><h1 id="升级流程之升级脚本"><a href="#升级流程之升级脚本" class="headerlink" title="升级流程之升级脚本"></a>升级流程之升级脚本</h1><p>&emsp;&emsp;升级脚本在recovery中执行，执行的每一步骤，是使用update-binary这个二进制文件里面的程序执行，代码见： bootable/recovery/updater/install.cpp 这里面编译会生成updater文件，这个文件就是制作update-binary的。<br>&emsp;&emsp;其中的脚本，通过文件中void RegisterInstallFunctions()  函数中的RegisterFunction(“mount”, MountFn);函数执行，前面是脚本，后面是脚本的函数。<br>执行完所有的脚本过程后，就完成了本次的升级</p><blockquote><p>注：整个升级过程是没有升级recovery自己的分区的</p></blockquote><h1 id="升级流程之启动升级"><a href="#升级流程之启动升级" class="headerlink" title="升级流程之启动升级"></a>升级流程之启动升级</h1><p>&emsp;&emsp;在recovery中，是怎样进行升级的呢？<br>&emsp;&emsp;Recovery的启动也是通过init执行recovery服务进行启动，执行recovery.cpp中的main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recovery.cpp */</span></span><br><span class="line"><span class="comment">/* ....... */</span></span><br><span class="line"><span class="keyword">if</span> (update_package != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    status = install_package(update_package, &amp;should_wipe_cache, TEMPORARY_INSTALL_FILE, <span class="literal">true</span>,</span><br><span class="line">                               retry_count);</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mian函数的入口参数是通过cache/recovery/command中得来。</p></blockquote><p>&emsp;&emsp;升级函数install_package（bootable/recovery/install.cpp）会调用 really_install_package，其中进行校验，之后开始执行升级update-binary调用updater-script开始根据进行升级，最终的升级过程在try_update_binary()函数中进行，其创建了两个管道并fork一个子进程，子进程管道的数据即升级指令，父进程读取其执行相应到处理（升级）工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* install.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">install_package</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, <span class="keyword">bool</span>* wipe_cache, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; install_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> needs_mount, <span class="keyword">int</span> retry_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; log_buffer;</span><br><span class="line">    <span class="keyword">if</span> (setup_install_mounts() != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"failed to set up expected mounts for install; aborting"</span>;</span><br><span class="line">        result = INSTALL_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = really_install_package(path, wipe_cache, needs_mount, &amp;log_buffer, retry_count,</span><br><span class="line">                                        &amp;max_temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_install_package</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path, <span class="keyword">bool</span>* wipe_cache, <span class="keyword">bool</span> needs_mount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* log_buffer, <span class="keyword">int</span> retry_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span>* max_temperature)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="comment">// Verify package.</span></span><br><span class="line">    <span class="keyword">if</span> (!verify_package(<span class="built_in">map</span>.addr, <span class="built_in">map</span>.length)) &#123;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kZipVerificationFailure));</span><br><span class="line">    <span class="keyword">return</span> INSTALL_CORRUPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span>                            </span><br><span class="line">    <span class="comment">// Verify and install the contents of the package.</span></span><br><span class="line">    ui-&gt;Print(<span class="string">"Installing update...\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (retry_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ui-&gt;Print(<span class="string">"Retry attempt: %d\n"</span>, retry_count);</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;SetEnableReboot(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (update_flag == <span class="number">1</span>) &#123;</span><br><span class="line">        result = try_update_binary(new_path, zip, wipe_cache, log_buffer, retry_count, max_temperature);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line"><span class="comment">// If the package contains an update binary, extract it and run it.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_update_binary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; package, ZipArchiveHandle zip, <span class="keyword">bool</span>* wipe_cache,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* log_buffer, <span class="keyword">int</span> retry_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span>* max_temperature)</span> </span>&#123;</span><br><span class="line">    read_source_target_build(zip, log_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> AB_OTA_UPDATER</span></span><br><span class="line">    <span class="keyword">int</span> ret = update_binary_command(package, zip, <span class="string">"/sbin/update_engine_sideload"</span>, retry_count,</span><br><span class="line">                                    pipefd[<span class="number">1</span>], &amp;args);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> ret = update_binary_command(package, zip, <span class="string">"/tmp/update-binary"</span>, retry_count, pipefd[<span class="number">1</span>],</span><br><span class="line">                                    &amp;args);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kUpdateBinaryCommandFailure));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">    <span class="comment">// When executing the update binary contained in the package, the</span></span><br><span class="line">    <span class="comment">// arguments passed are:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - the version number for this interface</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - an FD to which the program can write in order to update the</span></span><br><span class="line">    <span class="comment">//     progress bar.  The program can write single-line commands:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        progress &lt;frac&gt; &lt;secs&gt;</span></span><br><span class="line">    <span class="comment">//            fill up the next &lt;frac&gt; part of of the progress bar</span></span><br><span class="line">    <span class="comment">//            over &lt;secs&gt; seconds.  If &lt;secs&gt; is zero, use</span></span><br><span class="line">    <span class="comment">//            set_progress commands to manually control the</span></span><br><span class="line">    <span class="comment">//            progress of this segment of the bar.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        set_progress &lt;frac&gt;</span></span><br><span class="line">    <span class="comment">//            &lt;frac&gt; should be between 0.0 and 1.0; sets the</span></span><br><span class="line">    <span class="comment">//            progress bar within the segment defined by the most</span></span><br><span class="line">    <span class="comment">//            recent progress command.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        ui_print &lt;string&gt;</span></span><br><span class="line">    <span class="comment">//            display &lt;string&gt; on the screen.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        wipe_cache</span></span><br><span class="line">    <span class="comment">//            a wipe of cache will be performed following a successful</span></span><br><span class="line">    <span class="comment">//            installation.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        clear_display</span></span><br><span class="line">    <span class="comment">//            turn off the text display.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        enable_reboot</span></span><br><span class="line">    <span class="comment">//            packages can explicitly request that they want the user</span></span><br><span class="line">    <span class="comment">//            to be able to reboot during installation (useful for</span></span><br><span class="line">    <span class="comment">//            debugging packages that don't exit).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        retry_update</span></span><br><span class="line">    <span class="comment">//            updater encounters some issue during the update. It requests</span></span><br><span class="line">    <span class="comment">//            a reboot to retry the same package automatically.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        log &lt;string&gt;</span></span><br><span class="line">    <span class="comment">//            updater requests logging the string (e.g. cause of the</span></span><br><span class="line">    <span class="comment">//            failure).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - the name of the package zip file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - an optional argument "retry" if this update is a retry of a failed</span></span><br><span class="line">    <span class="comment">//   update attempt.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert the vector to a NULL-terminated char* array suitable for execv.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* chr_args[args.size() + <span class="number">1</span>];</span><br><span class="line">    chr_args[args.size()] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">    chr_args[i] = args[i].c_str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    PLOG(ERROR) &lt;&lt; <span class="string">"Failed to fork update binary"</span>;</span><br><span class="line">    log_buffer-&gt;push_back(android::base::StringPrintf(<span class="string">"error: %d"</span>, kForkUpdateBinaryFailure));</span><br><span class="line">    <span class="keyword">return</span> INSTALL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    umask(<span class="number">022</span>);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    execv(chr_args[<span class="number">0</span>], <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(chr_args));</span><br><span class="line">    <span class="comment">// Bug: 34769056</span></span><br><span class="line">    <span class="comment">// We shouldn't use LOG/PLOG in the forked process, since they may cause</span></span><br><span class="line">    <span class="comment">// the child process to hang. This deadlock results from an improperly</span></span><br><span class="line">    <span class="comment">// copied mutex in the ui functions.</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"E:Can't run %s (%s)\n"</span>, chr_args[<span class="number">0</span>], strerror(errno));</span><br><span class="line">    _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; logger_finished(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">temperature_logger</span><span class="params">(log_max_temperature, max_temperature, <span class="built_in">std</span>::ref(logger_finished))</span></span>;</span><br><span class="line"></span><br><span class="line">    *wipe_cache = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> retry_update = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    FILE* from_child = fdopen(pipefd[<span class="number">0</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), from_child) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">line</span><span class="params">(buffer)</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> space = line.find_first_of(<span class="string">" \n"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">command</span><span class="params">(line.substr(<span class="number">0</span>, space))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (command.empty()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of the leading and trailing space and/or newline.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> args = space == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ? <span class="string">""</span> : android::base::Trim(line.substr(space));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下面代码的主要逻辑是，对接收到的命令执行相应的处理操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;try_update_binary 将升级包中的 META-INF/com/google/android/update-binary 拷贝到设备的/tmp 目录并 fork 出一个进程，执行 update-binary 脚本update-binary 脚本用于读取 META-INF/com/google/android/update-binary/updater-script解析执行升级脚本中的命令。父进程通过管道接收 update-binary 传来的命令，并执行相应的操作。<br>&emsp;&emsp;Recovery 在读取并解析升级脚本的过程中，会把升级包中 recovery 目录下的 etc/install-recovery.sh 和recovery.img 释放到设备的 system 目录下。当升级成功，在重启进入 Android 的过程中，系统会运行一个名为 flash_recovery 的 service ,该 service 会运行 install-recovery.sh 脚本，在脚本中会把 recovery.img 直接 dd到 recovery 分区。烧完后，删除 recovery.img 。</p><h1 id="【拓展】Bootloader、BCB、Recovery与Main-System之间的交互"><a href="#【拓展】Bootloader、BCB、Recovery与Main-System之间的交互" class="headerlink" title="【拓展】Bootloader、BCB、Recovery与Main System之间的交互"></a>【拓展】Bootloader、BCB、Recovery与Main System之间的交互</h1><p>&emsp;&emsp;Recovery System与Main System的交互，主要是通过/cache分区下的文件进行信息交互的。具体如下：</p><table><thead><tr><th align="center">/cache文件</th><th align="center">方向</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">/cache/recovery/command</td><td align="center">INPUT</td><td align="center">Main System传递给Recovery的命令行，比如update_package的存放路径等</td></tr><tr><td align="center">/cache/recovery/last_flag</td><td align="center">OUTPUT</td><td align="center">似乎Rockchip平台独有，用于记录自动升级结果</td></tr><tr><td align="center">/cache/recovery/intent</td><td align="center">OUTPUT</td><td align="center">Recovery给Main Syatem传递的信息</td></tr><tr><td align="center">/cache/recovery/last_install</td><td align="center">OUTPUT</td><td align="center">Recovery升级结果文件，主系统可以读取这个文件以便知道系统升级的结果，然后可以给用户相应的提示</td></tr><tr><td align="center">/cache/recovery/last_locale</td><td align="center">OUTPUT</td><td align="center">关系到Recovery模式下，UI文字的语言呈现形式，比如以英文显示，以中文显示等，如果进入recovery时获取不到&lt;-locale&gt;启动参数，则会尝试读取/cache下的</td></tr><tr><td align="center">/cache/recovery/log</td><td align="center">OUTPUT</td><td align="center">Recovery模式下的整个过程的日志，在系统进入Main Systen后，文件名不是以“last_”为前缀的文件会被删除</td></tr><tr><td align="center">/cache/recovery/last_log</td><td align="center">OUTPUT</td><td align="center">Recovery模式下的日志，取自上面所说的log（但可能完整性不及log），一般来说，分析Recovery问题的时候，经常会分析这份log</td></tr></tbody></table><blockquote><p>command的值一般有以下一个或多个。</p></blockquote><p>&emsp;&emsp;Bootloader与Recovery和Main System之间也是存在交互的： Bootloader会通过解析BCB模块，决定启动系统到Recovery或Main System。而Recovery或Main System也能够操作BCB，进而影响到Bootloader的行为。</p><p><img src="/images/Android/Bootloader%E3%80%81BCB%E3%80%81Recovery%E4%B8%8EMainSystem%E5%9B%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="Bootloader、BCB、Recovery与MainSystem四者之间的关系"></p><style>table th:nth-of-type(1){width: 30%;}table th:nth-of-type(2){width: 15%;}table th:nth-of-type(3){width: 55%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/upgrade.jpg&quot; alt=&quot;upgrade&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;em
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的系统架构、核心组件及源码结构</title>
    <link href="https://zhouyuebiao.cn/2019/09/19/0036-Android%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://zhouyuebiao.cn/2019/09/19/0036-Android的系统架构与核心组件及源码结构/</id>
    <published>2019-09-19T06:41:19.000Z</published>
    <updated>2019-09-25T06:32:09.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于Android 9.0<br><img src="/images/Android/android_training.jpg" alt="android_training"></p><h1 id="Android系统架构介绍"><a href="#Android系统架构介绍" class="headerlink" title="Android系统架构介绍"></a>Android系统架构介绍</h1><p>&emsp;&emsp;Android系统架构分为五层，从下到上依次是Linux内核层、硬件抽象层、系统运行库层、应用框架层和应用层。<br><img src="/images/Android/android-stack_2x%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="Android系统架构"></p><h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>&emsp;&emsp;Android站在巨人的肩膀之上，其基于Linux对Linux的依赖主要包括核心和驱动程序两部分。</p><h2 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h2><p>&emsp;&emsp;Android的硬件抽象层，简单来说，就是对Linux内核驱动程序的封装，向上提供接口，向下屏蔽了具体的实现细节。也就是将Linux内核对硬件的支持分成了两层，一层放在用户空间（User Space），一层放在内核空间（Kernel Space），其中，硬件抽象层运行在用户空间，对应具体的驱动实现细节，而Linux内核驱动程序运行在内核空间，只提供简单的数据访问逻辑。</p><h3 id="Android系统为什么要把对硬件的支持划分为两层来实现呢？"><a href="#Android系统为什么要把对硬件的支持划分为两层来实现呢？" class="headerlink" title="Android系统为什么要把对硬件的支持划分为两层来实现呢？"></a>Android系统为什么要把对硬件的支持划分为两层来实现呢？</h3><p>&emsp;&emsp;Linux内核代码遵循GPL1协议，如果在Android系统所使用的Linux内核中添加或者修改了代码，那么就必须将它们公开。因此，如果Android系统像其他的Linux系统一样，把对硬件的支持完全实现在硬件驱动模块中，那么就必须将这些硬件驱动模块源代码公开，这样就可能会损害移动设备厂商的利益，因为这相当于暴露了硬件的实现细节和参数。</p><h3 id="为什么将其抽象到硬件抽象层就可以规避这个问题呢？"><a href="#为什么将其抽象到硬件抽象层就可以规避这个问题呢？" class="headerlink" title="为什么将其抽象到硬件抽象层就可以规避这个问题呢？"></a>为什么将其抽象到硬件抽象层就可以规避这个问题呢？</h3><p>&emsp;&emsp;Android 系统代码是遵循Apache License2协议的，它允许移动设备厂商添加或者修改Android系统源代码，而又不必公开这些代码。因此，如果把对硬件的支持完全实现在Android系统的用户空间中，那么就可以隐藏硬件的实现细节和参数。然而，这是无法做到的，因为只有内核空间才有特权操作硬件设备。一个折中的解决方案便是将对硬件的支持分别实现在内核空间和用户空间中，其中，内核空间仍然是以硬件驱动模块的形式来支持，不过它只提供简单的硬件访问通道；而用户空间以硬件抽象层模块的形式来支持，它封装了硬件的实现细节和参数。这样就可以保护移动设备厂商的利益了。</p><h2 id="系统运行层（库Libraries和运行环境Runtime）"><a href="#系统运行层（库Libraries和运行环境Runtime）" class="headerlink" title="系统运行层（库Libraries和运行环境Runtime）"></a>系统运行层（库Libraries和运行环境Runtime）</h2><p>&emsp;&emsp;本层次对应一般的嵌入式系统，相当于中间件层次。Android的本层次分成两个部分，一个是各种库，另一个是Android运行环境。本层的内容大多是使用C语言实现。<br>&emsp;&emsp;在一般情况下，Android的各种库是以系统中间件的形式提供的，它们的显著特点是与移动设备平台的应用密切相关。<br>另外，Android的运行环境主要是基于Dalvik（虚拟机）技术的。而Dalvik与一般的Java虚拟机（Java Virtual Machine，JVM）有如下区别：</p><ul><li>Java虚拟机：执行的是Java标准的字节码（Bytecode）。</li><li>Dalvik：执行的是Dalyik可执行格式（.dex）的文件。在执行的过程中，每一个应用程序即一个进程（Linux的一个Process）。</li></ul><p>&emsp;&emsp;二者最大的区别在于，JVM是基于栈的虚拟机（Stack-based），而Dalvik是基于寄存器的虚拟机（Register-based）。显然，后者最大的好处在于可以依据硬件实现更大的优化，这更适合移动设备的特点。</p><h2 id="应用框架层（Application-Framework）"><a href="#应用框架层（Application-Framework）" class="headerlink" title="应用框架层（Application Framework）"></a>应用框架层（Application Framework）</h2><p>&emsp;&emsp;在整个Android系统中，与应用开发最相关的是Application Framework，在这一层，Android为应用程序层的开发者提供了各种功能强大的APIs，这实际上是一个应用程序的框架。由于上层的应用程序是以Java构建的。在本层提供了程序中所需要的各种控件，例如：Views（视图组件）、List（列表）、Grid（栅格）、Text Box（文本框）、Button（按钮），甚至还有一个嵌入式的Web浏览器。<br>&emsp;&emsp;这一层提供的主要组件有：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Activity Manager(活动管理器)</td><td align="center">管理各个应用程序生命周期以及通常的导航回退功能</td></tr><tr><td align="center">Location Manager(位置管理器)</td><td align="center">提供地理位置以及定位功能服务</td></tr><tr><td align="center">Package Manager(包管理器)</td><td align="center">管理所有安装在Android系统中的应用程序</td></tr><tr><td align="center">Notification Manager(通知管理器)</td><td align="center">使得应用程序可以在状态栏中显示自定义的提示信息</td></tr><tr><td align="center">Resource Manager（资源管理器）</td><td align="center">提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td></tr><tr><td align="center">Telephony Manager(电话管理器)</td><td align="center">管理所有的移动设备功能</td></tr><tr><td align="center">Window Manager（窗口管理器）</td><td align="center">管理所有开启的窗口程序</td></tr><tr><td align="center">Content Providers（内容提供器）</td><td align="center">使得不同应用程序之间可以共享数据</td></tr><tr><td align="center">View System（视图系统）</td><td align="center">构建应用程序的基本组件</td></tr></tbody></table><h2 id="应用层（Application）"><a href="#应用层（Application）" class="headerlink" title="应用层（Application）"></a>应用层（Application）</h2><p>&emsp;&emsp;系统内置的应用程序以及非系统级的应用程序都是属于应用层。Android的应用程序负责与用户进行直接交互（GUI），通常基于Java进行开发，有时候还包含各种被放置在“res”目录中的资源文件。Java源码和相关资源在经过编译后会生成一个APK包。此外应用程序的开发者还可以使用应用程序框架层的API实现自己的程序。应用层是Android巨大潜力的体现。</p><h1 id="Android源码结构"><a href="#Android源码结构" class="headerlink" title="Android源码结构"></a>Android源码结构</h1><p>&emsp;&emsp;源码的全部工程可以分为三个部分：</p><ol><li>Core Project：核心工程部分，这是建立Android系统的基础，保存在根目录的各个文件夹中。</li><li>External Project：扩展工程部分，可以使其他开源项目具有扩展功能，保存在external文件夹中。</li><li>Package：包部分，提供了Android的应用程序、内容提供者、输入法和服务，保存在package文件夹中。</li></ol><p>&emsp;&emsp;源码中包含了原始的Android的目标机器代码、主机编译工具和仿真环境。第一级别目录结构如下：</p><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abi</td><td align="center">应用程序二进制接口</td></tr><tr><td align="center">art</td><td align="center">全新的ART运行环境</td></tr><tr><td align="center">bionic</td><td align="center">系统C库</td></tr><tr><td align="center">bootable</td><td align="center">启动引导相关代码</td></tr><tr><td align="center">build</td><td align="center">存放系统编译规则及generic等基础开发包配置</td></tr><tr><td align="center">cts</td><td align="center">Android兼容性测试套件标准</td></tr><tr><td align="center">dalvik</td><td align="center">dalvik虚拟机</td></tr><tr><td align="center">developers</td><td align="center">开发者目录</td></tr><tr><td align="center">development</td><td align="center">应用程序开发相关代码</td></tr><tr><td align="center">device</td><td align="center">设备相关配置</td></tr><tr><td align="center">docs</td><td align="center">参考文档目录</td></tr><tr><td align="center">external</td><td align="center">开源模组相关文件</td></tr><tr><td align="center">frameworks</td><td align="center">应用程序框架，Android系统核心部分，由Java和C++编写</td></tr><tr><td align="center">hardware</td><td align="center">主要是硬件抽象层的代码</td></tr><tr><td align="center">libcore</td><td align="center">核心库相关文件</td></tr><tr><td align="center">libnativehelper</td><td align="center">动态库，实现JNI库的基础</td></tr><tr><td align="center">ndk</td><td align="center">NDK相关代码。Android NDK（Android Native Development Kit）是一系列的开发工具，允许程序开发人员在Android应用程序中嵌入C/C++语言编写的非托管代码</td></tr><tr><td align="center">out</td><td align="center">编译完成后代码输出在此目录</td></tr><tr><td align="center">packages</td><td align="center">应用程序包</td></tr><tr><td align="center">pdk</td><td align="center">Plug Development Kit 的缩写，本地开发套件</td></tr><tr><td align="center">platform_testing</td><td align="center">平台测试</td></tr><tr><td align="center">prebuilts</td><td align="center">x86和arm架构下预编译的一些资源</td></tr><tr><td align="center">sdk</td><td align="center">sdk和模拟器</td></tr><tr><td align="center">system</td><td align="center">底层文件系统库、应用和组件，C语言实现</td></tr><tr><td align="center">toolchain</td><td align="center">工具链文件</td></tr><tr><td align="center">tools</td><td align="center">工具文件</td></tr><tr><td align="center">Makefile</td><td align="center">全局Makefile文件，用来定义编译规则</td></tr></tbody></table><p><img src="/images/Android/Android9.0.0%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Android9.0.0源码目录结构"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://androidxref.com/" target="_blank" rel="noopener">Android系统源码阅读</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5c0f7b90f265da613b6f9e97" target="_blank" rel="noopener">https://juejin.im/post/5c0f7b90f265da613b6f9e97</a></p><style>table th:nth-of-type(1){width:35%;}table th:nth-of-type(2){width: 65%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;基于Android 9.0&lt;br&gt;&lt;img src=&quot;/images/Android/android_training.jpg&quot; alt=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式软件开发工程师知识点</title>
    <link href="https://zhouyuebiao.cn/2019/09/16/0035-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zhouyuebiao.cn/2019/09/16/0035-嵌入式软件开发工程师知识点/</id>
    <published>2019-09-16T12:18:29.000Z</published>
    <updated>2019-09-19T08:48:52.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover/learn_dog.jpg" alt="cover"></p><h1 id="什么是预编译，何时需要预编译？"><a href="#什么是预编译，何时需要预编译？" class="headerlink" title="什么是预编译，何时需要预编译？"></a>什么是预编译，何时需要预编译？</h1><p>&emsp;&emsp;预编译又称预处理，是做一些代码文本的替换工作，处理‘#’开头的指令 , 比如拷贝 #include包含的文件代码， #define 宏定义的替换 , 条件编译等就是为编译做的预备工作的阶段预编译指令指示了在程序正式编译前就由编译器进行了操作，可以放在程序的任何位置。<br>&emsp;&emsp;何时使用：当大部分文件代码基本上不会更改时，比如 MFC的一些头文件以及一些必要的API 使用代码，也可以把你自己的一部分代码封装起来到一个 C或 C++文件中，（比如在其中包含一些头文件或必要的代码什么的， 然后在 VC-C/C++–PreCompiled Headers 里选择第三项 Create compiled Header file ）来指定为预编译头文件，这样就在以后的程序修改中编译时不会反复编译这部分。</p><blockquote><p>注意：过多的使用预编译头文件会大大降低编译的速度。</p></blockquote><h1 id="左定值右定向"><a href="#左定值右定向" class="headerlink" title="左定值右定向"></a>左定值右定向</h1><p>&emsp;&emsp;深入理解 char &#42;  const p,char const &#42; p,const char &#42; p 的区别</p><ol><li>关键看 const 修饰的是谁</li><li>由于没有 const &#42;  的运算，若出现 const &#42;  的形式，则 const 实际上是修饰前面的。</li></ol><p>&emsp;&emsp;char &#42; const p （const 修饰的是 p）：只能对“某个固定的位置” 进 行读写操作，并且在定义 p 时就必须初始化 （因为在后面不能执行“ p=.. ”的操作， 因此就不能在后面初始化，因此只能在定义时初始化） 。</p><blockquote><p>“某个固定的位 置”是相对于 char &#42; p 来说所限定的内容。</p></blockquote><p>&emsp;&emsp;char const&#42; p, 由于没有const&#42;运算，则const实际上是修饰前面的char，因此char const&#42; p等价于const char&#42; p。const char&#42; p 或者char const &#42; p （因为没有 const&#42; p 运算，因此const修饰的还是前面的char，可以对任意位置 （非系统敏感区域） 进行“只读” 操作。</p><blockquote><p>“只读”是相对于 char &#42; p 来说所限定的内容。</p></blockquote><h1 id="指针的长度？"><a href="#指针的长度？" class="headerlink" title="指针的长度？"></a>指针的长度？</h1><p>&emsp;&emsp;一个 32 位的机器 , 该机器的指针是多少位?：<br>&emsp;&emsp;指针是多少位只要看地址总线的位数就行了。 80386 以后的机子都是 32 的数据总线。所以指针的位数就是 4 个字节了。 </p><h1 id="进程的同步机制"><a href="#进程的同步机制" class="headerlink" title="进程的同步机制"></a>进程的同步机制</h1><p>&emsp;&emsp;列举几种进程的同步机制，并比较其优缺点 。</p><ul><li>原子操作</li><li>信号量机制</li><li>自旋锁</li><li>管程</li><li>会合</li><li>分布式系统</li></ul><h1 id="进程之间通信的途径"><a href="#进程之间通信的途径" class="headerlink" title="进程之间通信的途径"></a>进程之间通信的途径</h1><p>&emsp;&emsp;途径归纳而言如下：</p><ol><li>数据传输：一个进程向另一个进程传输数据，一般在一个字节和几 M字节之间。</li><li>共享数据</li><li>资源共享： 多个进程之间共享同样的资源， 为了做到这一点需要内核提供锁和同步机制。</li><li>通知事件 : 一个进程向另一个进程或一组进程发送消息， 通知他梦发生了某种事件 （如进程终止样通知付进程）</li><li>进程控制：有些进程希望完全控制另一个进程（ Debug进程），此时控制进程希望能够拦截另一个进程的所有的陷入和异常，并能够及时知道他的状态改变。</li></ol><h2 id="管道-pipe-："><a href="#管道-pipe-：" class="headerlink" title="管道 ( pipe ) ："></a>管道 ( pipe ) ：</h2><p>&emsp;&emsp;管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>&emsp;&emsp;创建一个简单的管道，可以使用系统调用 pipe() 。它接受一个参数，也就是一个包括两个整数的数组。 如果系统调用成功， 此数组将包括管道使用的两个文件描述符。 创建一个管道之后，一般情况下进程将产生一个新的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">系统调用： pipe();</span></span><br><span class="line"><span class="comment">原型： int pipe(int fd[2]);</span></span><br><span class="line"><span class="comment">返回值：如果系统调用成功，返回 0。如果系统调用失败返回 -1 ：</span></span><br><span class="line"><span class="comment">errno=EMFILE( 没有空亲的文件描述符）</span></span><br><span class="line"><span class="comment">EMFILE （系统文件表已满）</span></span><br><span class="line"><span class="comment">EFAULT （fd 数组无效）</span></span><br><span class="line"><span class="comment">注意： fd[0] 用于读取管道， fd[1] 用于写入管道。</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"><span class="comment">/*管道的创建*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create success\n"</span>);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管道的读写管道主要用于不同进程间通信。实际上，通常先创建一个管道，再通过 fork 函数创建一个<br>子进程。</p><p>子进程写入和父进程读的命名管道：</p><h3 id="管道读写注意事项："><a href="#管道读写注意事项：" class="headerlink" title="管道读写注意事项："></a>管道读写注意事项：</h3><p>&emsp;&emsp;可以通过打开两个管道来创建一个双向的管道。但需要在子理程中正确地设置文件描述符。<br>&emsp;&emsp;必须在系统调用 fork() 中调用 pipe() ，否则子进程将不会继承文件描述符。当使用半双工管道时，任何关联的进程都必须共享一个相关的祖先进程。因为管道存在于系统内核之中，所以任何不在创建管道的进程的祖先进程之中的进程都将无法寻址它。 而在命名管道中却不是这样。<br>&emsp;&emsp;管道实例见： pipe_rw.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf_r[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span>* p_wbuf;</span><br><span class="line">    <span class="keyword">int</span> r_num;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf_r,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf_r)); 数组中的数据清 <span class="number">0</span>；</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>((r_num=read(pipe_fd[<span class="number">0</span>],buf_r,<span class="number">100</span>))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d numbers read from be pipe is %s\n"</span>,r_num,buf_r);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">"Hello"</span>,<span class="number">5</span>)!=<span class="number">-1</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent write success!\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>(write(pipe_fd[<span class="number">1</span>],<span class="string">" Pipe"</span>,<span class="number">5</span>)!=<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent wirte2 succes!\n"</span>);</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        waitpid(pid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有名管道-named-pipe"><a href="#有名管道-named-pipe" class="headerlink" title="有名管道(named pipe)"></a>有名管道(named pipe)</h2><p>&emsp;&emsp;有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><h2 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h2><p>&emsp;&emsp;信号量是一个计数器，可以用来控制多个进程对共享资源的访问。 它常作为一种锁机制， 防止某进程正在访问共享资源时， 其他进程也访问该资源。 因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h2 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列(message queue)"></a>消息队列(message queue)</h2><p>&emsp;&emsp;消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。 消息队列克服了信号传递信息少、 管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h2 id="信号-sinal"><a href="#信号-sinal" class="headerlink" title="信号(sinal)"></a>信号(sinal)</h2><p>&emsp;&emsp;信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。信号是软件中断。信号（ signal ）机制是 Unix 系统中最为古老的进程之间的能信机制。它用于在一个或多个进程之间传递异步信号。很多条件可以产生一个信号。</p><h2 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存(shared memory)"></a>共享内存(shared memory)</h2><p>&emsp;&emsp;共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。 它往往与其他通信机制， 如信号两， 配合使用，来实现进程间的同步和通信。</p><h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><p>&emsp;&emsp;套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>&emsp;&emsp;死锁产生的原因及四个必要条件:</p><h2 id="产生死锁的原因："><a href="#产生死锁的原因：" class="headerlink" title="产生死锁的原因："></a>产生死锁的原因：</h2><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当等。<blockquote><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 其次， 进程运行推进顺序与速度不同， 也可能产生死锁。</p></blockquote></li></ol><h2 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h2><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。</p><blockquote><p>这四个条件是死锁的必要条件， 只要系统发生死锁， 这些条件必然成立， 而只要上述条件之一不满足，就不会发生死锁 。</p></blockquote><h2 id="死锁的解除与预防："><a href="#死锁的解除与预防：" class="headerlink" title="死锁的解除与预防："></a>死锁的解除与预防：</h2><p>&emsp;&emsp;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 所以，在系统设计、 进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法， 避免进程永久占据系统资源。 此外， 也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h2 id="操作系统中进程调度策略有哪几种？"><a href="#操作系统中进程调度策略有哪几种？" class="headerlink" title="操作系统中进程调度策略有哪几种？"></a>操作系统中进程调度策略有哪几种？</h2><ol><li>FCFS(先来先服务 ) </li><li>优先级</li><li>时间片轮转</li><li>多级反馈</li></ol><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><p>&emsp;&emsp;纯虚函数如何定义？使用时应注意什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void f()=0; 是接口，子类必须要实现</span><br></pre></td></tr></table></figure><h1 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>&emsp;&emsp;数据顺序存储，固定大小。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>&emsp;&emsp;数据可以随机存储，大小可动态改变</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="ISO-的七层模型是什么？"><a href="#ISO-的七层模型是什么？" class="headerlink" title="ISO 的七层模型是什么？"></a>ISO 的七层模型是什么？</h2><p>&emsp;&emsp;OSI（Open System Interconnection ）参考模型是国际标准化组织（ ISO）制定的一个用于计算机或通信系统间互联的标准体系， 一般称为 OSI 参考模型或七层模型。 它是一个七层的、抽象的模型，不仅包括一系列抽象的术语或概念，也包括具体的协议<br><img src="/images/network/OSI_Mode.png" alt="ISO七层模型"></p><p>&emsp;&emsp;网卡、集线器、hub工作在物理层<br>&emsp;&emsp;路由器(router)工作在网络层<br>&emsp;&emsp;交换机(switch)工作在数据链路层<br>&emsp;&emsp;常见的网络层协议： IP 协议、 ICMP、 IGMP、 MPLS、 ARP<br>&emsp;&emsp;常见的传输层协议： TCP、 UDP<br>&emsp;&emsp;常见的应用层协议： TELNET、 SMTP、 HTTP、 FTP、 DHCP、 SNMP</p><h2 id="tcp-udp-是属于哪一层？"><a href="#tcp-udp-是属于哪一层？" class="headerlink" title="tcp/udp 是属于哪一层？"></a>tcp/udp 是属于哪一层？</h2><p>&emsp;&emsp;tcp /udp 属于传输层<br>&emsp;&emsp;TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等<br>&emsp;&emsp;与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、 流控制以及错误恢复功能等。由于 UDP 比 较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。</p><blockquote><p>tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好，开销大，实时性较差。<br>udp: 包头小，开销小 , 占用资源少，实时性较好，缺点是不可靠。 tcp 是面向连接的可靠字节流</p></blockquote><h2 id="tcp-udp-有何优缺点？"><a href="#tcp-udp-有何优缺点？" class="headerlink" title="tcp/udp 有何优缺点？"></a>tcp/udp 有何优缺点？</h2><p>&emsp;&emsp;udp 是无连接的不可靠报文传递。<br>&emsp;&emsp;TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须在双方之间建立一个 TCP连接，之后才能传输数据， TCP提供超时重发、丢弃重复数据、检验数据、流控制等功能，保证数据能从一端传输到另一端。<br>&emsp;&emsp;UDP是用户数据报协议，是一个简单的面向数据报的运输层的协议。 UDP不提供可靠性，他只是把应用程序传给 IP 层的数据报发送出去。但是并不保证它们到达目的地，由于 UDP在传输前不需要在客户端与服务器端之间建立一个连接， 且没有超时重发机制， 故而传输速度很快。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr=(<span class="keyword">int</span> *)(&amp;a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="已知一个数组-table-，用一个宏定义，求出数据的元素个数"><a href="#已知一个数组-table-，用一个宏定义，求出数据的元素个数" class="headerlink" title="已知一个数组 table ，用一个宏定义，求出数据的元素个数"></a>已知一个数组 table ，用一个宏定义，求出数据的元素个数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIBL （sizeof(table)/sizfof(table[0]) ）</span></span><br></pre></td></tr></table></figure><h1 id="对于一个频繁使用的短小函数-在-C语言中应用什么实现-在-C-中应用什么实现"><a href="#对于一个频繁使用的短小函数-在-C语言中应用什么实现-在-C-中应用什么实现" class="headerlink" title="对于一个频繁使用的短小函数 , 在 C语言中应用什么实现 , 在 C++中应用什么实现 ?"></a>对于一个频繁使用的短小函数 , 在 C语言中应用什么实现 , 在 C++中应用什么实现 ?</h1><p>答案： c 用宏定义， c++用 inline</p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p>&emsp;&emsp;软件测试都有那些种类 ?</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h2 id="黑盒测试-1"><a href="#黑盒测试-1" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>&emsp;&emsp;指的是把被测的软件看作是一个黑盒子， 我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。它只检查程序功能是否按照需求规格说明书的规定正常使用， 程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>&emsp;&emsp;白盒测试， 指的是把盒子盖子打开， 去研究里面的源代码和程序结果。 它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作</p><h2 id="灰盒测试"><a href="#灰盒测试" class="headerlink" title="灰盒测试"></a>灰盒测试</h2><p>&emsp;&emsp;灰盒测试介于黑盒测试与白盒测试之间。<br>&emsp;&emsp;可以这样理解， 灰盒测试关注输出对于输入的正确性， 同时也关注内部表现， 但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p><h1 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enumstring &#123; x1, x2, x3=<span class="number">10</span>, x4, x5, &#125;x;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;问 x；<br>&emsp;&emsp;枚举元素的值不可以改变 但是你可以在定义时对其进行初始化 若都不赋值依次为 0 1 2 3 4 5 。。。若赋了一个值则后面的值为前面的一次加一对其进行赋值如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">string</span></span><br><span class="line">&#123;</span><br><span class="line">    x1=<span class="number">1</span>,</span><br><span class="line">    x2,</span><br><span class="line">    x3=<span class="number">10</span>,</span><br><span class="line">    x4=<span class="number">12</span>,</span><br><span class="line">    x5,</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么现在元素的值依次为：1 2 10 12 13</p><h1 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p1; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p2; </span><br><span class="line">p1=(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="number">0x801000</span>; </span><br><span class="line">p2=(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)<span class="number">0x810000</span>;</span><br></pre></td></tr></table></figure><p>请问： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1+5=?;</span><br><span class="line">p2+5=?;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;答案： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1+5=801005;</span><br><span class="line">p2+5=810014;</span><br></pre></td></tr></table></figure><blockquote><p>不要忘记了这个是 16 进制的数字， p2 要加 20 变为 16 进制就是 14</p></blockquote><h1 id="TCP-IP-通信建立的过程怎样，端口有什么作用？"><a href="#TCP-IP-通信建立的过程怎样，端口有什么作用？" class="headerlink" title="TCP/IP 通信建立的过程怎样，端口有什么作用？"></a>TCP/IP 通信建立的过程怎样，端口有什么作用？</h1><p>&emsp;&emsp;三次握手，确定是哪个应用程序使用该协议<br>&emsp;&emsp;TCP/IP 的三次握手</p><ul><li>第一次握手： 客户端发送 syn 包(syn=j) 到服务器， 并进入 SYN_SEND状态， 等待服务器确认 ;</li><li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN(ack=j+1) ，同时自己也发送一个SYN包(syn=k) ，即 SYN+ACK包，此时服务器进入 SYN_RECV状态 ;</li><li>第三次握手：客户端收到服务器的 SYN+ACK包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。</li></ul><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><p>&emsp;&emsp;理想状态下， TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP连接的请求，断开过程需要经过“四次握手” ( 过程就不细写了，就是服务器和客户端交互，最终确定断开 )</p><h1 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h1><p>&emsp;&emsp;TCP-传输控制协议， 提供的是面向连接、 可靠的字节流服务。 但客户端和服务器端彼此交换数据前，必须现在双方建立 TCP连接，然后才能传输数据。TCP提供方超时重发，丢弃重复的数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>&emsp;&emsp;UDP：用户数据报协议，是一个简单的面向数据报的运输层协议， UDP不提供平可靠性，他只是负者吧应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能够到达目的地，<br>&emsp;&emsp;由于 UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度快</p><h1 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a>局部变量能否和全局变量重名？</h1><p>&emsp;&emsp;能， 局部会屏蔽全局。 要用全局变量， 需要使用 “::” 局部变量可以与全局变量同名，在函数内引用这个变量时， 会用到同名的局部变量， 而不会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多个同名的局部变量， 比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p><h1 id="如何引用一个已经定义过的全局变量？"><a href="#如何引用一个已经定义过的全局变量？" class="headerlink" title="如何引用一个已经定义过的全局变量？"></a>如何引用一个已经定义过的全局变量？</h1><p>extern 可以用引用头文件的方式， 也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错</p><h1 id="全局变量可不可以定义在可被多个-C-文件包含的头文件中？为什么？"><a href="#全局变量可不可以定义在可被多个-C-文件包含的头文件中？为什么？" class="headerlink" title="全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？"></a>全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？</h1><p>&emsp;&emsp;可以，在不同的 C文件中以 static 形式来声明同名全局变量。可以在不同的 C文件中声明同名的全局变量， 前提是其中只能有一个 C文件中对此变量赋初值， 此时连接不会出错</p><h1 id="无限循环的表示方式"><a href="#无限循环的表示方式" class="headerlink" title="无限循环的表示方式"></a>无限循环的表示方式</h1><h2 id="for-1"><a href="#for-1" class="headerlink" title="for( ; 1 ; )"></a>for( ; 1 ; )</h2><p>&emsp;&emsp;语句 for( ; 1 ; ) 有什么问题？它是什么意思？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和while(1) 相同。</span><br></pre></td></tr></table></figure><h1 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h1><h2 id="队列和栈有什么区别-？"><a href="#队列和栈有什么区别-？" class="headerlink" title="队列和栈有什么区别 ？"></a>队列和栈有什么区别 ？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列先进先出，栈后进先出</span><br></pre></td></tr></table></figure><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>&emsp;&emsp;内存分配应该注意什么问题？</p><ol><li>检查内存是否分配成功</li><li>内存生命周期，程序结束时记得 free ，避免内存的泄露</li><li>使用过程中，避免指针的越界访问，会导致不必要的错误。</li></ol><h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。</li><li>线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</li></ol><blockquote><p>两者都可以提高程序的并发度，提高程序运行效率和响应时间。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>&emsp;&emsp;线程和进程在使用上各有优缺点： </p><ol><li>线程执行开销小， 但不利于资源管理和保护，而进程正相反。</li><li>同时，线程适合于在 SMP机器上运行，而进程则可以跨机器迁移。</li></ol><p>&emsp;&emsp;根本区别就一点：用多进程每个进程有自己的地址空间 (address space) ，线程则共享地址空间。所有其它区别都是由此而来的：</p><ul><li>速度： 线程产生的速度快， 线程间的通讯快、 切换快等， 因为他们在同一个地址空间内。</li><li>资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。</li><li>同步问题： 线程使用公共变量 / 内存时需要使用同步机制还是因为他们在同一个地址空间内。</li></ul><blockquote><p>实时操作系统 ： 所谓实时操作系统， 实际上是指操作系统工作时， 其资源可以根据需要随时进行动态分配，由于各种资源可以进行动态分配，因此其处理事务的能力较强、速度较快。其主要的特点是提供及时的响应和高可靠性。</p></blockquote><h1 id="堆栈溢出的主要原因是没有回收垃圾资源。"><a href="#堆栈溢出的主要原因是没有回收垃圾资源。" class="headerlink" title="堆栈溢出的主要原因是没有回收垃圾资源。"></a>堆栈溢出的主要原因是没有回收垃圾资源。</h1><h1 id="C语言的定义和声明"><a href="#C语言的定义和声明" class="headerlink" title="C语言的定义和声明"></a>C语言的定义和声明</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;编译器在创建一个对象时， 为该对象申请开辟的内存空间， 这个空间的的名字就是变量名或者对象名。同一个变量名在摸个区域内只能定义一次，重复定义会出现错误的。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>&emsp;&emsp;声明有两种作用：</p><ol><li>告诉编译器， 这个变量或者函数， 我已经定义了 （开辟空间了） ， 但是在别的地方，我先说明一下，免得编译器报错。当然，声明可以多次出现。</li><li>告诉编译器，这个变量名或者对象名，我先预定了， 其他地方不可以用了。和在饭馆吃饭（人多）要提前预约一样的道理。</li></ol><blockquote><p>定义和声明最本质的区别在于， 声明没开辟空间， 而定义则创建对象 （变量） 并开辟了空间。这是最重要的一点。</p></blockquote><h1 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h1><p>&emsp;&emsp;这个结构体的大小多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">int</span> Num ；</span><br><span class="line"><span class="keyword">char</span>*Pc ；</span><br><span class="line"><span class="keyword">short</span> sDtate ；</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">short</span> S[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;int：占 4 个字节（ 32 系统）。<br>&emsp;&emsp;char <em>pc：指针相当于地址，地址就是你当前操作系统的位数。如果是指针数组即存放指针的数组，占用的空间是 4</em>数组的个数。<br>&emsp;&emsp;如果是数组指针即指向数组的指针，指针指向的是数组的地址，占用 4 个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short sDtate：2 个</span><br><span class="line">char ch[2]：2 个</span><br><span class="line">short S[4]：2*4=8 short 型数组</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以一起占用：4+4+2+2+8=20 字节。</p><h1 id="在C-中引用C"><a href="#在C-中引用C" class="headerlink" title="在C++中引用C"></a>在C++中引用C</h1><p>&emsp;&emsp;如何在 C++中引用 C？<br>&emsp;&emsp;C++和 C是两种完全不同的编译连接处理方式，如果直接在 C++里面调用 C函数，会找不到函数体， 报连接错误， 就要在 C++文件中面申明哪些函数是 C写的， 要用 C的处理方式处理。<br>&emsp;&emsp;1、 引用头文件前需要加上 extern “C”如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"S.h"</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2、 C++调用 C函数的方法，将用到的函数全部重新声明一遍，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Extern <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Externa <span class="keyword">void</span> <span class="title">A_app</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C++语言支持函数的重载， C语言不支持函数的重载。函数被 C++编译后在库中的名字与 C语言的不同， 所以 C++程序不能直接调用 C函数， C++提供一个 C连接交换指定符号 extern ” C”来解决这个问题。</p><h1 id="C语言中嵌入汇编"><a href="#C语言中嵌入汇编" class="headerlink" title="C语言中嵌入汇编"></a>C语言中嵌入汇编</h1><p>&emsp;&emsp;C语言中嵌入汇编？<br>&emsp;&emsp;为什么需要嵌入汇编： C语言是一种中级语言，可以实现高级语言的模块化编程，又可以实现对底层的操作。但是，与汇编相比， C语言的效率还是比较低的。因此，在对效率与硬件操作要求比较高的地方，可以采用将部分汇编语句嵌入到 C语言中的方式。<br>&emsp;&emsp;在 gcc 中，可以使用 <em>asm_表示后面代码为内嵌汇编代码， _volatile</em> 表示编译器不要优化代码。语法 <em>asm</em> <em>volatile</em>( 汇编语句模板：输出部分：输入部分：破坏描述部分 )<br>&emsp;&emsp;汇编语句模板是汇编命令的字符串， 输出部分是需要输出到 C变量参数列表， 输入部分是需要从 C变量输入到 ASM汇编的参数列表， 破坏描述部分是执行汇编指令会破坏的寄存器描述。</p><h1 id="预处理指令-error"><a href="#预处理指令-error" class="headerlink" title="预处理指令#error"></a>预处理指令#error</h1><p>&emsp;&emsp;#error 预处理指令的作用是 ，编译程序时，只要遇到 #error 就会生成一个编译错误提示消息，并停止编译。其语法格式为： #error error-message</p><h1 id="Linux的内存管理"><a href="#Linux的内存管理" class="headerlink" title="Linux的内存管理"></a>Linux的内存管理</h1><p>&emsp;&emsp;早期的计算机中，程序直接运行在物理内存上。但是不适合现在的系统，这些支持多任务，多进程的。 这个时候我们就要考虑将系统的有限的物理内存如何及时有效的分配给多个程序，这个事情本身我们称之为内存管理。<br>&emsp;&emsp;内存管理想要解决的问题： </p><ol><li>进程地址空间不能分割，由于程序直接访问的是物理内存，这个时候程序锁使用的内存空间不是隔离的。</li><li>内存使用的效率低， </li><li>程序运行的地址不能确定， 程序每次运行的时候， 都要在内存中开辟一块足够大的空闲区域， 而这个空闲区域位置是不确定的，这会带来重定位的问题。</li></ol><p>&emsp;&emsp;内存管理无非就是想办法解决上面三个问题， 如何使进程的地址空间隔离， 如何提高内存的使用效率，如何解决程序运行时的重定位问题？<br>&emsp;&emsp;这里引用计算机界一句无从考证的名言： “计算机系统里的任何问题都可以靠引入一个中间层来解决。”<br>&emsp;&emsp;内存管理的几种方式：</p><ol><li>页式管理。 </li><li>段式管理。 </li><li>断页式管理</li></ol><h1 id="X86与X64"><a href="#X86与X64" class="headerlink" title="X86与X64"></a>X86与X64</h1><p>&emsp;&emsp;Intel 曾用 8086,80286,80386 等作为其PC用 CPU的型号表示法：</p><ul><li>X86 是 Intel 制造的普通CPU；</li><li>X64是 X86_64的缩写，是 X86 的改进版，加入了 64 位地址扩展等性能。</li></ul><h1 id="linux系统的Socket-网络编程"><a href="#linux系统的Socket-网络编程" class="headerlink" title="linux系统的Socket 网络编程"></a>linux系统的Socket 网络编程</h1><p>&emsp;&emsp;socket 相当于进行网络通信两端的插座， 只要对方的 socket 和自己的 socket 有通信连接，双方就可以通信。<br>&emsp;&emsp;服务器端的程序编写：</p><ol><li>调用 ServerSocket （int port ）创建一个服务器端的套接字，并绑定到指定的端口号。</li><li>调用 accept （），监听连接请求，则接收连接，返回通信套接字。</li><li>调用 Socket 类的 getOutStream （）和 getinputStream() 获取输出流和输入流，开始网络的输出与输入。</li><li>关闭通信套接字 Socket.close （）</li></ol><p>&emsp;&emsp;客户端的程序编写：</p><ol><li>调用 Socket 创建一个流套接字，并连接到服务器。</li><li>调用 Socket 类的 getoutputstream() 和 fetInputStream 获取输出流和输入流，开始网络的数据的发送和接收。</li><li>关闭通信套接字 socket.close().</li></ol><h1 id="网络中常见的-ping-命令是什么协议"><a href="#网络中常见的-ping-命令是什么协议" class="headerlink" title="网络中常见的 ping 命令是什么协议 ?"></a>网络中常见的 ping 命令是什么协议 ?</h1><p>&emsp;&emsp;Ping 的原理是，向指定的 ip 地址发送一定长度的数据包，按照约定，若指定的 IP 地址存在，会返回同样大小的数据包。在特定的时间没有返回，就是超时，一般认为指定的 IP 地址不存在。 Ping 使用的是 ICMP（Internet Control message protocol Internet 控制消息协议）。<br>&emsp;&emsp;有些防火墙会屏蔽 ICMP协议，所以有时候 ping 的结果只能做参考， ping 不同并不表示对方的 IP 不存在。 他是一把双刃剑， 别人使用 ping 命令可能会探测到你的计算机上的许多消息。可以安装防火墙，或创建一个禁止所有计算机 ping 本机地址的安全策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/cover/learn_dog.jpg&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是预编译，何时需要预编译？&quot;&gt;&lt;a href=&quot;#什么是预编译，何时需要预编译？&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式常见经典考点总结</title>
    <link href="https://zhouyuebiao.cn/2019/09/09/0034-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://zhouyuebiao.cn/2019/09/09/0034-嵌入式常见经典考点总结/</id>
    <published>2019-09-09T10:13:13.000Z</published>
    <updated>2019-09-19T08:48:46.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover/learn.jpg" alt="learn"></p><h1 id="一、预处理器（Preprocessor）"><a href="#一、预处理器（Preprocessor）" class="headerlink" title="一、预处理器（Preprocessor）"></a>一、预处理器（Preprocessor）</h1><h2 id="用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"><a href="#用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）" class="headerlink" title="用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"></a>用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我在这想看到几件事情：</p><ul><li>#define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）</li><li>懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</li><li>意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。</li><li>如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</li></ul><h2 id="写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个。"><a href="#写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个。" class="headerlink" title="写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。"></a>写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MIN(A,B) （（A） &lt;= (B) ? (A) : (B))</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个测试是为下面的目的而设的：</p><ul><li>标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</li><li>三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。</li><li>懂得在宏中小心地把参数用括号括起来</li><li>我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">least = MIN(*p++, b);</span><br></pre></td></tr></table></figure></li></ul><h2 id="预处理器标识-error的目的是什么？"><a href="#预处理器标识-error的目的是什么？" class="headerlink" title="预处理器标识#error的目的是什么？"></a>预处理器标识#error的目的是什么？</h2><p>&emsp;&emsp;如果你不知道答案，请看参考[附录]。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p><h1 id="二、死循环（Infinite-loops）"><a href="#二、死循环（Infinite-loops）" class="headerlink" title="二、死循环（Infinite loops）"></a>二、死循环（Infinite loops）</h1><p>&emsp;&emsp;嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？<br>这个问题用几个解决方案。我首选的方案是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一些程序员更喜欢如下方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是：”我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。</p></blockquote><p>&emsp;&emsp;第三个方案是用 goto</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure><blockquote><p>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。</p></blockquote><h1 id="三、数据声明（Data-declarations）"><a href="#三、数据声明（Data-declarations）" class="headerlink" title="三、数据声明（Data declarations）"></a>三、数据声明（Data declarations）</h1><p>&emsp;&emsp;用变量a给出下面的定义：</p><ul><li>a) 一个整型数（An integer） </li><li>b)一个指向整型数的指针（ A pointer to an integer） </li><li>c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r </li><li>d)一个有10个整型数的数组（ An array of 10 integers） </li><li>e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） </li><li>f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） </li><li>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） </li><li>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）</li></ul><p>&emsp;&emsp;答案是：</p><ul><li>a) int a; // An integer </li><li>b) int *a; // A pointer to an integer </li><li>c) int **a; // A pointer to a pointer to an integer </li><li>d) int a[10]; // An array of 10 integers </li><li>e) int *a[10]; // An array of 10 pointers to integers </li><li>f) int (*a)[10]; // A pointer to an array of 10 integers </li><li>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer </li><li>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer </li></ul><blockquote><p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？</p></blockquote><h1 id="四、Static"><a href="#四、Static" class="headerlink" title="四、Static"></a>四、Static</h1><p>&emsp;&emsp;关键字static的作用是什么？<br>&emsp;&emsp;这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：</p><ul><li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li><li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li><li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。<br>  大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。</li></ul><h1 id="五、Const"><a href="#五、Const" class="headerlink" title="五、Const"></a>五、Const</h1><p>&emsp;&emsp;关键字const有什么含意？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于限定一个变量为只读</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我只要一听到被面试者说：”const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着”只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）<br>&emsp;&emsp;如果应试者能正确回答这个问题，我将问他一个附加的问题：<br>&emsp;&emsp;下面的声明都是什么意思？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><ul><li>前两个的作用是一样，a是一个常整型数。</li><li>第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。</li><li>第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。</li><li>最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</li></ul><blockquote><p>如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：</p></blockquote><ul><li>关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）</li><li>通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</li><li>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</li></ul><h1 id="六、Volatile"><a href="#六、Volatile" class="headerlink" title="六、Volatile"></a>六、Volatile</h1><p>&emsp;&emsp;关键字volatile有什么含意?并给出三个不同的例子。<br>&emsp;&emsp;一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><ul><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li><li>多线程应用中被几个任务共享的变量<br>&emsp;&emsp;回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。<br>&emsp;&emsp;假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。</li><li>一个参数既可以是const还可以是volatile吗？解释为什么。</li><li>一个指针可以是volatile 吗？解释为什么。</li><li>下面的函数有什么错误：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;下面是答案：</p><ul><li>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</li><li>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</li><li>这段代码有点变态。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    b = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、位操作（Bit-manipulation）"><a href="#七、位操作（Bit-manipulation）" class="headerlink" title="七、位操作（Bit manipulation）"></a>七、位操作（Bit manipulation）</h1><p>&emsp;&emsp;嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。<br>&emsp;&emsp;对这个问题有三种基本的反应:</p><ul><li>不知道如何下手。该被面者从没做过任何嵌入式系统的工作。</li><li>用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。</li><li>用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。<br>最佳的解决方案如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1 &lt;&lt; 3)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a |= BIT3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&amp;=~操作。</p><h1 id="八、访问固定的内存位置（Accessing-fixed-memory-locations）"><a href="#八、访问固定的内存位置（Accessing-fixed-memory-locations）" class="headerlink" title="八、访问固定的内存位置（Accessing fixed memory locations）"></a>八、访问固定的内存位置（Accessing fixed memory locations）</h1><p>&emsp;&emsp;嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span>;</span><br><span class="line">*ptr = <span class="number">0xaa55</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;A more obscure approach is:<br>&emsp;&emsp;一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><h1 id="九、中断（Interrupts）"><a href="#九、中断（Interrupts）" class="headerlink" title="九、中断（Interrupts）"></a>九、中断（Interrupts）</h1><p>&emsp;&emsp;中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nArea = %f"</span>, area);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数有太多的错误了，以至让人不知从何说起了：</p><ul><li>ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。</li><li>ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</li><li>在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。</li><li>与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</li></ul><blockquote><p>重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这 样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。</p></blockquote><h1 id="十、代码例子（Code-examples）"><a href="#十、代码例子（Code-examples）" class="headerlink" title="十、代码例子（Code examples）"></a>十、代码例子（Code examples）</h1><p>12 . 下面的代码输出是什么，为什么？</p><pre><code>void foo(void){    unsigned int a = 6;    int b = -20;    (a+b &gt; 6) ? puts(&quot;&gt; 6&quot;) : puts(&quot;&lt;= 6&quot;);}</code></pre><p>&emsp;&emsp;这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p><ol start="13"><li>评价下面的代码片断：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = <span class="number">0xFFFF</span>; </span><br><span class="line"><span class="comment">/*1's complement of zero */</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = ~<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。<br>&emsp;&emsp;到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…</p><h1 id="十一、动态内存分配（Dynamic-memory-allocation）"><a href="#十一、动态内存分配（Dynamic-memory-allocation）" class="headerlink" title="十一、动态内存分配（Dynamic memory allocation）"></a>十一、动态内存分配（Dynamic memory allocation）</h1><p>&emsp;&emsp;尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所以回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> ((ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a null pointer"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a valid pointer"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p><h1 id="十二、Typedef"><a href="#十二、Typedef" class="headerlink" title="十二、Typedef"></a>十二、Typedef</h1><p>&emsp;&emsp;Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dPS struct s *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">tPS</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？<br>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dPS p1,p2;</span><br><span class="line">tPS p3,p4;</span><br></pre></td></tr></table></figure><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span>  <span class="comment">//宏定义的只对就近的那个生效</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。</p><h1 id="十三、晦涩的语法"><a href="#十三、晦涩的语法" class="headerlink" title="十三、晦涩的语法"></a>十三、晦涩的语法</h1><p>&emsp;&emsp;C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是，它会做些什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>, c;</span><br><span class="line">c = a+++b;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a++ + b;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此, 这段代码持行后a = 6, b = 7, c = 12。<br>&emsp;&emsp;如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。</p><h1 id="十四、递增-amp-减运算符：-amp-–"><a href="#十四、递增-amp-减运算符：-amp-–" class="headerlink" title="十四、递增&amp;减运算符：++ &amp; –"></a>十四、递增&amp;减运算符：++ &amp; –</h1><p>&emsp;&emsp;紧凑的代码让程序更为整洁，通常其生成的机器代码效率更高。<br>&emsp;&emsp;递增运算符(increment operator)将其运算对象递增1；递减运算符(decrement operator)将其运算递减1，该运算符以两种方式出现(两种模式的区别在于递增&amp;递减行为发生的时间不同)：</p><h2 id="出现在其作用的变量前面—前缀模式-a"><a href="#出现在其作用的变量前面—前缀模式-a" class="headerlink" title="++出现在其作用的变量前面—前缀模式(++a)"></a>++出现在其作用的变量前面—前缀模式(++a)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = <span class="number">2</span>*++a;</span><br></pre></td></tr></table></figure><ul><li>首先，a递增1；</li><li>然后，2乘以a，并将结果赋给q</li></ul><h2 id="出现在其作用的变量后面—后缀模式-a"><a href="#出现在其作用的变量后面—后缀模式-a" class="headerlink" title="++出现在其作用的变量后面—后缀模式(a++)"></a>++出现在其作用的变量后面—后缀模式(a++)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = <span class="number">2</span>*a++;</span><br></pre></td></tr></table></figure><ul><li>首先，2乘以a，并将结果赋给q；</li><li>然后，a递增1</li></ul><blockquote><p>出现在其作用的变量前面—前缀模式(–a)<br>出现在其作用的变量后面—后缀模式(a–)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/cover/learn.jpg&quot; alt=&quot;learn&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、预处理器（Preprocessor）&quot;&gt;&lt;a href=&quot;#一、预处理器（Preprocessor）&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="知识总结" scheme="https://zhouyuebiao.cn/tags/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之shell</title>
    <link href="https://zhouyuebiao.cn/2019/08/29/0033-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bshell/"/>
    <id>https://zhouyuebiao.cn/2019/08/29/0033-Linux搬砖三剑客之shell/</id>
    <published>2019-08-29T03:22:02.000Z</published>
    <updated>2019-08-29T06:14:48.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/shell/shell-logo.jpg" alt="linux-shell"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;这里讨论的shell，基于Bourne shell（默认shell）</p><h1 id="shell的特殊变量"><a href="#shell的特殊变量" class="headerlink" title="shell的特殊变量"></a>shell的特殊变量</h1><table><thead><tr><th align="center">特殊变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">$0</td><td align="center">当前脚本的文件名。</td></tr><tr><td align="center">$n</td><td align="center">这些变量对应于调用脚本的参数。这里n是对应于参数位置的正十进制数（第一个参数是$ 1，第二个参数是$ 2，依此类推）。</td></tr><tr><td align="center">$#</td><td align="center">提供给脚本的参数数量。</td></tr><tr><td align="center">$*</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ *相当于$ 1 $ 2。</td></tr><tr><td align="center">$@</td><td align="center">所有参数都是双引号。如果脚本收到两个参数，$ @相当于$ 1 $ 2。</td></tr><tr><td align="center">$?</td><td align="center">执行最后一个命令的退出状态。退出状态是每个命令完成后返回的数值。通常，大多数命令如果成功则返回退出状态0，如果不成功则返回1。</td></tr><tr><td align="center">$$</td><td align="center">当前shell的进程号。对于shell脚本，这是它们执行的进程ID。</td></tr><tr><td align="center">$!</td><td align="center">最后一个后台命令的进程号。</td></tr></tbody></table><blockquote><p>$ *和$ @两者的行为相同，除非它们用双引号括起来，“”。这两个参数都指定命令行参数。但是，“$ *”特殊参数将整个列表作为一个参数，其间带有空格，“$ @”特殊参数获取整个列表并将其分隔为单独的参数。</p></blockquote><h1 id="shell的运算符"><a href="#shell的运算符" class="headerlink" title="shell的运算符"></a>shell的运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">（加法）在运算符的任一侧添加值</td><td align="center"><code>expr $a + $b</code> 将给出30</td></tr><tr><td align="center">-</td><td align="center">（减法）从左手操作数中减去右手操作数</td><td align="center"><code>expr $a - $b</code> 将给-10</td></tr><tr><td align="center">*</td><td align="center">（乘法）将运算符两侧的值相乘</td><td align="center"><code>expr $a \* $b</code> 将给出200</td></tr><tr><td align="center">/</td><td align="center">（除法）用左手操作数除左手操作数</td><td align="center"><code>expr $b / $a</code> 将给出2</td></tr><tr><td align="center">%</td><td align="center">（取模）用左手操作数除左手操作数并返回余数</td><td align="center"><code>expr $b ％ $a</code> 将给出0</td></tr><tr><td align="center">=</td><td align="center">（赋值）在左操作数中指定右操作数</td><td align="center">a = $b 会将b的值赋给a</td></tr><tr><td align="center">==</td><td align="center">（等于）比较两个数字，如果两个数字相同则返回true。</td><td align="center">[ $a == $b ] 会返回false。</td></tr><tr><td align="center">!=</td><td align="center">（不等于）比较两个数字，如果两个数字不同则返回true。</td><td align="center">[ $a != $b ] 会返回true。</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-eq</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a -eq $b ] is not true.</td></tr><tr><td align="center">-ne</td><td align="center">检查两个操作数的值是否相等; 如果值不相等，则条件成立。</td><td align="center">[ $a -ne $b ] is true.</td></tr><tr><td align="center">-gt</td><td align="center">检查左操作数的值是否大于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -gt $b ] is not true.</td></tr><tr><td align="center">-lt</td><td align="center">检查左操作数的值是否小于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -lt $b ] is true.</td></tr><tr><td align="center">-ge</td><td align="center">检查左操作数的值是否大于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">[ $a -ge $b ] is not true.</td></tr><tr><td align="center">-le</td><td align="center">检查左操作数的值是否小于或等于右操作数的值; 如果是，则条件成立。</td><td align="center">$a -le $b ] is true.</td></tr></tbody></table><blockquote><p>所有条件表达式应放在方括号内并且周围有空格是非常重要的。例如，[ $a &lt;= $b ]是正确的，而[$a&lt;=$b]是不正确的。</p></blockquote><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>&emsp;&emsp;示例中,假设变量a为10，变量b为20。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">这是合乎逻辑的否定。这将真实条件反转为假，反之亦然。</td><td align="center">[ ! false ] is true.</td></tr><tr><td align="center">-o</td><td align="center">这是合乎逻辑的OR。如果其中一个操作数为true，则条件成立。</td><td align="center">[ $a -lt 20 -o $b -gt 100 ] is true.</td></tr><tr><td align="center">-a</td><td align="center">这是合乎逻辑的和。如果两个操作数都为真，则条件变为true，否则为false。</td><td align="center">[ $a -lt 20 -a $b -gt 100 ] is false.</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>&emsp;&emsp;示例中,假设变量a为“abc”，而变量b为“efg”。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">检查两个操作数的值是否相等; 如果是，则条件成立。</td><td align="center">[ $a = $b ] is not true.</td></tr><tr><td align="center">!=</td><td align="center">检查两个操作数的值是否相等; 如果值不相等则条件变为真。</td><td align="center">[ $a != $b ] is true.</td></tr><tr><td align="center">-z</td><td align="center">检查给定的字符串操作数大小是否为零; 如果长度为零，则返回true。</td><td align="center">[ -z $a ] is not true.</td></tr><tr><td align="center">-n</td><td align="center">检查给定的字符串操作数大小是否为非零; 如果它是非零长度，则返回true。</td><td align="center">[ -n $a ] is not false.</td></tr><tr><td align="center">str</td><td align="center">检查str是否不是空字符串; 如果它是空的，则返回false。</td><td align="center">[ $a ] is not false.</td></tr></tbody></table><h2 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h2><p>&emsp;&emsp;这些运算符可用于测试与Unix文件相关的各种属性。<br>&emsp;&emsp;示例中，假设变量文件包含现有文件名“test”，其大小为100字节，并具有读取，写入和执行权限。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="center">检查文件是否是块特殊文件; 如果是，则条件成立。</td><td align="center">[ -b $file ] is false</td></tr><tr><td align="center">-c file</td><td align="center">检查文件是否是字符特殊文件; 如果是，则条件成立。</td><td align="center">[ -c $file ] is false.</td></tr><tr><td align="center">-d file</td><td align="center">检查文件是否是目录; 如果是，则条件成立。</td><td align="center">[ -d $file ] is not true.</td></tr><tr><td align="center">-f file</td><td align="center">检查文件是普通文件而不是目录或特殊文件; 如果是，则条件成立。</td><td align="center">[ -f $file ] is true.</td></tr><tr><td align="center">-g file</td><td align="center">检查文件是否设置了组ID（SGID）位; 如果是，则条件成立。</td><td align="center">[ -g $file ] is false.</td></tr><tr><td align="center">-k file</td><td align="center">检查文件是否设置了粘滞位; 如果是，则条件成立。</td><td align="center">[ -k $file ] is false.</td></tr><tr><td align="center">-p file</td><td align="center">检查文件是否是命名管道; 如果是，则条件成立。</td><td align="center">[ -p $file ] is false.</td></tr><tr><td align="center">-t file</td><td align="center">检查文件描述符是否打开并与终端关联; 如果是，则条件成立。</td><td align="center">[ -t $file ] is false.</td></tr><tr><td align="center">-u file</td><td align="center">检查文件是否设置了其用户ID（SUID）位; 如果是，则条件成立。</td><td align="center">[ -u $file ] is false.</td></tr><tr><td align="center">-r file</td><td align="center">检查文件是否可读; 如果是，则条件成立。</td><td align="center">[ -r $file ] is true.</td></tr><tr><td align="center">-w file</td><td align="center">检查文件是否可写; 如果是，则条件成立。</td><td align="center">[ -w $file ] is true.</td></tr><tr><td align="center">-x file</td><td align="center">检查文件是否可执行; 如果是，则条件成立。</td><td align="center">[ -x $file ] is true.</td></tr><tr><td align="center">-s file</td><td align="center">检查文件的大小是否大于0; 如果是，则条件成立。</td><td align="center">[ -s $file ] is true.</td></tr><tr><td align="center">-e file</td><td align="center">检查文件是否存在; 即使file是目录但存在，也是如此。</td><td align="center">[ -e $file ] is true.</td></tr></tbody></table><h1 id="shell修炼秘籍"><a href="#shell修炼秘籍" class="headerlink" title="shell修炼秘籍"></a>shell修炼秘籍</h1><h2 id="shell命令图谱"><a href="#shell命令图谱" class="headerlink" title="shell命令图谱"></a>shell命令图谱</h2><p><img src="/images/shell/Linux-shell-commands.png" alt="Linux-shell-commands"></p><h1 id="shell的种类"><a href="#shell的种类" class="headerlink" title="shell的种类"></a>shell的种类</h1><p><img src="/images/shell/shells.svg" alt="shells"></p><p>&emsp;&emsp;shell是一个用户终端，是内核与用户之间的翻译官。内核解释shell翻译过来的用户命令从而指挥CPU和其他计算机硬件如何执行特定任务。<br>每次用户登录时，都会启动shell。shell的类型取决于用户的选择，在大多数情况下默认设置为bash。</p><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>&emsp;&emsp;Bash (GNU Bourne-Again Shell) 是许多Linux发行版的默认Shell，它是用户帐户最常见的默认shell。</p><h2 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h2><p>&emsp;&emsp;C Shell被创造的Bill Joy在加州大学伯克利分校。他的主要目的是使用类似C语言的语法创建一个shell。因此，它包括控制结构和表达式语法之类的功能。<br>&emsp;&emsp;其他功能包括历史记录和编辑机制，别名，目录堆栈，代字符表示法，cdpath，作业控制和路径哈希等等。</p><h2 id="tcsh"><a href="#tcsh" class="headerlink" title="tcsh"></a>tcsh</h2><p>&emsp;&emsp;将tcsh被开发成为与C shell兼容。t in tcsh来自TENEX，这是一个操作系统。<br>&emsp;&emsp;tcsh与csh命令行编辑和其他功能等扩展非常接近。Mac OS X以前是tcsh默认配置，但在版本10.3中切换为bash。</p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>&emsp;&emsp;Z shell是专为交互式使用而设计的。<br>&emsp;&emsp;Z shell的一些功能包括拼写检查，在单个缓冲区中编辑多行命令，改进的变量和数组处理，自定义，可编程命令行完成和可主题提示。</p><h2 id="还有很多甚至更多"><a href="#还有很多甚至更多" class="headerlink" title="还有很多甚至更多"></a>还有很多甚至更多</h2><p>&emsp;&emsp;还有很多shell可供选择！当我们了解有关终端和shell的更多信息时，可能希望升级到另一个shell。但是一般而言，bash已经很好地满足我们的需求了。</p><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 90%;}</style><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 65%;}table th:nth-of-type(3){width: 25%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/shell/shell-logo.jpg&quot; alt=&quot;linux-shell&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="shell" scheme="https://zhouyuebiao.cn/categories/shell/"/>
    
    
      <category term="shell" scheme="https://zhouyuebiao.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之vi&amp;vim</title>
    <link href="https://zhouyuebiao.cn/2019/08/28/0032-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bvi&amp;vim/"/>
    <id>https://zhouyuebiao.cn/2019/08/28/0032-Linux搬砖三剑客之vi&amp;vim/</id>
    <published>2019-08-28T03:40:30.000Z</published>
    <updated>2019-09-19T08:52:53.783Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vi&vim/vi&vimlog.png" alt="vi&amp;vimlog"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不可不知的两大编辑器：</p><ul><li>编辑器之神——Vim</li><li>神之编辑器——Emacs</li></ul><p>&emsp;&emsp;有趣的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a>。</p><p>&emsp;&emsp;vim与神的编辑器emacs的争论从来没有停止过。两种编辑器的设计哲学完全不同，风格迥异。vim的特点是Composability（组合性），Emacs的特点是Extensibility（可扩展性）。vim使用键序列输入，Emacs则经常使用组合键（同时按）输入，所以Emacs有个绰号Esc + Meta + Alt + Ctrl + Shift。正因为各种显著的差异各种争论在所难免，对此我们应该端正自己的心态：提高自己的格局，少一些争论。</p><h1 id="磨刀不误砍柴工"><a href="#磨刀不误砍柴工" class="headerlink" title="磨刀不误砍柴工"></a>磨刀不误砍柴工</h1><p>&emsp;&emsp;不做无谓的争论，工欲善其事必先利其器，我们只管选择一种自己顺手的工具（我选择vi&amp;vim）来学习，不断深入学习，提高自己的同时，不断与工具磨合，早日达到人剑合一的境界，笑看江湖。<br><img src="/images/vi&vim/huaji.jpg" alt="huaji"></p><h2 id="进入vim的姿势"><a href="#进入vim的姿势" class="headerlink" title="进入vim的姿势"></a>进入vim的姿势</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">vim filename</td><td align="center">打开或新建文件，并将光标置于第一行首</td></tr><tr><td align="center">vim +num filename</td><td align="center">打开文件，并将光标置于第n行首</td></tr><tr><td align="center">vim + filename</td><td align="center">打开文件，并将光标置于最后一行首</td></tr><tr><td align="center">vim +/pattern filename</td><td align="center">打开文件，并将光标置于第一个与pattern匹配的串处</td></tr><tr><td align="center">vim -r filename</td><td align="center">在上次正用vim编辑时发生系统崩溃，恢复filename</td></tr><tr><td align="center">vim filenae1…filenamen</td><td align="center">打开多个文件，依次编辑</td></tr></tbody></table><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">列出所有选项设置情况</td></tr><tr><td align="center">term</td><td align="center">设置终端类型</td></tr><tr><td align="center">ignorance</td><td align="center">在搜索中忽略大小写</td></tr><tr><td align="center">list</td><td align="center">显示制表位（Ctrl+1）和行尾标志（$）显示行号</td></tr><tr><td align="center">number</td><td align="center">显示由面向行的命令修改过的数目</td></tr><tr><td align="center">report</td><td align="center">显示简短的警告信息</td></tr><tr><td align="center">terse</td><td align="center">在转到别的文件时若没保存当前文件则显示NO write信息</td></tr><tr><td align="center">nomagic</td><td align="center">允许在搜索模式中，使用前面不带“V的特殊字符</td></tr><tr><td align="center">nowrapscan</td><td align="center">禁止vi在搜索到达文件两端时，又从另一端开始</td></tr><tr><td align="center">mesg</td><td align="center">允许vi显示其他用户用write写到自己终端上的信息</td></tr><tr><td align="center">:set number</td><td align="center">显示行号</td></tr><tr><td align="center">:set nonumber</td><td align="center">不显示行号</td></tr><tr><td align="center">set ruler</td><td align="center">显示标尺</td></tr><tr><td align="center">set noruler</td><td align="center">不显示标尺</td></tr><tr><td align="center">:set hlsearch</td><td align="center">高亮显示查找到的单词</td></tr><tr><td align="center">:set nohlsearch</td><td align="center">关闭高亮显示</td></tr><tr><td align="center">:syntax on</td><td align="center">语法高亮显示行号</td></tr><tr><td align="center">:set tabstop=8</td><td align="center">设置tab大小，8为最常用最普遍的设置4.4个空格，8.正常的制表符，12:一个制表符4个空格，16.两个制表符</td></tr><tr><td align="center">:set autoindent</td><td align="center">自动缩进</td></tr><tr><td align="center">:set cindent</td><td align="center">C语言格式里面的自动缩进</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">k</td><td align="center">向上移动</td></tr><tr><td align="center">j</td><td align="center">向下移动</td></tr><tr><td align="center">h</td><td align="center">向左移动</td></tr><tr><td align="center">l</td><td align="center">向右移动</td></tr><tr><td align="center">k nk</td><td align="center">向上移动n行</td></tr><tr><td align="center">j nk</td><td align="center">向下移动n行</td></tr><tr><td align="center">h nh</td><td align="center">向左移动n行</td></tr><tr><td align="center">l nl</td><td align="center">向右移动n行</td></tr><tr><td align="center">Spach</td><td align="center">光标右移一个字符</td></tr><tr><td align="center">Backspace</td><td align="center">光标左移一个字符</td></tr><tr><td align="center">Enter</td><td align="center">光标下移一行</td></tr><tr><td align="center">w/W</td><td align="center">光标右移一个字至字首</td></tr><tr><td align="center">b/B</td><td align="center">光标左移一个字至字首</td></tr><tr><td align="center">e/e</td><td align="center">光标右移一个字至字尾</td></tr><tr><td align="center">)</td><td align="center">光标移至句尾</td></tr><tr><td align="center">(</td><td align="center">光标移至句首</td></tr><tr><td align="center">}</td><td align="center">光标移至段落开头</td></tr><tr><td align="center">{</td><td align="center">光标移至段落结尾</td></tr><tr><td align="center">n$</td><td align="center">光标移至第n行尾</td></tr><tr><td align="center">H</td><td align="center">光标移至屏幕顶行</td></tr><tr><td align="center">M</td><td align="center">光标移至屏幕中间行</td></tr><tr><td align="center">L</td><td align="center">光标移至屏幕最后行</td></tr><tr><td align="center">0</td><td align="center">（注意是数字零）光标移至当前行首</td></tr><tr><td align="center">^</td><td align="center">移动光标到行首第一个非空字符上去</td></tr><tr><td align="center">$</td><td align="center">光标移至当前行尾</td></tr><tr><td align="center">gg</td><td align="center">移到第一行</td></tr><tr><td align="center">G</td><td align="center">移到最后一行</td></tr><tr><td align="center">f</td><td align="center">移动光标到当前行的字符a上</td></tr><tr><td align="center">F</td><td align="center">与f相反</td></tr><tr><td align="center">%</td><td align="center">移动到与制匹配的括号上去（），}，Ⅱ，&lt;&gt;等</td></tr><tr><td align="center">nG</td><td align="center">移动到第n行上</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr></tbody></table><h2 id="屏幕滚动"><a href="#屏幕滚动" class="headerlink" title="屏幕滚动"></a>屏幕滚动</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+u</td><td align="center">向文件首翻半屏</td></tr><tr><td align="center">Ctrl+d</td><td align="center">向文件尾翻半屏</td></tr><tr><td align="center">Ctrl+f</td><td align="center">向文件尾翻一屏</td></tr><tr><td align="center">Ctrl+b</td><td align="center">向文件首翻一屏</td></tr><tr><td align="center">nz</td><td align="center">将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</td></tr></tbody></table><h2 id="插入文本类"><a href="#插入文本类" class="headerlink" title="插入文本类"></a>插入文本类</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">在光标前</td></tr><tr><td align="center">I</td><td align="center">在当前行首</td></tr><tr><td align="center">a</td><td align="center">光标后</td></tr><tr><td align="center">A</td><td align="center">在当前行尾</td></tr><tr><td align="center">o</td><td align="center">在当前行之下新开一行</td></tr><tr><td align="center">O</td><td align="center">在当前行之上新开一行</td></tr><tr><td align="center">r</td><td align="center">替换当前字符</td></tr><tr><td align="center">R</td><td align="center">替换当前字符及其后的字符，直至按ESC键</td></tr><tr><td align="center">s</td><td align="center">从当前光标位置处开始，以输入的文本替代指定数目的字符</td></tr><tr><td align="center">S</td><td align="center">删除指定数目的行，并以所输入文本代替之</td></tr><tr><td align="center">ncw/nCW</td><td align="center">修改指定数目的字</td></tr><tr><td align="center">nCC</td><td align="center">修改指定数目的行</td></tr></tbody></table><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x/X</td><td align="center">删除一个字符，x删除光标后的，而X删除光标前的</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词（删除光标位置到下一个单词开始的位置）</td></tr><tr><td align="center">dnw</td><td align="center">删除n个单词</td></tr><tr><td align="center">dne</td><td align="center">也可，只是删除到单词尾</td></tr><tr><td align="center">do</td><td align="center">删至行首</td></tr><tr><td align="center">d$</td><td align="center">删至行尾</td></tr><tr><td align="center">dd</td><td align="center">删除一行</td></tr><tr><td align="center">ndd</td><td align="center">删除当前行及其后n-1行</td></tr><tr><td align="center">dnl</td><td align="center">向右删除n个字母</td></tr><tr><td align="center">dnh</td><td align="center">向左删除n个字母</td></tr><tr><td align="center">dnj</td><td align="center">向下删除n行，当前行+其上n行</td></tr><tr><td align="center">dnk</td><td align="center">向上删除n行，当期行+其下n行</td></tr><tr><td align="center">cnw[word]</td><td align="center">将n个word改变为word</td></tr><tr><td align="center">C$</td><td align="center">改变到行尾</td></tr><tr><td align="center">cc</td><td align="center">改变整行</td></tr><tr><td align="center">shift+j</td><td align="center">删除行尾的换行符，下一行接上来了</td></tr></tbody></table><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">p</td><td align="center">粘贴用x或d删除的文本</td></tr><tr><td align="center">ynw</td><td align="center">复制n个单词</td></tr><tr><td align="center">yy</td><td align="center">复制一行</td></tr><tr><td align="center">ynl</td><td align="center">复制n个字符</td></tr><tr><td align="center">y$</td><td align="center">复制当前光标至行尾处</td></tr><tr><td align="center">nyy</td><td align="center">拷贝n行</td></tr></tbody></table><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>|u          |撤销前一次的操作<br>|shif+u(U)  |撤销对该行的所有操作</p><h2 id="搜索及替换"><a href="#搜索及替换" class="headerlink" title="搜索及替换"></a>搜索及替换</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">/pattern</td><td align="center">从光标开始处向文件尾搜索pattern</td></tr><tr><td align="center">?pattern</td><td align="center">从光标开始处向文件首搜索pattern</td></tr><tr><td align="center">n</td><td align="center">在同一方向重复上一次搜索命令</td></tr><tr><td align="center">N</td><td align="center">在反方向上重复上一次搜索命令</td></tr><tr><td align="center">cw newword</td><td align="center">替换为newword</td></tr><tr><td align="center">n</td><td align="center">继续查找</td></tr><tr><td align="center">.</td><td align="center">执行替换</td></tr><tr><td align="center">:s/p1/p2/g</td><td align="center">将当前行中所有p1均用p2替代，g表示执行用c表示需要确认</td></tr><tr><td align="center">:n1,n2 s/p1/p2/g</td><td align="center">将第n1至n2行中所有p1均用p2替代</td></tr><tr><td align="center">:g/p1/s//p2/g</td><td align="center">将文件中所有p1均用p2替换</td></tr><tr><td align="center">:1,$ s/string1/string2/g</td><td align="center">在全文中将string1替换为string2</td></tr></tbody></table><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">,[a-z]</td><td align="center">在文中做标记，标记号可为a-z的26个字母</td></tr><tr><td align="center">`a</td><td align="center">移动到标记a处</td></tr></tbody></table><h2 id="visual模式"><a href="#visual模式" class="headerlink" title="visual模式"></a>visual模式</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">v</td><td align="center">进入visual模式</td></tr><tr><td align="center">V</td><td align="center">进入行的visual模式</td></tr><tr><td align="center">ctrl+V</td><td align="center">进如块操作模式用o和O改变选择的边的大小</td></tr><tr><td align="center">在所有行插入相同的内容如include&lt;</td><td align="center">将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按1（shit+），后插入要插入的文本，按IESC]完成</td></tr></tbody></table><h2 id="行方式命令"><a href="#行方式命令" class="headerlink" title="行方式命令"></a>行方式命令</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:n1,n2 co n3</td><td align="center">将n1行到n2行之间的内容拷贝到第n3行下</td></tr><tr><td align="center">:n1,n2 m n3</td><td align="center">将n1行到n2行之间的内容移至到第n3行下</td></tr><tr><td align="center">:n1,n2 d</td><td align="center">将n1行到n2行之间的内容删除</td></tr><tr><td align="center">:n1,n2 wlcommand</td><td align="center">将文件中n1行至n2行的内容作为command的输入并执行之</td></tr></tbody></table><blockquote><p>若不指定n1，n2，则表示将整个文件内容作为command的输入 |</p></blockquote><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">q[a-z]</td><td align="center">开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏</td></tr><tr><td align="center">reg</td><td align="center">显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z]</td></tr></tbody></table><h2 id="操作窗口"><a href="#操作窗口" class="headerlink" title="操作窗口"></a>操作窗口</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:split</td><td align="center">分割一个窗口</td></tr><tr><td align="center">:split file.c</td><td align="center">为另一个文件fle.c分隔窗口</td></tr><tr><td align="center">:nsplit file.c</td><td align="center">为另一个文件file.c分隔窗口，并指定其行数</td></tr><tr><td align="center">ctrl + W</td><td align="center">在窗口中切换</td></tr><tr><td align="center">:close</td><td align="center">关闭当前窗口</td></tr></tbody></table><h2 id="文件及其他"><a href="#文件及其他" class="headerlink" title="文件及其他"></a>文件及其他</h2><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:q退出vi</td><td align="center"></td></tr><tr><td align="center">:q!</td><td align="center">不保存文件并退出vi/vim</td></tr><tr><td align="center">:e filename</td><td align="center">打开文件filename进行编辑</td></tr><tr><td align="center">:e!</td><td align="center">放弃修改文件内容，重新载入该文件编辑</td></tr><tr><td align="center">:W</td><td align="center">保存当前文件</td></tr><tr><td align="center">:wq</td><td align="center">存盘后再退出</td></tr><tr><td align="center">:ZZ</td><td align="center">保存当前文档并退出vi/vim</td></tr><tr><td align="center">:!command</td><td align="center">执行shell命令command</td></tr><tr><td align="center">:r!command</td><td align="center">将命令command的输出结果放到当前行</td></tr><tr><td align="center">:n1,n2 write temp.c</td><td align="center"></td></tr><tr><td align="center">:read file.c</td><td align="center">将文件file.c的内容插入到当前光标所在的下面</td></tr></tbody></table><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><h2 id="寓教于乐"><a href="#寓教于乐" class="headerlink" title="寓教于乐"></a>寓教于乐</h2><p>&emsp;&emsp;<a href="https://vim-adventures.com/" target="_blank" rel="noopener">非常有趣的VIM学习小游戏。</a></p><h2 id="修炼秘籍-1"><a href="#修炼秘籍-1" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h2><h2 id="vim命令图解（中文版）"><a href="#vim命令图解（中文版）" class="headerlink" title="vim命令图解（中文版）"></a>vim命令图解（中文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-cn.png" alt="vim命令图解cn"></p><h2 id="vim命令图解（英文版）"><a href="#vim命令图解（英文版）" class="headerlink" title="vim命令图解（英文版）"></a>vim命令图解（英文版）</h2><p><img src="/images/vi&vim/vim-cheat-sheet-en.png" alt="vim命令图解en"></p><h2 id="vim命令图解大全"><a href="#vim命令图解大全" class="headerlink" title="vim命令图解大全"></a>vim命令图解大全</h2><p>&emsp;&emsp;此图内容比较繁多，窃以为入门学习上面两个图足矣。<br><img src="/images/vi&vim/vim_cheat_sheet_for_programmers_screen.png" alt="vim命令图解大全"></p><p>&emsp;&emsp;当然，如果对此资源感兴趣，可前往<a href="http://michael.peopleofhonoronly.com/vim/" target="_blank" rel="noopener">此处获取</a>更全面的资源。</p><h2 id="其他未分类资源"><a href="#其他未分类资源" class="headerlink" title="其他未分类资源"></a>其他未分类资源</h2><p><img src="/images/vi&vim/preview.webp" alt="vim-preview"></p><p><img src="/images/vi&vim/vim-movement-commands-cheatsheet.png" alt="vim-movement-commands-cheatsheet"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>&emsp;&emsp;<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E6%88%98" target="_blank" rel="noopener">编辑器之战</a></p><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vi&amp;vim/vi&amp;vimlog.png&quot; alt=&quot;vi&amp;amp;vimlog&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不可
      
    
    </summary>
    
      <category term="tools" scheme="https://zhouyuebiao.cn/categories/tools/"/>
    
    
      <category term="tools" scheme="https://zhouyuebiao.cn/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Linux搬砖三剑客之git</title>
    <link href="https://zhouyuebiao.cn/2019/08/21/0031-Linux%E6%90%AC%E7%A0%96%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BGit/"/>
    <id>https://zhouyuebiao.cn/2019/08/21/0031-Linux搬砖三剑客之Git/</id>
    <published>2019-08-21T11:49:00.000Z</published>
    <updated>2019-08-29T07:53:42.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git/gswg-git-solid-choice.png" alt="gswg-git-solid-choice"></p><h1 id="git指令速查表"><a href="#git指令速查表" class="headerlink" title="git指令速查表"></a>git指令速查表</h1><p><img src="/images/git/git-cheat-sheet-large01-cn.png" alt="git指令速查表"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="复制一个已创建的仓库"><a href="#复制一个已创建的仓库" class="headerlink" title="复制一个已创建的仓库"></a>复制一个已创建的仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span></span><br></pre></td></tr></table></figure><h3 id="创建一个新的本地仓库"><a href="#创建一个新的本地仓库" class="headerlink" title="创建一个新的本地仓库"></a>创建一个新的本地仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><h3 id="显示工作路径下全部已修改的文件"><a href="#显示工作路径下全部已修改的文件" class="headerlink" title="显示工作路径下全部已修改的文件"></a>显示工作路径下全部已修改的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><h3 id="显示与上次提交版本文件的不同"><a href="#显示与上次提交版本文件的不同" class="headerlink" title="显示与上次提交版本文件的不同"></a>显示与上次提交版本文件的不同</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br></pre></td></tr></table></figure><h3 id="把当前所有修改添加到下次提交中"><a href="#把当前所有修改添加到下次提交中" class="headerlink" title="把当前所有修改添加到下次提交中"></a>把当前所有修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br></pre></td></tr></table></figure><h3 id="指定某个文件的修改添加到下次提交中"><a href="#指定某个文件的修改添加到下次提交中" class="headerlink" title="指定某个文件的修改添加到下次提交中"></a>指定某个文件的修改添加到下次提交中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="提交本地的所有修改"><a href="#提交本地的所有修改" class="headerlink" title="提交本地的所有修改"></a>提交本地的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br></pre></td></tr></table></figure><h3 id="提交之前已标记的变化"><a href="#提交之前已标记的变化" class="headerlink" title="提交之前已标记的变化"></a>提交之前已标记的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br></pre></td></tr></table></figure><h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br></pre></td></tr></table></figure><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><h3 id="从最新提交开始显示所有的提交记录"><a href="#从最新提交开始显示所有的提交记录" class="headerlink" title="从最新提交开始显示所有的提交记录"></a>从最新提交开始显示所有的提交记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><h3 id="显示指定文件的所有修改"><a href="#显示指定文件的所有修改" class="headerlink" title="显示指定文件的所有修改"></a>显示指定文件的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="谁，在什么时间，修改了文件的什么内容？"><a href="#谁，在什么时间，修改了文件的什么内容？" class="headerlink" title="谁，在什么时间，修改了文件的什么内容？"></a>谁，在什么时间，修改了文件的什么内容？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><h3 id="显示所有分支"><a href="#显示所有分支" class="headerlink" title="显示所有分支"></a>显示所有分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -av</span></span><br></pre></td></tr></table></figure><h3 id="切换当前分支"><a href="#切换当前分支" class="headerlink" title="切换当前分支"></a>切换当前分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于当前分支，创建新分支"><a href="#基于当前分支，创建新分支" class="headerlink" title="基于当前分支，创建新分支"></a>基于当前分支，创建新分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;new-branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于远端分支，创建新的可追溯的分支"><a href="#基于远端分支，创建新的可追溯的分支" class="headerlink" title="基于远端分支，创建新的可追溯的分支"></a>基于远端分支，创建新的可追溯的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="给当前的提交打标签"><a href="#给当前的提交打标签" class="headerlink" title="给当前的提交打标签"></a>给当前的提交打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h2><h3 id="列出当前配置的远端"><a href="#列出当前配置的远端" class="headerlink" title="列出当前配置的远端"></a>列出当前配置的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br></pre></td></tr></table></figure><h3 id="显示远端信息"><a href="#显示远端信息" class="headerlink" title="显示远端信息"></a>显示远端信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加新的远端"><a href="#添加新的远端" class="headerlink" title="添加新的远端"></a>添加新的远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载远端的所有改动到本地，不会自动合并到当前"><a href="#下载远端的所有改动到本地，不会自动合并到当前" class="headerlink" title="下载远端的所有改动到本地，不会自动合并到当前"></a>下载远端的所有改动到本地，不会自动合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将本地版本发布到远端"><a href="#将本地版本发布到远端" class="headerlink" title="将本地版本发布到远端"></a>将本地版本发布到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="删除远端分支"><a href="#删除远端分支" class="headerlink" title="删除远端分支"></a>删除远端分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr &lt;remote/branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="发布标签"><a href="#发布标签" class="headerlink" title="发布标签"></a>发布标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><h2 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h2><h3 id="将分支合并到当前"><a href="#将分支合并到当前" class="headerlink" title="将分支合并到当前"></a>将分支合并到当前</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将当前版本充值到分支中"><a href="#将当前版本充值到分支中" class="headerlink" title="将当前版本充值到分支中"></a>将当前版本充值到分支中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebse &lt;branch&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请勿重置已发布的提交！</p></blockquote><h3 id="退出重置"><a href="#退出重置" class="headerlink" title="退出重置"></a>退出重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort</span></span><br></pre></td></tr></table></figure><h3 id="解决冲突后继续重置"><a href="#解决冲突后继续重置" class="headerlink" title="解决冲突后继续重置"></a>解决冲突后继续重置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span></span></span><br></pre></td></tr></table></figure><h3 id="使用配置好的合并工具去解决冲突"><a href="#使用配置好的合并工具去解决冲突" class="headerlink" title="使用配置好的合并工具去解决冲突"></a>使用配置好的合并工具去解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure><h3 id="在编辑器中手动解决冲去后，标记文件未已解决冲突"><a href="#在编辑器中手动解决冲去后，标记文件未已解决冲突" class="headerlink" title="在编辑器中手动解决冲去后，标记文件未已解决冲突"></a>在编辑器中手动解决冲去后，标记文件未已解决冲突</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;resolved-file&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;resolved-file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="放弃工作目录下的所有修改"><a href="#放弃工作目录下的所有修改" class="headerlink" title="放弃工作目录下的所有修改"></a>放弃工作目录下的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD</span></span><br></pre></td></tr></table></figure><h3 id="放弃某个文件的所有本地修改"><a href="#放弃某个文件的所有本地修改" class="headerlink" title="放弃某个文件的所有本地修改"></a>放弃某个文件的所有本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过创建一个截然不同的新的提交重置一个提交"><a href="#通过创建一个截然不同的新的提交重置一个提交" class="headerlink" title="通过创建一个截然不同的新的提交重置一个提交"></a>通过创建一个截然不同的新的提交重置一个提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"><a href="#将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改"></a>将HEAD重置到上一次提交的版本，并抛弃该版本之后的所有修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"><a href="#将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改"></a>将HEAD重置到上一次提交的版本，并将之后修改标记未未添加到缓存区的修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"><a href="#将HEAD重置到上一次提交的版本，并保留未提交的本地修改" class="headerlink" title="将HEAD重置到上一次提交的版本，并保留未提交的本地修改"></a>将HEAD重置到上一次提交的版本，并保留未提交的本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep &lt;commit&gt;</span></span><br></pre></td></tr></table></figure><h1 id="git信条"><a href="#git信条" class="headerlink" title="git信条"></a>git信条</h1><p><img src="/images/git/git-cheat-sheet-large02-cn.png" alt="git信条"></p><h2 id="提交要对应修改"><a href="#提交要对应修改" class="headerlink" title="提交要对应修改"></a>提交要对应修改</h2><p>&emsp;&emsp;一次提交应该对应一个相关的改动，例如，两个不同的错误应该对应两次不同的提交、使它更容易让其他开发人员明白这个改动，如果这次改动存在问题，也可以方便的回滚到改动之前的状态，通过需存区标记功能。Git可以轻松打造非常精确的提交。</p><h2 id="经常性地提交修改"><a href="#经常性地提交修改" class="headerlink" title="经常性地提交修改"></a>经常性地提交修改</h2><p>&emsp;&emsp;经常的提交改动可以更方便为它作注释。从而更容易确保提交的注释和改动的一致性，通过频繁快速的提交来与其他的开发人员共享这些改动。那样就会避免或减少代码整合时带来的冲突、反之，非常庞大的提交将会增大整合时出现冲突的风险。</p><h2 id="不提交不完整地改动"><a href="#不提交不完整地改动" class="headerlink" title="不提交不完整地改动"></a>不提交不完整地改动</h2><p>&emsp;&emsp;对于一个很大的功能模块来说.完成后再提交并不意味若必须整体完成后才可以，而是要把它正确分割成小的完整的逻辑模块进行经常性的提变，一定不要提交一些不完整的改动。仅仅是因为下班。<br>&emsp;&emsp;同祥，如果只是为了得到一个干净的工作区城也不需要立即提交，可以通过Git的&lt;<stash>&gt;命令把这些改动移到另外的分支。</stash></p><h2 id="提交前进行代码测试"><a href="#提交前进行代码测试" class="headerlink" title="提交前进行代码测试"></a>提交前进行代码测试</h2><p>&emsp;&emsp;不要提交还没有经过完整测试的改动。只有经过测试，并确定无误的改动才能提交。把改动发送给开发团队其他成员前，必须确定所有修改已经完整测试过。这样才算是真正的完成。</p><h2 id="高质量地提交注释"><a href="#高质量地提交注释" class="headerlink" title="高质量地提交注释"></a>高质量地提交注释</h2><p>&emsp;&emsp;提交注释的开头需要一个少于50个字的简短说明.在一个空白的分割行之后要写出一个详细的提交细节.比如回答如下的两个问题；</p><ul><li>出于什么理由需要这个修改？</li><li>基于当前版本.具体改动了什么？</li></ul><p>&emsp;&emsp;为了和自动生成的注释保持一致（例如：git merge），一定要使用现在时态祈使句（比如使用change 而不要使用changed和changes）.</p><h2 id="版本控制不是备份"><a href="#版本控制不是备份" class="headerlink" title="版本控制不是备份"></a>版本控制不是备份</h2><p>&emsp;&emsp;版本控制系统具有一个很强大的附带功能，那就是服务器端的备份功能，但是不要把VCS当成一个备份系统。一定要注意.只需要提交那些有意义的改动而不要仅仅作为文件存储系统来使用。</p><h2 id="使用分支功能"><a href="#使用分支功能" class="headerlink" title="使用分支功能"></a>使用分支功能</h2><p>&emsp;&emsp;自始至终Git的核心就是提供一个快速，简单和灵活的分支功能，分支是一个非常优秀的工具，用来帮助开发人员解决在日常团队开发中存在的代码冲突的问题。因此分支功能应该广泛的运用在不同的开发流程中，比如：开发新的功能、修错等等。</p><h2 id="合理的工作流程"><a href="#合理的工作流程" class="headerlink" title="合理的工作流程"></a>合理的工作流程</h2><p>&emsp;&emsp;Git可以支持很多不同流程；长期分支.特性分支，合并或是重置，git-flow等等选择哪一种流程要取决于如下一些因素；什么项目，什么样的开发，部署模式和（可能是量重要的）开发团队人员的个人习惯.不管怎样。选择什么样的流程都要得到所用开发人员的认同并且一直遭循它</p><h2 id="使用帮助文档"><a href="#使用帮助文档" class="headerlink" title="使用帮助文档"></a>使用帮助文档</h2><p>&emsp;&emsp;显示给定git指令的帮助文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="修炼秘籍"><a href="#修炼秘籍" class="headerlink" title="修炼秘籍"></a>修炼秘籍</h1><p><a href="http://www.git-tower.com/learn" target="_blank" rel="noopener">http://www.git-tower.com/learn</a><br><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/</a><br><a href="http://www.git-scm.org/" target="_blank" rel="noopener">http://www.git-scm.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/git/gswg-git-solid-choice.png&quot; alt=&quot;gswg-git-solid-choice&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;git指令速查表&quot;&gt;&lt;a href=&quot;#git指令速查表&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="tools" scheme="https://zhouyuebiao.cn/categories/tools/"/>
    
    
      <category term="git" scheme="https://zhouyuebiao.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Android系统的编译</title>
    <link href="https://zhouyuebiao.cn/2019/08/16/0030-Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E8%AF%91/"/>
    <id>https://zhouyuebiao.cn/2019/08/16/0030-Android系统的编译/</id>
    <published>2019-08-16T01:16:12.000Z</published>
    <updated>2019-09-04T01:36:20.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_m_marshmallow.jpg" alt="android_m_marshmallow"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="noopener">http://source.android.com/source/initializing.html</a></p><h1 id="Android模块编译流程"><a href="#Android模块编译流程" class="headerlink" title="Android模块编译流程"></a>Android模块编译流程</h1><p>&emsp;&emsp;在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易。</p><h2 id="第一步使build-envsetup-sh生效"><a href="#第一步使build-envsetup-sh生效" class="headerlink" title="第一步使build/envsetup.sh生效"></a>第一步使build/envsetup.sh生效</h2><p>&emsp;&emsp;命令“source build/envsetup.sh”引入了 build/envsetup.sh脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> . build/envsetup.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> build/envsetup.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>envsetup.sh脚本文件里包含vendorsetup.sh 、lunch、 m mm mmm的定义</p></blockquote><h2 id="第二步选择编译类型"><a href="#第二步选择编译类型" class="headerlink" title="第二步选择编译类型"></a>第二步选择编译类型</h2><p>&emsp;&emsp;lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。编译类型会影响最终系统中包含的模块。<br>&emsp;&emsp;如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，此时可以通过输入编号或者名称进行选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lunch full</span><br><span class="line"># 或者</span><br><span class="line">$ lunch &lt;选择一个特定的编译类型&gt;</span><br></pre></td></tr></table></figure><h2 id="最后一步make"><a href="#最后一步make" class="headerlink" title="最后一步make"></a>最后一步make</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里，make的选择有多种，具体内容分到下小节讨论。</p><blockquote><p>make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。</p></blockquote><h2 id="最最后一步清理编译结果"><a href="#最最后一步清理编译结果" class="headerlink" title="最最后一步清理编译结果"></a>最最后一步清理编译结果</h2><h3 id="清理所有编译结果"><a href="#清理所有编译结果" class="headerlink" title="清理所有编译结果"></a>清理所有编译结果</h3><p>&emsp;&emsp;执行清理，相当于：rm -rf out/。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean</span></span><br></pre></td></tr></table></figure><h3 id="清理一个指定模块的编译结果。"><a href="#清理一个指定模块的编译结果。" class="headerlink" title="清理一个指定模块的编译结果。"></a>清理一个指定模块的编译结果。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean-&lt;local_target&gt;</span></span><br></pre></td></tr></table></figure><h1 id="关于make的更多选项"><a href="#关于make的更多选项" class="headerlink" title="关于make的更多选项"></a>关于make的更多选项</h1><p>&emsp;&emsp;以下编译的编译选项可加上 “-j &lt;线程数&gt;”来启动多线程编译，加快编译的速度。</p><h2 id="编译当前选定产品的OTA全量包"><a href="#编译当前选定产品的OTA全量包" class="headerlink" title="编译当前选定产品的OTA全量包"></a>编译当前选定产品的OTA全量包</h2><p>&emsp;&emsp;也叫整包编译(all partitions)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make otapackage</span></span><br></pre></td></tr></table></figure><h2 id="编译所有内容"><a href="#编译所有内容" class="headerlink" title="编译所有内容"></a>编译所有内容</h2><p>&emsp;&emsp;编译所有内容，不管当前产品的定义中是否会包含。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br></pre></td></tr></table></figure><h2 id="编译boot-img"><a href="#编译boot-img" class="headerlink" title="编译boot.img"></a>编译boot.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make bootimage</span></span><br></pre></td></tr></table></figure><h2 id="编译uboot-bin"><a href="#编译uboot-bin" class="headerlink" title="编译uboot.bin"></a>编译uboot.bin</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./mk &lt;uboot对应的版本&gt;  --systemroot</span></span><br></pre></td></tr></table></figure><h2 id="编译-recovery-img-ramdisk-recovery-img"><a href="#编译-recovery-img-ramdisk-recovery-img" class="headerlink" title="编译 recovery.img(ramdisk-recovery.img)"></a>编译 recovery.img(ramdisk-recovery.img)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make recoveryimage</span></span><br></pre></td></tr></table></figure><h2 id="编译vendor-img"><a href="#编译vendor-img" class="headerlink" title="编译vendor.img"></a>编译vendor.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make vendorimage</span></span><br></pre></td></tr></table></figure><h2 id="编译system-img"><a href="#编译system-img" class="headerlink" title="编译system.img"></a>编译system.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make systemimage</span></span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img"><a href="#编译-userdata-img" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make odm_image</span></span><br></pre></td></tr></table></figure><h2 id="编译-userdata-img-1"><a href="#编译-userdata-img-1" class="headerlink" title="编译 userdata.img"></a>编译 userdata.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make userdataimage</span></span><br></pre></td></tr></table></figure><h2 id="编译ramdisk-img"><a href="#编译ramdisk-img" class="headerlink" title="编译ramdisk.img"></a>编译ramdisk.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make ramdisk</span></span><br></pre></td></tr></table></figure><h2 id="编译logo-img"><a href="#编译logo-img" class="headerlink" title="编译logo.img"></a>编译logo.img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make logoimage</span></span><br></pre></td></tr></table></figure><h2 id="快速重建系统镜像"><a href="#快速重建系统镜像" class="headerlink" title="快速重建系统镜像"></a>快速重建系统镜像</h2><p>&emsp;&emsp;从已经编译出的包快速重建系统镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make snod</span></span><br></pre></td></tr></table></figure><h2 id="编译-dtb"><a href="#编译-dtb" class="headerlink" title="编译 dtb"></a>编译 dtb</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make dtbimage</span></span><br></pre></td></tr></table></figure><h2 id="编译出-Android-的-SDK"><a href="#编译出-Android-的-SDK" class="headerlink" title="编译出 Android 的 SDK"></a>编译出 Android 的 SDK</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make sdk</span></span><br></pre></td></tr></table></figure><h2 id="编译所有-JNI-framework"><a href="#编译所有-JNI-framework" class="headerlink" title="编译所有 JNI framework"></a>编译所有 JNI framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make libandroid_runtime</span></span><br></pre></td></tr></table></figure><h2 id="编译所有-Java-framework"><a href="#编译所有-Java-framework" class="headerlink" title="编译所有 Java framework"></a>编译所有 Java framework</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make framework</span></span><br></pre></td></tr></table></figure><h2 id="编译系统服务和相关内容"><a href="#编译系统服务和相关内容" class="headerlink" title="编译系统服务和相关内容"></a>编译系统服务和相关内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make services</span></span><br></pre></td></tr></table></figure><h2 id="编译指定模块"><a href="#编译指定模块" class="headerlink" title="编译指定模块"></a>编译指定模块</h2><p>&emsp;&emsp;编译一个指定的模块，local_target 为模块的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make &lt;local_target&gt;</span></span><br></pre></td></tr></table></figure><h2 id="获取所有产品的编译配置信息"><a href="#获取所有产品的编译配置信息" class="headerlink" title="获取所有产品的编译配置信息"></a>获取所有产品的编译配置信息</h2><p>&emsp;&emsp;显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make dump-products</span></span><br></pre></td></tr></table></figure><h2 id="编译指定产品"><a href="#编译指定产品" class="headerlink" title="编译指定产品"></a>编译指定产品</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make PRODUCT-xxx-yyy</span></span><br></pre></td></tr></table></figure><h2 id="获取帮助信息"><a href="#获取帮助信息" class="headerlink" title="获取帮助信息"></a>获取帮助信息</h2><p>&emsp;&emsp;显示帮助信息，显示主要的make目标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="其他编译选项"><a href="#其他编译选项" class="headerlink" title="其他编译选项"></a>其他编译选项</h2><h3 id="m编译"><a href="#m编译" class="headerlink" title="m编译"></a>m编译</h3><p>m：编译整个安卓系统。（makes from the of the tree）</p><h3 id="mm编译"><a href="#mm编译" class="headerlink" title="mm编译"></a>mm编译</h3><p>mm：编译当前目录下的模块，当前目录下需要有Android.mk这个makefile文件，否则就往上找最近的Android.mk文件。（builds all of the moudles in the current directory）<br>mma：当前目录新增或删除文件后，可以用mma重新编译。</p><h3 id="mmm编译"><a href="#mmm编译" class="headerlink" title="mmm编译"></a>mmm编译</h3><p>mmm：编译指定路径下的模块，指定的路径下面需要有Android.mk这个makefile文件。（builds all of the moudles in the supplies directory）<br>mmma：指定目录下新增或删除文件后，可以用mmma重新编译。 // 未全编译的情况下，可以使用该命令单编译模块</p><h4 id="mmm命令的编译过程"><a href="#mmm命令的编译过程" class="headerlink" title="mmm命令的编译过程"></a>mmm命令的编译过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── build/core/main.mk（是Android编译系统的入口文件）</span><br><span class="line">    ├── build/core/config.mk（会定好编译类型和目标文件）</span><br><span class="line">        ├── build/core/definitions.mk（定义在编译过程中用到的宏）</span><br><span class="line">        ├── ONE_SHOT_MAKEFILE-&gt;build/core/package.mk（编译Apk库文件）</span><br><span class="line">            ├── build/core/java_library.mk（编译Java库文件）</span><br><span class="line">            ├── build/core/static_java_library.mk（编译Java静态库文件）</span><br><span class="line">            ├── build/core/shared_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/dynamic_library.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/binary.mk（ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">            ├── build/core/base_rules.mk （ 计算一些基本变量的值，并创建一些基本的依赖规则）</span><br><span class="line">                ├── build/core/static_library.mk（编译.a静态库文件）</span><br><span class="line">                ├── build/core/executable.mk（编译可执行文件）</span><br><span class="line">                ├── build/core/prebuilt.mk（编译已经预编译好的第三方库文件）</span><br><span class="line">            ├── build/core/Makfile（有system.img、boot.img、recovery.img等镜像文件生成规则）</span><br></pre></td></tr></table></figure><blockquote><p>环境变量ONE_SHOT_MAKEFILE中存放要编译模块的Android.mk的文件路径，如果环境变量值为空，表示执行的是m或者make命令，会对Android源代码中的所有模块进行编译。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_m_marshmallow.jpg&quot; alt=&quot;android_m_marshmallow&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android的分区和启动流程</title>
    <link href="https://zhouyuebiao.cn/2019/08/15/0029-Android%E7%9A%84%E5%88%86%E5%8C%BA%E5%92%8C%E6%98%A0%E5%83%8F/"/>
    <id>https://zhouyuebiao.cn/2019/08/15/0029-Android的分区和映像/</id>
    <published>2019-08-15T01:18:03.000Z</published>
    <updated>2019-09-23T01:49:23.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/andioid_happy.jpg" alt="android"></p><h1 id="Android分区"><a href="#Android分区" class="headerlink" title="Android分区"></a>Android分区</h1><h2 id="什么是分区"><a href="#什么是分区" class="headerlink" title="什么是分区"></a>什么是分区</h2><p>&emsp;&emsp;Android的分区就像是盖房子那样一块块砖块垒起来的，每块砖块放在合适的位置，遇到特特殊的需求，我们就将砖块修正一下（增加或裁减分区），这样我们的房子（Android系统）就慢慢起来了。盖房子需要很多砖头，但是我们Android的大楼主要是由几块砖块组成，这样我们学习起来就简单很多了，毕竟我们不用学习怎么盖一栋楼那么难（手动滑鸡）。<br>&emsp;&emsp;分区的重要性我们可以总结起来：分划决定发展，大小决定成败</p><blockquote><p>分划决定我们要划分不同的大小不同的分区，这个决定了整个平台的规划分区的大小，影响了我们存储的数据量</p></blockquote><p><img src="/images/Android/Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%8C%BA.jpg" alt="Android系统的分区"></p><h2 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h2><p>&emsp;&emsp;分区类型有裸分区和文件系统分区两部分。</p><h3 id="裸分区"><a href="#裸分区" class="headerlink" title="裸分区"></a>裸分区</h3><p>&emsp;&emsp;裸分区是指二进制存储到flash中的数据分区：如fashboot、boot、recovery、misc等</p><h3 id="文件系统分区"><a href="#文件系统分区" class="headerlink" title="文件系统分区"></a>文件系统分区</h3><p>&emsp;&emsp;文件系统分区是指通过挂载进行文件操作的分区，如cache、system、data等</p><h2 id="各个分区的作用"><a href="#各个分区的作用" class="headerlink" title="各个分区的作用"></a>各个分区的作用</h2><p>&emsp;&emsp;通过以上的介绍我们初步了解了分区，也知道了分区的类型，下面对常见分区进行简要的介绍，这些分区在启动过程中发挥不同的作用：</p><ul><li>boot：boot 分区包含通过 mkbootimg 组合在一起的内核映像和 RAM 磁盘。为了直接刷写内核而不刷写新的 boot 分区，可以使用虚拟分区：</li></ul><ul><li>kernel：kernel 虚拟分区仅覆盖内核（zImage、zImage-dtb、Image.gz-dtb），方法是写入新的映像来覆盖旧的映像。为此，它会确定 eMMC 中现有内核映像的起始位置并将新内核映像复制到该位置。请记住，新内核映像可能会大于现有内核映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。如果提供的开发内核不兼容，则可能需要使用相关的内核模块更新 dtb 分区（如果存在）、vendor 分区或 system 分区。</li><li>ramdisk：ramdisk 虚拟分区通过将新映像写入旧磁盘来仅覆盖 RAM 磁盘。为此，它会确定 eMMC 中现有 ramdisk.img 的起始位置并将新 RAM 磁盘映像复制到该位置。请记住，新 RAM 磁盘映像可能会大于现有 RAM 磁盘映像。引导加载程序可以通过移动其后的任何数据来腾出空间或放弃出错的操作。</li></ul><ul><li>system：system 分区主要包含 Android 框架。</li><li>recovery：recovery 分区用于存储在 OTA 过程中启动的恢复映像。如果设备支持 A/B 更新，则恢复映像可以是启动映像中包含的 RAM 磁盘，而不是单独的映像。</li><li>cache：cache 分区用于存储临时数据，如果设备使用 A/B 更新，则可以不要此分区。cache 分区不需要可从引导加载程序写入，而只需要可清空。大小取决于设备类型和 userdata 分区的可用空间。目前，50MB 至 100MB 应该没问题。</li><li>misc：misc 分区供恢复映像使用，存储空间不能小于 4KB。</li><li>userdata：userdata 分区包含用户安装的应用和数据，包括自定义数据。</li><li>metadata：如果设备被加密，则需要使用 metadata 分区，该分区的存储空间不能小于 16MB。</li><li>vendor：vendor 分区包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，则可以省略此分区。</li><li>radio：radio 分区包含无线装置映像。只有包含无线装置且在专用分区中包含无线装置专用软件的设备才需要此分区。</li><li>tos：tos 分区用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用。</li></ul><blockquote><p>摘自：<a href="https://source.android.google.cn/devices/bootloader/partitions-images" target="_blank" rel="noopener">source.android.google</a></p></blockquote><p>&emsp;&emsp;<em>注：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。</em></p><h1 id="通用的Android系统分区"><a href="#通用的Android系统分区" class="headerlink" title="通用的Android系统分区"></a>通用的Android系统分区</h1><p>&emsp;&emsp;安卓手机和平板一般包括以下分区：</p><table><thead><tr><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">/u-boot</td><td align="center">启动分区，引导加载kernel和烧录的作用</td></tr><tr><td align="center">/partition</td><td align="center">partition/parameter.txt存储分区表信息</td></tr><tr><td align="center">/misc</td><td align="center">存储标记升级存储的一些升级信息</td></tr><tr><td align="center">/logo</td><td align="center">开机画面</td></tr><tr><td align="center">/recovery</td><td align="center">升级模块</td></tr><tr><td align="center">/boot</td><td align="center">内核分区（启动Android系统）</td></tr><tr><td align="center">/system</td><td align="center">系统分区</td></tr><tr><td align="center">/cache</td><td align="center">缓存临时文件，和下载升级包存储升级</td></tr><tr><td align="center">/data</td><td align="center">用户数据分区，安装的apk，缓存文件，系统启动的必要文件，数据库等用户相关信息。</td></tr></tbody></table><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p>&emsp;&emsp;此分区包含了一些系统设置和系统功能启用禁用的相关设置。这些设置包括CID(运营商或区域识别码）、USB设置和一些硬件设置等等。这是一个很重要的分区，如果此分区损坏或者部分数据丢失，手机的一些特定功能可能不能正常工作。</p><h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><p>&emsp;&emsp;在正常分区或内核分区被破坏，不能正常启动时，可以进入此分区进行恢复，他相当与一个简易的OS或blos，可以认为是一个boot分区的替代品，通过他可以让我们在这一分区进行备份维护和恢复，我们通常说的刷机便指的是此分区。<br><img src="/images/Android/android_recovery.jpg" alt="android_recovery"><br>&emsp;&emsp;进入此分区方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、通过 adb reboot recovery</span><br><span class="line">2、通过组合键，电源键+音量键</span><br></pre></td></tr></table></figure><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>&emsp;&emsp;此分区可以保证设备正常启动，它包含了kernel（内核）、ramdisk（虚拟内存盘：通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，可以极大的提高在其上进行的文件访问的速度)，如果没有此分区，设备通常不能正常启动。只有必要的时候，才去通过Recovery软件擦除（format）这个分区，一旦擦除，设备只有再重新安装一个新的boot分区，可以通过安装一个包含boot分区的ROM来实现，否则无法启动安卓系统。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>&emsp;&emsp;此分区用来存放除kernel和ramdisk以外的系统相关配置，他包括了用户界面、手机预装的软件等。擦除这个分区将会删除整个系统，但不会导致不能启动。可以通过进入Recovery程序或者bootloader程序中，安装一个新ROM(安卓系统)。</p><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>&emsp;&emsp;此分区包含了用户的数据信息，如：联系人、短信、设置、用户安装的程序的，擦除此分区，相当于手机恢复出厂设置，可以在Recovery模式中选择“data/factory reset ”擦除此分区。</p><p>&emsp;&emsp;此分区下的一些常见目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/data/[packagename]/files 文件缓存目录,一般存小的文件缓存，如果是图片，不建议放这里，一般放到外置卡;</span><br><span class="line">/data/data/[packagename]/cache目录，存放一些其他缓存;</span><br><span class="line">/data/data/[packagename]/databases，存放数据库;</span><br><span class="line">/data/data/[packagename]/lib，应用的so目录;</span><br><span class="line">/data/data/[packagename]/shared_prefs 应用的SharedPreferences保存;</span><br></pre></td></tr></table></figure><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>&emsp;&emsp;此分区是安卓系统缓存区，他保存系统最常访问的数据和应用程序。擦除这个分区，不会影响个人数据，只是删除了这个分区中已经保存的缓存内容，缓存内容会在后续手机使用过程中重新自动生成。</p><h1 id="Android的启动流程"><a href="#Android的启动流程" class="headerlink" title="Android的启动流程"></a>Android的启动流程</h1><p>&emsp;&emsp;Android 从 Linux 系统启动有 4 个步骤；</p><ul><li>init 进程启动</li><li>Native 服务启动</li><li>System Server，Android 服务启动</li><li>Home 启动</li></ul><p><img src="/images/Android/Android%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="Android的启动流程"></p><h2 id="init-initial-进程启动-system-core-init"><a href="#init-initial-进程启动-system-core-init" class="headerlink" title="init(initial)进程启动(system\core\init)"></a>init(initial)进程启动(system\core\init)</h2><p>&emsp;&emsp;init 进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序 init 的方式，完成引导进程。init 始终是第一个进程.<br>&emsp;&emsp;init 进程一起来就根据 init.rc 和 init.xxx.rc 脚本文件建立了几个基本的服<br>务：</p><ul><li>servicemanamger</li><li>zygote</li></ul><p>&emsp;&emsp;最后 init 并不退出，而是担当起 property service 的功能。<br>Property service 就是属性设置</p><h3 id="通过init-rc启动服务"><a href="#通过init-rc启动服务" class="headerlink" title="通过init.rc启动服务"></a>通过init.rc启动服务</h3><p>&emsp;&emsp;system/core/init/init.c 中parse_config_file(Init.rc)<br>&emsp;&emsp;解析脚本文件：init.rc 和 init.xxxx.rc(硬件平台相关)init.rc 是 Android自己规定的初始化脚本(Android Init Language,<br>System/Core/Init/readme.txt)<br>&emsp;&emsp;该脚本包含四个类型的声明：</p><ul><li>Action(动作)</li><li>Commands(命令)</li><li>Services(服务)</li><li>Options(选项)</li></ul><h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>&emsp;&emsp;Servicemanager和zygote进程就奠定了Android的基础。Zygote 这个进程起来才会建立起真正的Android运行空间，初始化建立的 Service 都是 Navtive<br>&emsp;&emsp;service.在.rc 脚本文件中zygote的描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以 Zygote 从 main(…)    frameworks/base/cmds/app_main.cpp 开始</p><ol><li>main(…)     frameworks/base/cmds/app_main.cpp</li></ol><ul><li>建立 Java Runtime</li><li>runtime.start(“com.android.internal.os.ZygoteInit”, startSystemServer);</li></ul><ol start="2"><li>runtime.start    AndroidRuntime.cpp</li></ol><ul><li>建立虚拟机</li><li>运行：com.android.internal.os.ZygoteInit：main 函数。</li></ul><ol start="3"><li>main()   com.android.internal.os.ZygoteInit//正真的 Zygote。</li></ol><ul><li>registerZygoteSocket();//登记 Listen 端口</li><li>startSystemServer();</li><li>进入 Zygote 服务框架。</li></ul><p>&emsp;&emsp;经过这几个步骤，Zygote就建立好了，利用Socket通讯，接收ActivityManangerService的请求，Fork应用程序。<br>&emsp;&emsp;startSystemServer com.android.internal.os.ZygoteInit在Zygote上 fork了一个进程:com.android.server.SystemServer. 于是SystemServer (SystemServer.java）就建立了。Android的所有服务循环框架都是建SystemServer(SystemServer.java)上。在SystemServer.java中看不到循环结构，只是可以看到建立了init2的实现函数，建立了一大堆服务，并 AddService到service Manager。</p><h2 id="Home启动"><a href="#Home启动" class="headerlink" title="Home启动"></a>Home启动</h2><p>&emsp;&emsp;在<a href="mailto:ServerThread@SystemServer.java" target="_blank" rel="noopener">ServerThread@SystemServer.java</a>后半段，我们可以看到系统在启动完所有的Android服务后，做了这样一些动作：</p><ul><li>使用xxx.systemReady()通知各个服务，系统已经就绪。</li><li>特别对于ActivityManagerService.systemReady(回调)</li></ul><p>&emsp;&emsp;Widget.wallpaper,imm(输入法)等ready通知。</p><p>&emsp;&emsp;Home就是在ActivityManagerService.systemReady()通知的过程中建立的。下面是ActivityManagerService.systemReady()的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemReady()@ActivityManagerService.java</span><br><span class="line">resumeTopActivityLocked()</span><br><span class="line">startHomeActivityLocked();<span class="comment">//如果是第一个则启动HomeActivity。</span></span><br><span class="line">startActivityLocked（。。。）CATEGORY_HOME</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/andioid_happy.jpg&quot; alt=&quot;android&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Android分区&quot;&gt;&lt;a href=&quot;#Android分区&quot; class=&quot;headerlink&quot; title=&quot;Android
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android之源起</title>
    <link href="https://zhouyuebiao.cn/2019/08/14/0028-Android%E4%B9%8B%E6%BA%90%E8%B5%B7/"/>
    <id>https://zhouyuebiao.cn/2019/08/14/0028-Android之源起/</id>
    <published>2019-08-14T03:38:25.000Z</published>
    <updated>2019-08-15T01:21:34.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Android/android_in_google.jpg" alt="android_in_google"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Android（读音：英：[‘ændrɔɪd]，美：[ˈænˌdrɔɪd]），常见的非官方中文名称为安卓，是一个基于Linux内核的开放源代码移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触摸屏移动设备如智能手机和平板电脑与其他便携式设备。</p><h1 id="Android的成立"><a href="#Android的成立" class="headerlink" title="Android的成立"></a>Android的成立</h1><p>&emsp;&emsp;2003年10月，有“Android之父”之称的安迪·鲁宾（Andy Rubin）、利奇·米纳尔（Rich Miner）、尼克·席尔斯（Nick Sears）、克里斯·怀特（Chris White）在美国加利福尼亚州帕罗奥图共同成立了Android科技公司（Android Inc.），鲁宾把Android项目描述为“有极大的潜能以开发更智能的移动设备，以更了解其用家的位置及偏好。”该公司早期的方向是为数字相机开发先进的操作系统，此亦是2004年4月该公司向投资者介绍的基础。尽管Android科技公司的创始人和员工过去都具有各自的科技成就，但是Android科技公司的经营只显露出它在智能手机软件的方面，该公司随后认为相机市场不足以实现其目标，并且在5个月之后努力把Android转移到一款可跟Symbian及微软Windows Mobile互相媲美的手机操作系统。</p><p>Android的后续发展：</p><ul><li>2005年7月11日Android Inc.被美国科技企业Google收购。</li><li>2007年11月，Google与84家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良Android，随后，Google以Apache免费开放源代码许可证的授权方式，发布了Android的源代码，开放源代码加速了Android普及，让生产商推出搭载Android的智能手机，Android后来更逐渐拓展到平板电脑及其他领域上。</li><li>2010年末数据显示，Andrioid超越称霸逾十年的诺基亚Symbian系统，成为全球第一大智能手机操作系统。</li><li>2013年6月最高曾有5.38亿台活跃的安卓设备；2013年6月最高曾有10亿台活跃的安卓设备</li><li>2017年3月，Android全球网络流量和设备超越Microsoft Windows，正式成为全球第一大操作系统。</li><li>2018年8月6日，Android 9宣布发行。</li></ul><h1 id="Android命名由来"><a href="#Android命名由来" class="headerlink" title="Android命名由来"></a>Android命名由来</h1><p>&emsp;&emsp;Android一词最早出现于法国作家维利耶·德·利尔－阿达姆·利尔亚当（Auguste Villiers de l’Isle-Adam）在1886年发表的科幻小说《未来夏娃（L’Ève future）》中。他把外表像人的机器人取名为Android。</p><h1 id="Android标志"><a href="#Android标志" class="headerlink" title="Android标志"></a>Android标志</h1><p>&emsp;&emsp;Android是一个全身绿色的机器人，半圆形的头部，有两支天线和空白的点作为眼睛。它的头部与身体之间有空白的区域，相似于一枚有平底的鸡蛋，两侧各有两个圆角矩形，作为它的双臂。Android的标志是由Ascender公司设计，颜色采用了PMS 376C和RGB中十六进制的#A4C639来绘制，这是Android操作系统的品牌象征。当中的文字使用了Ascender公司专门制作的称之为“Google Droid”的字体有时候，它会以纯文字的标志展示。</p><h2 id="Android机器人"><a href="#Android机器人" class="headerlink" title="Android机器人"></a>Android机器人</h2><p><img src="/images/Android/Android_Robot.png" alt="Android_Robot"></p><h2 id="Android字标"><a href="#Android字标" class="headerlink" title="Android字标"></a>Android字标</h2><p><img src="/images/Android/android_logo_no_2x.png" alt="android_logo"></p><h1 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h1><p>&emsp;&emsp;Android系统架构包含以下组件：<br><img src="/images/Android/ape_fwk_all.png" alt="ape_fwk_all"></p><ul><li>应用框架。应用框架最常被应用开发者使用。很多此类 API 都可以直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息，因此如果作为硬件开发者，需要非常了解其中的 API。</li><li>Binder IPC。Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，这使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。</li><li>系统服务。系统服务是专注于特定功能的模块化组件，例如窗口管理器、搜索服务或通知管理器。 应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。</li><li>硬件抽象层 (HAL)。HAL 可定义一个标准接口以供硬件供应商实现，这可让 Android 忽略较低级别的驱动程序实现。借助 HAL，您可以顺利实现相关功能，而不会影响或更改更高级别的系统。HAL 实现会被封装成模块，并会由 Android 系统适时地加载。</li><li>Linux 内核。开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含几个特殊的补充功能，例如：Low Memory Killer（一种内存管理系统，可更主动地保留内存）、唤醒锁定（一种 PowerManager 系统服务）、Binder IPC 驱动程序以及对移动嵌入式平台来说非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任意版本的内核，只要它支持所需功能（如 Binder 驱动程序）即可。</li></ul><h1 id="Android堆栈"><a href="#Android堆栈" class="headerlink" title="Android堆栈"></a>Android堆栈</h1><p>&emsp;&emsp;Android 是一个针对多种不同设备类型打造的开放源代码软件堆栈。Android 的主要目的是为运营商、OEM 和开发者打造一个开放的软件平台，使他们能够将创新理念变为现实，并推出能够卓有成效地改善用户移动体验的真实产品。<br>&emsp;&emsp;Android 平台的设计可确保不存在一个集中瓶颈，即没有任何行业参与者可一手限制或控制其他参与者的创新。这样，我们不但可以打造功能完善的高品质消费类产品，而且可以完全开放源代码，供第三方自由定制和移植。<br><img src="/images/Android/Android%E5%A0%86%E6%A0%88.png" alt="Android 堆栈"></p><h1 id="Android更新时间表"><a href="#Android更新时间表" class="headerlink" title="Android更新时间表"></a>Android更新时间表</h1><table><thead><tr><th align="center">名称</th><th align="center">版本号</th><th align="center">发行日期</th><th align="center">API等级</th><th align="center">安全性更新状态</th></tr></thead><tbody><tr><td align="center">Android 1.0</td><td align="center">1.0</td><td align="center">2008年9月23日</td><td align="center">1</td><td align="center">不支持</td></tr><tr><td align="center">Android Petit Four</td><td align="center">1.1</td><td align="center">2009年2月9日</td><td align="center">2</td><td align="center">不支持</td></tr><tr><td align="center">Android Cupcake</td><td align="center">1.5</td><td align="center">2009年4月27日</td><td align="center">3</td><td align="center">不支持</td></tr><tr><td align="center">Android Donut</td><td align="center">1.6</td><td align="center">2009年9月15日</td><td align="center">4</td><td align="center">不支持</td></tr><tr><td align="center">Android Eclair</td><td align="center">2.0 – 2.1</td><td align="center">2009年10月26日</td><td align="center">5 – 7</td><td align="center">不支持</td></tr><tr><td align="center">Android Froyo</td><td align="center">2.2 – 2.2.3</td><td align="center">2010年5月20日</td><td align="center">8</td><td align="center">不支持</td></tr><tr><td align="center">Android Gingerbread</td><td align="center">2.3 – 2.3.7</td><td align="center">2010年12月6日</td><td align="center">9 – 10</td><td align="center">不支持</td></tr><tr><td align="center">Android Honeycomb</td><td align="center">3.0 – 3.2.6</td><td align="center">2011年2月22日</td><td align="center">11 – 13</td><td align="center">不支持</td></tr><tr><td align="center">Android Ice Cream Sandwich</td><td align="center">4.0 – 4.0.4</td><td align="center">2011年10月18日</td><td align="center">14 – 15</td><td align="center">不支持</td></tr><tr><td align="center">Android Jelly Bean</td><td align="center">4.1 – 4.3.1</td><td align="center">2012年7月9日</td><td align="center">16 – 18</td><td align="center">不支持</td></tr><tr><td align="center">Android KitKat</td><td align="center">4.4 – 4.4.4</td><td align="center">2013年10月31日</td><td align="center">19 – 20</td><td align="center">不支持</td></tr><tr><td align="center">Android Lollipop</td><td align="center">5.0 – 5.1.1</td><td align="center">2014年11月12日</td><td align="center">21 – 22</td><td align="center">不支持</td></tr><tr><td align="center">Android Marshmallow</td><td align="center">6.0 – 6.0.1</td><td align="center">2015年10月5日</td><td align="center">23</td><td align="center">支持</td></tr><tr><td align="center">Android Nougat</td><td align="center">7.0 – 7.1.2</td><td align="center">2016年8月22日</td><td align="center">24 – 25</td><td align="center">支持</td></tr><tr><td align="center">Android Oreo</td><td align="center">8.0 – 8.1</td><td align="center">2017年8月21日</td><td align="center">26 – 27</td><td align="center">支持</td></tr><tr><td align="center">Android Pie</td><td align="center">9.0.0</td><td align="center">2018年8月6日</td><td align="center">28</td><td align="center">支持</td></tr><tr><td align="center">Android Q</td><td align="center">未知</td><td align="center">2019年3月13日</td><td align="center">29</td><td align="center">测试中</td></tr></tbody></table><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/Android" target="_blank" rel="noopener">wiki</a><br><a href="https://source.android.google.cn/setup/community" target="_blank" rel="noopener">Android社区</a></p></blockquote><style>table th:nth-of-type(1){width: 35%;}table th:nth-of-type(2){width: 16%;}table th:nth-of-type(3){width: 25%;}table th:nth-of-type(4){width: 16%;}table th:nth-of-type(5){width: 18%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Android/android_in_google.jpg&quot; alt=&quot;android_in_google&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Android" scheme="https://zhouyuebiao.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://zhouyuebiao.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C语言操作符优先级</title>
    <link href="https://zhouyuebiao.cn/2019/08/09/0027-C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://zhouyuebiao.cn/2019/08/09/0027-C语言操作符优先级/</id>
    <published>2019-08-09T06:32:01.000Z</published>
    <updated>2020-01-03T07:29:46.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/C&C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="C语言操作符优先级"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;表达式的求值顺序是由3个因素决定的：操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序。两个相邻的操作符哪个先执行取决于他们的优先级，如果两者的由优先级相同，那么它们的执行顺序由他们的结核性决定。</p><h1 id="C语言操作符的优先级"><a href="#C语言操作符的优先级" class="headerlink" title="C语言操作符的优先级"></a>C语言操作符的优先级</h1><p>表 5.1 列出了C语言中每个操作符的所有属性：</p><table><thead><tr><th align="center">操作符</th><th align="left">描述</th><th align="center">用法示例</th><th align="left">结果类型</th><th align="center">结合性</th><th align="left">控制求值顺序?</th></tr></thead><tbody><tr><td align="center">()</td><td align="left">聚组</td><td align="center">(表达式)</td><td align="left">与表达式同</td><td align="center">N/A</td><td align="left">否</td></tr><tr><td align="center">()</td><td align="left">函数调用</td><td align="center">rexp(rexp,…,rexp)</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">[]</td><td align="left">下标引用</td><td align="center">rexp[rexp]</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">.</td><td align="left">访问结构成员</td><td align="center">lexp.member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">-&gt;</td><td align="left">访问结构指针成员</td><td align="center">rexp-&gt;member_name</td><td align="left">lexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">后缀自增</td><td align="center">lexp++</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">后缀自减</td><td align="center">lexp–</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!</td><td align="left">逻辑反</td><td align="center">!rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">~</td><td align="left">按位取反</td><td align="center">~rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">单目，表示正值</td><td align="center">+rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">单目，表示负值</td><td align="center">-rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">++</td><td align="left">前缀自增</td><td align="center">++lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#45;&#45;</td><td align="left">前缀自减</td><td align="center">–lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">间接访问</td><td align="center">*rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">取地址</td><td align="center">&amp;lexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">sizeof</td><td align="left">取其长度</td><td align="center">sizeof rexp; sizeof(类型)</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">(类型)</td><td align="left">类型转换</td><td align="center">(类型)rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">*</td><td align="left">乘法</td><td align="center">rexp*rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">/</td><td align="left">除法</td><td align="center">rexp/rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">%</td><td align="left">整数取余</td><td align="center">rexp%rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">+</td><td align="left">加法</td><td align="center">rexp+rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#45;</td><td align="left">减法</td><td align="center">rexp&#45;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移位</td><td align="center">rexp&#60;&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移位</td><td align="center">rexp&gt;&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;</td><td align="left">大于</td><td align="center">rexp&gt;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于</td><td align="center">rexp&gt;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;</td><td align="left">小于</td><td align="center">rexp&#60;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于</td><td align="center">rexp&#60;=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">==</td><td align="left">等于</td><td align="center">rexp==rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">!=</td><td align="left">不等于</td><td align="center">rexp!=rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;</td><td align="left">位于</td><td align="center">rexp&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">^</td><td align="left">位异或</td><td align="center">rexp^rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;</td><td align="left">位或</td><td align="center">rexp&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&amp;&amp;</td><td align="left">逻辑与</td><td align="center">rexp&amp;&amp;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">否</td></tr><tr><td align="center">&#124;&#124;</td><td align="left">逻辑或</td><td align="center">rexpre&#124;&#124;rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr><tr><td align="center">?:</td><td align="left">条件操作符</td><td align="center">rexp?rexp:rexp</td><td align="left">rexp</td><td align="center">N/A</td><td align="left">是</td></tr><tr><td align="center">=</td><td align="left">赋值</td><td align="center">lexp=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">+=</td><td align="left">以…加</td><td align="center">lexp+=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">-=</td><td align="left">以…减</td><td align="center">lexp-=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#42;=</td><td align="left">以…乘</td><td align="center">lexp &#42;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">/=</td><td align="left">以…除</td><td align="center">lexp/=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">%=</td><td align="left">以…取模</td><td align="center">lexp%=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">以…左移</td><td align="center">lexp&lt;&lt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">以…右移</td><td align="center">lexp&gt;&gt;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&amp;=</td><td align="left">以…与</td><td align="center">lexp&amp;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">^=</td><td align="left">以…异或</td><td align="center">lexp^=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">&#124;=</td><td align="left">以…或</td><td align="center">lexp&#124;=rexp</td><td align="left">rexp</td><td align="center">R-L</td><td align="left">否</td></tr><tr><td align="center">,</td><td align="left">逗号</td><td align="center">rexp,rexp</td><td align="left">rexp</td><td align="center">L-R</td><td align="left">是</td></tr></tbody></table><h1 id="附：Markdown特殊字符转义"><a href="#附：Markdown特殊字符转义" class="headerlink" title="附：Markdown特殊字符转义"></a>附：Markdown特殊字符转义</h1><p>&emsp;&emsp;虽然hexo的语法是Markdown格式的，但是在书写时对于特殊字符使用“\“转义是不严谨的做法，最好的方式是使用特殊字符对应的编码，对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    &amp;emsp;          --&gt; 空格(Space)</span><br><span class="line">!   &amp;#33;           --&gt; 惊叹号 (Exclamation mark) </span><br><span class="line">”   &amp;#34; &amp;quot;    --&gt; 双引号 (Quotation mark)</span><br><span class="line">#   &amp;#35;           --&gt; 数字标志 (Number sign)</span><br><span class="line">$   &amp;#36;           --&gt; 美元标志(Dollar sign)</span><br><span class="line">%   &amp;#37;           --&gt; 百分号(Percent sign)</span><br><span class="line">&amp;   &amp;#38; &amp;amp;     --&gt; 和号(Ampersand)</span><br><span class="line">|   &amp;#124;          --&gt; 竖线(Vertical bar) </span><br><span class="line">‘   &amp;#39;           --&gt; 单引号(Apostrophe) </span><br><span class="line">(   &amp;#40;           --&gt; 小括号左边部分(Left parenthesis) </span><br><span class="line">)   &amp;#41;           --&gt; 小括号右边部分(Right parenthesis) </span><br><span class="line">+   &amp;#43;           --&gt; 加号(Plus sign)</span><br><span class="line">-   &amp;#45; &amp;minus;   --&gt; 减号(Minus sign)</span><br><span class="line">*   &amp;#42;           --&gt; 星号(Asterisk)</span><br><span class="line">\   &amp;#92;           --&gt; 反斜杠(Reverse solidus (backslash)) </span><br><span class="line">&lt;   &amp;#60; &amp;lt;      --&gt; 小于号(Less than) </span><br><span class="line">=   &amp;#61;           --&gt; 等于符号(Equals sign)</span><br><span class="line">&gt;   &amp;#62;           --&gt; 大于号(Greater than)</span><br><span class="line">?   &amp;#63;           --&gt; 问号(Question mark)</span><br><span class="line">@   &amp;#64;           --&gt; 在标志(Commercial at)</span><br><span class="line">[   &amp;#91;           --&gt; 中括号左边部分(Left square bracket) </span><br><span class="line">]   &amp;#93;           --&gt; 中括号右边部分(Right square bracket)</span><br><span class="line">&#123;   &amp;#123;          --&gt; 大括号左边部分(Left curly brace) </span><br><span class="line">&#125;   &amp;#125;          --&gt; 大括号右边部分(Right curly brace)</span><br></pre></td></tr></table></figure><style>table th:nth-of-type(1){width: 10%;}table th:nth-of-type(2){width: 20%;}table th:nth-of-type(3){width: 30%;}table th:nth-of-type(4){width: 15%;}table th:nth-of-type(5){width: 10%;}table th:nth-of-type(6){width: 15%;}</style>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/C&amp;C++/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg&quot; alt=&quot;C语言操作符优先级&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Repo入门</title>
    <link href="https://zhouyuebiao.cn/2019/08/08/0026-repo%E5%85%A5%E9%97%A8/"/>
    <id>https://zhouyuebiao.cn/2019/08/08/0026-repo入门/</id>
    <published>2019-08-08T09:49:55.000Z</published>
    <updated>2019-08-09T06:33:18.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>&emsp;&emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自动化部分开发工作流程。但是Repo并不是要取代Git，只是为了让Git更容易使用。repo命令只是一个可执行的Python脚本，我们可以将其放在路径中的任何位置。</p><h1 id="Repo、Git、Gerrit三者的区别"><a href="#Repo、Git、Gerrit三者的区别" class="headerlink" title="Repo、Git、Gerrit三者的区别"></a>Repo、Git、Gerrit三者的区别</h1><h2 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h2><p>&emsp;&emsp;Git 是一个开放源代码的版本控制系统，专用于处理分布在多个代码库上的大型项目。在 Android 环境中，我们会使用 Git 执行本地操作，例如建立本地分支、提交、查看更改、修改。</p><h2 id="1-2-Repo"><a href="#1-2-Repo" class="headerlink" title="1.2 Repo"></a>1.2 Repo</h2><p>&emsp;&emsp;Repo 是我们以 Git 为基础构建的代码库管理工具。Repo 可以在必要时整合多个 Git 代码库，将相关内容上传到我们的修订版本控制系统，并自动执行 Android 开发工作流程的部分环节。Repo 并非用来取代 Git，只是为了让我们在 Android 环境中更轻松地使用 Git。Repo 命令是一段可执行的 Python 脚本，我们可以将其放在路径中的任何位置。使用 Android 源代码文件时，就可以使用 Repo 执行跨网络操作。例如，可以借助单个 Repo 命令，将文件从多个代码库下载到本地工作目录。</p><h2 id="1-3-Gerrit"><a href="#1-3-Gerrit" class="headerlink" title="1.3 Gerrit"></a>1.3 Gerrit</h2><p>&emsp;&emsp;Gerrit 是一个基于网页的代码审核系统，适用于使用 Git 的项目。Gerrit 允许所有授权用户提交更改（如果通过代码审核，这些更改会自动纳入项目中），以此鼓励其他人更集中地使用 Git。此外，Gerrit 可以在浏览器中并排显示更改，并支持代码内注释，使得审核工作变得更轻松！</p><h1 id="2-Repo的工作原理"><a href="#2-Repo的工作原理" class="headerlink" title="2. Repo的工作原理"></a>2. Repo的工作原理</h1><p>&emsp;&emsp;repo需要关注当前git库的数量、名称、路径等，有了这些基本信息，才能对这些git库进行操作。通过集中维护所有git库的清单，repo可以方便的从清单中获取git库的信息。 这份清单会随着版本演进升级而产生变化，同时也有一些本地的修改定制需求，所以，repo是通过一个git库来管理项目的清单文件的，这个git库名字叫manifests。<br>&emsp;&emsp;当打开repo这个可执行的python脚本后，发现代码量并不大(不超过1000行)，难道仅这一个脚本就完成了AOSP数百个git库的管理吗？并非如此。 repo是一系列脚本的集合，这些脚本也是通过git库来维护的，这个git库名字叫repo。<br>&emsp;&emsp;在客户端使用repo初始化一个项目时，就会从远程把manifests和repo这两个git库拷贝到本地，但这对于Android开发人员来说，又是近乎无形的(一般通过文件管理器，是无法看到这两个git库的)。 repo将自动化的管理信息都隐藏根目录的.repo子目录中。</p><h1 id="3-安装Repo"><a href="#3-安装Repo" class="headerlink" title="3. 安装Repo"></a>3. 安装Repo</h1><p>创建目录并修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h2 id="3-1-下载repo"><a href="#3-1-下载repo" class="headerlink" title="3.1 下载repo"></a>3.1 下载repo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x ~/bin/repo</span></span><br></pre></td></tr></table></figure><h2 id="3-3-获取帮助"><a href="#3-3-获取帮助" class="headerlink" title="3.3 获取帮助"></a>3.3 获取帮助</h2><p>&emsp;&emsp;安装 Repo 后，运行以下命令可以找到最新文档（开头是包含所有命令的摘要）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-查询具体命令的帮助"><a href="#3-4-查询具体命令的帮助" class="headerlink" title="3.4 查询具体命令的帮助"></a>3.4 查询具体命令的帮助</h2><p>&emsp;&emsp;在 Repo 树中运行以下命令来获取有关某个命令的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> &lt;COMMAND&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-查看Repo-init-参数的说明和选项列表"><a href="#3-5-查看Repo-init-参数的说明和选项列表" class="headerlink" title="3.5 查看Repo init 参数的说明和选项列表"></a>3.5 查看Repo init 参数的说明和选项列表</h2><p>&emsp;&emsp;此命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（要了解详情，请参阅 <a href="https://source.android.com/source/using-repo.html#init" target="_blank" rel="noopener">init</a>。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo <span class="built_in">help</span> init</span></span><br></pre></td></tr></table></figure><h1 id="4-初始化仓库"><a href="#4-初始化仓库" class="headerlink" title="4. 初始化仓库"></a>4. 初始化仓库</h1><p>&emsp;&emsp;初始化仓库命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示范：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MY_WORKING_DIRECTORY</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo init -u https://android.googlesource.com/platform/manifest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这将在当前目录中安装 Repo。这会创建一个 .repo/ 目录，其中包含用于 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo/ 目录中还包含 manifest.xml，这是一个指向 .repo/manifests/ 目录中所选清单的符号链接。<br>选项：</p><ul><li>-u：指定要从中检索清单代码库的网址。可以在 <a href="https://android.googlesource.com/platform/manifest" target="_blank" rel="noopener">https://android.googlesource.com/platform/manifest</a> 中找到常见清单</li><li>-m：在代码库中选择清单文件。如果未选择任何清单名称，则会默认选择 default.xml。</li><li>-b：指定修订版本，即特定的清单分支。</li></ul><blockquote><p>注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo/ 的父目录或相应父目录的子目录。</p></blockquote><h1 id="5-拉取仓库"><a href="#5-拉取仓库" class="headerlink" title="5. 拉取仓库"></a>5. 拉取仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> repo sync PROJECT0 PROJECT1 PROJECT2 ...</span></span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-j <numbers>： 多任务，一般8核心可以开到16任务,过多会起反作用</numbers></li><li>-c： 只下载当前分支代码</li><li>-d： 让工程回退到manifest指定的版本</li><li>-f： 如果某个工程同步失败，继续同步</li></ul><h1 id="6-修改仓库结构"><a href="#6-修改仓库结构" class="headerlink" title="6. 修改仓库结构"></a>6. 修改仓库结构</h1><p>&emsp;&emsp;如果想修改repo的结构，应该在 .repo/manifests 文件夹里面修改 default.xml 文件，然后用git命令提交。default.xml 文件内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">"git://git.mygit.com/"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"kk-shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">"shift"</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">"1"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"packages/shift/VideoPlayer"</span> <span class="attr">name</span>=<span class="string">"platform/packages/shift/VideoPlayer"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"another_manifest.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>该文件内容的理解，请移步</p></blockquote><h1 id="7-理解repo-init后生成的-repo目录结构"><a href="#7-理解repo-init后生成的-repo目录结构" class="headerlink" title="7. 理解repo init后生成的.repo目录结构"></a>7. 理解repo init后生成的.repo目录结构</h1><p>&emsp;&emsp;当我们执行repo init命令之后会在当前目录下生成’.repo’目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree .repo -L 1</span></span><br><span class="line">.repo</span><br><span class="line">├── manifests</span><br><span class="line">├── manifests.git</span><br><span class="line">├── manifest.xml -&gt; manifests/default.xml</span><br><span class="line">├── project.list</span><br><span class="line">├── projects</span><br><span class="line">└── repo</span><br></pre></td></tr></table></figure><p>.repo目录理解：</p><ul><li>manifests：一个git库，包含default.xml文件，用于描述repo所管理的git库的信息</li><li>manifests.git：manifest这个git库的实体，manifest/.git目录下的所有文件都会链接到该目录</li><li>manifests/default.xml：工作树的主配置文件，一般不要编辑这个文件</li><li>projects/：每个git工程的 .git结构</li><li>manifest.xml：这是一个指向 .repo/manifests/ 目录中所选清单的符号链接</li><li>project.list：git库的所有仓库列表</li><li>repo/： 一个git库，包含repo运行的所有脚本</li></ul><h1 id="8-default-xml-文件解读"><a href="#8-default-xml-文件解读" class="headerlink" title="8. default.xml 文件解读"></a>8. default.xml 文件解读</h1><ul><li>manifest<br>&emsp;&emsp;这个是配置的顶层元素，即根标志</li><li>remote</li></ul><ul><li>name：在每一个.git/config文件的remote项中用到这个name，即表示每个git的远程服务器的名字(这个名字很关键，如果多个remote属性的话，default属性中需要指定default remote)。git pull、get fetch的时候会用到这个remote name。</li><li>alias ：可以覆盖之前定义的remote name，name必须是固定的，但是alias可以不同，可以用来指向不同的remote url</li><li>fetch ：所有git url真正路径的前缀，所有git 的project name加上这个前缀，就是git url的真正路径</li><li>review ：指定Gerrit的服务器名，用于repo upload操作。如果没有指定，则repo upload没有效果</li></ul><ul><li>default<br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</li></ul><ul><li>remote ：远程服务器的名字（上面remote属性中提到过，多个remote的时候需要指定default remote，就是这里设置了）</li><li>revision ：所有git的默认branch，后面project没有特殊指出revision的话，就用这个branch</li><li>sync_j ： 在repo sync中默认并行的数目</li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li></ul><ul><li>manifest-server<br>它的url属性用于指定manifest服务的URL，通常是一个XML RPC 服务，它要支持一下RPC方法：</li></ul><ul><li>GetApprovedManifest(branch, target) ：返回一个manifest用于指示所有projects的分支和编译目标。</li><li>target参数来自环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT，组成$TARGET_PRODUCT-$TARGET_BUILD_VARIANT</li><li>GetManifest(tag) ：返回指定tag的manifest</li></ul><ul><li>project<br>需要clone的单独git</li></ul><ul><li>name ：git 的名称，用于生成git url。URL格式是：${remote fetch}/${project name}.git 其中的 fetch就是上面提到的remote 中的fetch元素，name 就是此处的name</li><li>path ：clone到本地的git的工作目录，如果没有配置的话，跟name一样</li><li>remote ：定义remote name，如果没有定义的话就用default中定义的remote name</li><li>revision ：指定需要获取的git提交点，可以定义成固定的branch，或者是明确的commit 哈希值</li><li>groups ：列出project所属的组，以空格或者逗号分隔多个组名。所有的project都自动属于”all”组。每一个project自动属于</li><li>name:’name’ 和path:’path’组。例如<project name="monkeys" path="barrel-of">，它自动属于default, name:monkeys, and path:barrel-of组。如果一个project属于notdefault组，则，repo sync时不会下载</project></li><li>sync_c ：如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。</li><li>sync_s ： 如果设置为true，则会同步git的子项目</li><li>upstream ：在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间</li><li>annotation ：可以有0个或多个annotation，格式是name-value，repo forall命令是会用来定义环境变量</li></ul><ul><li>include<br>通过name属性可以引入另外一个manifest文件(路径相对与当前的manifest.xml 的路径)</li></ul><ul><li>name ：另一个需要导入的manifest文件名字<br>可以在当前的路径下添加一个another_manifest.xml，这样可以在另一个xml中添加或删除project</li></ul><ul><li>remove-project<br>&emsp;&emsp;从内部的manifest表中删除指定的project。经常用于本地的manifest文件，用户可以替换一个project的定义</li></ul><h1 id="9-Google提供的参考资源"><a href="#9-Google提供的参考资源" class="headerlink" title="9. Google提供的参考资源"></a>9. Google提供的参考资源</h1><p>&emsp;&emsp;主页：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;错误报告：<a href="https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo" target="_blank" rel="noopener">https://bugs.chromium.org/p/gerrit/issues/list?q=component:repo</a><br>&emsp;&emsp;资料来源：<a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a><br>&emsp;&emsp;概述：<a href="https://source.android.com/source/developing.html" target="_blank" rel="noopener">https://source.android.com/source/developing.html</a><br>&emsp;&emsp;文档：<a href="https://source.android.com/source/using-repo.html" target="_blank" rel="noopener">https://source.android.com/source/using-repo.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Repo是一个建立在Git之上的工具。Repo帮助管理许多Git存储库，上传到修订控制系统，并自
      
    
    </summary>
    
      <category term="Git" scheme="https://zhouyuebiao.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://zhouyuebiao.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C语言显示数据处理进度条</title>
    <link href="https://zhouyuebiao.cn/2019/07/11/0025-C%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>https://zhouyuebiao.cn/2019/07/11/0025-C语言显示数据处理进度条/</id>
    <published>2019-07-11T07:03:41.000Z</published>
    <updated>2019-07-11T09:42:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。<br>&emsp;&emsp;我们见过比如使用git clone命令下载的时候显示的进度那样的效果，类似的还有很多，很多linux命令执行后一般都会有进度条显示，那么我们该怎样实现那样的效果呢？</p><blockquote><p>操作环境：linux；Linux+GCC</p></blockquote><h1 id="从C语言printf格式化控制台移动光标说起"><a href="#从C语言printf格式化控制台移动光标说起" class="headerlink" title="从C语言printf格式化控制台移动光标说起"></a>从C语言printf格式化控制台移动光标说起</h1><p>&emsp;&emsp;在Linux环境下，光标的移动、背景色和字体颜色的设置非常简单。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\033[47;31mhello world\033[5m"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;47是字背景颜色, 31是字体的颜色, hello world是字符串. 后面的\033[5m是控制码。字背景颜色范围: 40–49 字颜色: 30–39。<br>表2-1 字背景颜色及字颜色范围表</p><table><thead><tr><th align="center">数值</th><th align="left">背景颜色</th><th align="center">数值</th><th align="left">字颜色</th></tr></thead><tbody><tr><td align="center">40</td><td align="left">黑</td><td align="center">30</td><td align="left">黑</td></tr><tr><td align="center">41</td><td align="left">红</td><td align="center">31</td><td align="left">红</td></tr><tr><td align="center">42</td><td align="left">绿</td><td align="center">32</td><td align="left">绿</td></tr><tr><td align="center">43</td><td align="left">黄</td><td align="center">33</td><td align="left">黄</td></tr><tr><td align="center">44</td><td align="left">蓝</td><td align="center">34</td><td align="left">蓝</td></tr><tr><td align="center">45</td><td align="left">紫</td><td align="center">35</td><td align="left">紫</td></tr><tr><td align="center">46</td><td align="left">深绿</td><td align="center">36</td><td align="left">深绿</td></tr><tr><td align="center">47</td><td align="left">白色</td><td align="center">37</td><td align="left">白色</td></tr></tbody></table><p>表2-2 ANSI控制码表</p><table><thead><tr><th align="center">ANSI控制码</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">\033[0m</td><td align="left">关闭所有属性</td></tr><tr><td align="center">\033[1m</td><td align="left">设置高亮度</td></tr><tr><td align="center">\03[4m</td><td align="left">下划线</td></tr><tr><td align="center">\033[5m</td><td align="left">闪烁</td></tr><tr><td align="center">\033[7m</td><td align="left">反显</td></tr><tr><td align="center">\033[8m</td><td align="left">消隐</td></tr><tr><td align="center">\033[30m – \033[37m</td><td align="left">设置前景色</td></tr><tr><td align="center">\033[40m – \033[47m</td><td align="left">设置背景色</td></tr><tr><td align="center">\033[nA</td><td align="left">光标上移n行</td></tr><tr><td align="center">\03[nB</td><td align="left">光标下移n行</td></tr><tr><td align="center">\033[nC</td><td align="left">光标右移n行</td></tr><tr><td align="center">\033[nD</td><td align="left">光标左移n行</td></tr><tr><td align="center">\033[y;xH</td><td align="left">设置光标位置</td></tr><tr><td align="center">\033[2J</td><td align="left">清屏</td></tr><tr><td align="center">\033[K</td><td align="left">清除从光标到行尾的内容</td></tr><tr><td align="center">\033[s</td><td align="left">保存光标位置</td></tr><tr><td align="center">\033[u</td><td align="left">恢复光标位置</td></tr><tr><td align="center">\033[?25l</td><td align="left">隐藏光标</td></tr><tr><td align="center">\33[?25h</td><td align="left">显示光标</td></tr></tbody></table><h2 id="实现显示进度条代码"><a href="#实现显示进度条代码" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法的优点是，由于每次打印显示之前都是先将光标移动到行首并将其后的所有输出内容清除，因此当控制台有其他字符输出时，也不会导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress（进度百分比，取值为0~100）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,本次显示进度条时所输出的字符个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移动到行首并清除从当前光标到行尾的所有内容 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\033[k"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回本次显示进度条时所输出的字符个数 */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用’-b’退格字符实现"><a href="#使用’-b’退格字符实现" class="headerlink" title="使用’\b’退格字符实现"></a>使用’\b’退格字符实现</h1><p>&emsp;&emsp;在C语言中，提供了转义字符’\b’来进行输出后的退格操作。在编程过程中，我们有时候需要进行退格操作。但是，我在以前使用的过程中，发现我使用语句printf(“abc\b”);之后，在输出结果中还是显示的abc并不是我希望得到的ab。</p><h2 id="用法及原理"><a href="#用法及原理" class="headerlink" title="用法及原理"></a>用法及原理</h2><p>&emsp;&emsp;在用’\b’进行退格操作的时候，实际上，每次使用’\b’字符之后，控制台的输出光标会后退一个字符的位置，但是并没有将相应的字符删除。所以，我们需要在’\b’字符后面紧跟一个字符，用来代替需要删除的字符。如果后面没有需要输出的字符，可以用至少一个空格跟在’\b’后面，用来替换需要删除的字符。<br>&emsp;&emsp;该’\b’退格字符，也可以多个连用，以实现对多个字符的删除操作，但是需要注意的是，想要删除几个字符就要使用至少几个’\b’，对应的也需要有相等数量的字符用来替换待删除的字符。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="对单个字符进行退格操作（删除单个字符）"><a href="#对单个字符进行退格操作（删除单个字符）" class="headerlink" title="对单个字符进行退格操作（删除单个字符）"></a>对单个字符进行退格操作（删除单个字符）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\bv"</span>);  <span class="comment">//此处的输出结果是abv，后面的'v'就是用来替换'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b"</span>);  <span class="comment">//此处的输出结果是abc，可以看出虽然用了'\b'退格，但是并没有提供相应的用来替换最后一个字符'c'的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abc\b "</span>);  <span class="comment">//此处的输出结果是ab，因为在'\b'后面，跟了一个空格' '来替换了字符'c'</span></span><br></pre></td></tr></table></figure><h3 id="对多个字符进行退格操作（删除字符串）"><a href="#对多个字符进行退格操作（删除字符串）" class="headerlink" title="对多个字符进行退格操作（删除字符串）"></a>对多个字符进行退格操作（删除字符串）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b.new"</span>);  <span class="comment">//此处的输出结果是ph.new，后面的字符串".new"是用来替换"rase"的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"phrase\b\b\b\b newString"</span>);  <span class="comment">//此处输出的结果是ph  newString，中间用了两个空格来代替字符串"ra"，紧接着用了两个字符"ne"来代替字符串"se"，再后面多出的"wString"字符串，则原样输出。</span></span><br></pre></td></tr></table></figure><h2 id="实现显示进度条代码-1"><a href="#实现显示进度条代码-1" class="headerlink" title="实现显示进度条代码"></a>实现显示进度条代码</h2><p>&emsp;&emsp;这个方法有个致命的缺点，当控制台有其他字符输出的时候会打乱现有的显示位置，导致显示位置错乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 在控制台打印显示进度条</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param[in] progress           进度百分比，取值为0~100</span></span><br><span class="line"><span class="comment">* @param[in] last_char_count    上一次显示进度条时所用到的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return i,目前进度条打印的字符个数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">display_progress</span><span class="params">(<span class="keyword">int</span> progress, <span class="keyword">int</span> last_char_count)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把上次显示的进度条信息全部清空*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; last_char_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\b"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处输出‘=’，显示进度，以‘&gt;&gt;’结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; progress; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"="</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">    <span class="comment">/* 输出空格截止到第104的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i += <span class="number">2</span>; i &lt; <span class="number">104</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输出进度条百分比 */</span></span><br><span class="line">    i = i + <span class="built_in">printf</span>(<span class="string">"[%d%%]"</span>, progress);  </span><br><span class="line">    <span class="comment">/* 系统必要的输出策略，刷新输出缓冲区才能显示 */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*返回本次显示进度条时所输出的字符个数*/</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===================================================================================================&gt;&gt;   [99%]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用多线程进行较大的数据处理的时候，多开一个线程用于显示数据处理进度，这样会使得程序运行的体验更好。&lt;br&gt;&amp;em
      
    
    </summary>
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://zhouyuebiao.cn/tags/C-C/"/>
    
  </entry>
  
</feed>
